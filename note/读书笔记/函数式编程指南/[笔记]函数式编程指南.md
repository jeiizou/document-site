---
title: '[笔记]函数式编程指南'
date: 2018-09-30 16:46:36
category:
    - 笔记
    - 函数式编程指南
tags:
    - 函数式编程
---


> 函数式编程指南: 第一章到第九章

<!-- more -->

# 函数式编程

> 来自 GitBook:[JS 函数式编程指南](https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)

## 一等公民的函数

看如下的例子:

```js
// 太傻了
var getServerStuff = function(callback) {
    return ajaxCall(function(json) {
        return callback(json);
    });
};

// 这才像样
var getServerStuff = ajaxCall;
```

<!-- more -->

错误的垃圾代码:

```js
var BlogController = (function() {
    var index = function(posts) {
        return Views.index(posts);
    };

    var show = function(post) {
        return Views.show(post);
    };

    var create = function(attrs) {
        return Db.create(attrs);
    };

    var update = function(post, attrs) {
        return Db.update(post, attrs);
    };

    var destroy = function(post) {
        return Db.destroy(post);
    };

    return { index: index, show: show, create: create, update: update, destroy: destroy };
})();
```

实际上, 可以重写成这样:

```js
var BlogController = {
    index: Views.index,
    show: Views.show,
    create: Db.create,
    update: Db.update,
    destroy: Db.destroy
};
```

### 为何钟爱一等公民

如果一个函数被不必要地包裹起来了，而且发生了改动，那么包裹它的那个函数也要做相应的变更。

```js
httpGet('/post/2', function(json) {
    return renderPost(json);
});
```

如果 httpGet 要改成可以抛出一个可能出现的 err 异常，那我们还要回过头去把“胶水”函数也改了。

```js
// 把整个应用里的所有 httpGet 调用都改成这样，可以传递 err 参数。
httpGet('/post/2', function(json, err) {
    return renderPost(json, err);
});
```

写成一等公民函数的形式，要做的改动将会少得多：

```js
httpGet('/post/2', renderPost); // renderPost 将会在 httpGet 中调用，想要多少参数都行
```

## 纯函数的好处

纯函数是这样一种函数, 即相同的输入, 永远会得到相同的输出, 而且没有任何可观察的副作用.

比如`slice`和`splice`, 这两个函数的作用并无二致. 但是它们各自的方式却大不同. 我们说`slice`符合纯函数定义是因为对相同的输入它保证能返回相同的输出, 而`splice`却会娇兰调用它的那个数组, 然后再吐出来, 这就会产生可观察到的副作用, 即这个数组永久改变了.

```js
let xs = [1, 2, 3, 4, 5];

//纯的
xs.slice(0, 3);
//=>[1,2,3]

xs.slice(0, 3);
//=>[1,2,3]

xs.slice(0, 3);
//=>[1,2,3]

//不纯的
xs.splice(0, 3);
//=> [1,2,3]

xs.splice(0, 3);
//=> [4,5]

xs.splice(0, 3);
//=> []
```

在函数式编程中, 我们讨厌这种改变数据的本函数. 我们追求的是那种可靠的, 每次都能返回同样结果的函数, 而不是像`splice`这样会吧数据改变的函数.

下面来看另一个例子:

```js
// 不纯的
var minimum = 21;

var checkAge = function(age) {
    return age >= minimum;
};

// 纯的
var checkAge = function(age) {
    var minimum = 21;
    return age >= minimum;
};
```

在不纯的版本中, `checkAge`的结果将取决于`minimum`这个可变变量的值. 换句话说, 它取决于系统状态, 因为引入了外部的环境, 从而增加了认知负荷(cognitive load).

这种依赖状态是影响系统复杂度的罪魁祸首.

使用纯函数的形式, 函数就能做到自给自足, 我们也可以让`minimum`成为一个不可变(immutable)对象, 这样就能保留纯粹性, 因为状态不会有变化. 要实现这个效果, 必须创建一个对象, 然后调用`Object.freeze`方法:

```js
var immutableState = Object.freeze({
    minimum: 21
});
```

### 副作用

**副作用** 是什么, 我们可以理解为一切除结果计算之外发生的事情.

作用本身并没有坏处, 而副作用的关键在于"副". 就像一潭死水的"水"本身并不是幼虫的培养皿, "死"才是生成虫群的关键原因. 同理, 副作用中的"副"是滋生 bug 的温床.

> 副作用实在计算结果的过程中, 系统状态的一种变化, 或者与外部世界进行的可观察的交互.

副作用可能包含, 但不限于:

-   更改文件系统
-   往数据库插入记录
-   发送一个 http 请求
-   可变数据
-   打印/log
-   获取用户输入
-   DOM 查询
-   访问系统状态

这个列表还可以继续写下去. 概括来讲, 只要是跟函数外部环境发生的交互就都是副作用--这一点可能会让我们怀疑无副作用编程的可行性. 函数式编程的哲学就是假定副作用是造成不正当行为的主要原因.

这并不是说, 要禁止使用一切副作用, 而是说, 要让它们在可控的范围内发生. 后面提及`funtor`和`monad`的时候, 我们会学习如何控制他们. 但不是现在.

### 八年级数学

> 函数是不同数组的特殊关系: 每一个输入值返回且只返回一个输出值.

换句话说, 函数只是两种数值之间的关系: 输入和输出. 尽量每个输入都只会一个输出, 但不同的输入却可以有相同的输出.

纯函数, 就是数学上的函数, 而且是函数式编程的全部. 使用这些纯函数编程能够带来大量的好处

### 追求"纯"的理由

#### 可缓存性

首先纯函数总能根据输入来做缓存. 实现缓存的一种典型方式是 memoize 技术:

```js
var squareNumber = memoize(function(x) {
    return x * x;
});

squareNumber(4);
//=> 16

squareNumber(4); // 从缓存中读取输入值为 4 的结果
//=> 16

squareNumber(5);
//=> 25

squareNumber(5); // 从缓存中读取输入值为 5 的结果
//=> 25
```

下面的代码是一个简单的实现, 尽管它不太健壮:

```js
var memoize = function(f) {
    var cache = {};

    return function() {
        var arg_str = JSON.stringify(arguments);
        cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
        return cache[arg_str];
    };
};
```

值得注意的一点是, 可以通过延迟执行的方式把不纯的函数转换为纯函数:

```js
var pureHttpCall = memoize(function(url, params) {
    return function() {
        return $.getJSON(url, params);
    };
});
```

这里我们没有真正发送 http 请求, 而只是返回了一个函数. 当调用它的时候才会发送请求. 这个函数之所以有资格成为纯函数, 是因为它总是会根据相同的输入返回相同的输出: 给定`url`和`params`之后, 他就只会返回同一个发送 http 请求的函数.

这个`memoize`函数工作起来没有任何问题, 虽然它缓存的并不是 http 请求所返回的结果, 而是生成的函数.

现在来看这种方式意义不大，不过很快我们就会学习一些技巧来发掘它的用处。重点是我们可以缓存任意一个函数，不管它们看起来多么具有破坏性。

#### 可移植性/自文档化(Portable/Self-Dpcumenting)

纯函数完全是自给自足的, 它需要的所有东西都能轻易获得. 仔细思考这一点. 混函数的依赖明显, 跟易于观察和理解.

```js
// 不纯的
var signUp = function(attrs) {
  var user = saveUser(attrs);
  welcomeUser(user);
};

var saveUser = function(attrs) {
    var user = Db.save(attrs);
    ...
};

var welcomeUser = function(user) {
    Email(user, ...);
    ...
};

// 纯的
var signUp = function(Db, Email, attrs) {
  return function() {
    var user = saveUser(Db, attrs);
    welcomeUser(Email, user);
  };
};

var saveUser = function(Db, attrs) {
    ...
};

var welcomeUser = function(Email, user) {
    ...
};
```

通过强迫"注入"依赖, 或者把它们当做参数传递, 我们的应用也更加灵活; 因为数据库或者邮件客户端等等都参数化了. 如果要使用另一个`DB`, 只需要修改传递的参数就可以了.

在 JS 中, 可移植性意味着把函数序列化(serializing)并通过 socket 发送. 也可以意味着代码能够在 web workers 中运行.

命令式编程中"典型"的方法和过程都深深根植与它们所在的环境中, 通过状态, 依赖和有效作用达成. 纯函数于此相反, 它与环境无关, 只要我们愿意, 可以在任何地方运行.

#### 可测试性（Testable）

纯函数让测试更加容易. 我们不需要伪造真实环境, 也不需要断言状态. 只要简单的给函数一个输入, 然后断言实处就好了.

#### 合理性(Reasonable)

很多人相信使用纯函数最大的好处是引用透明性(referential reansparency). 如果一段代码可以替换成它所执行得到的结果, 而且是在不改变整个程序行为的前提下替换的. 那么我们就说这段代码是引用透明的.

纯函数的特性保证了引用透明性.

```js
var Immutable = require('immutable');

var decrementHP = function(player) {
    return player.set('hp', player.hp - 1);
};

var isSameTeam = function(player1, player2) {
    return player1.team === player2.team;
};

var punch = function(player, target) {
    if (isSameTeam(player, target)) {
        return target;
    } else {
        return decrementHP(target);
    }
};

var jobe = Immutable.Map({ name: 'Jobe', hp: 20, team: 'red' });
var michael = Immutable.Map({ name: 'Michael', hp: 20, team: 'green' });

punch(jobe, michael);
//=> Immutable.Map({name:"Michael", hp:19, team: "green"})
```

#### 并行代码

我们可以并行运行任意纯函数. 因为纯函数根本不需要访问共享的内存, 而且根据其定义, 纯函数也不会因副作用而进入竞争态(race condition).

并行代码在服务端 js 混进以及使用了 web worker 的浏览器哪里是非常容易实现的. 因为它使用了线程. 不过出于对非纯函数复杂度的考虑, 当前主流观点还是避免使用这种并行.

## 柯里化(curry)

### 不可或缺的 curry

curry 的概念很简单: 只传递给函数一部分参数来调用它, 让它返回一个函数去处理剩下的参数.

我们可以一次性地调用 curry 函数, 也可以每次值传递一个参数分多次调用.

```js
var add = function(x) {
    return function(y) {
        return x + y;
    };
};

var increment = add(1);
var addTen = add(10);

increment(2);
// 3

addTen(2);
// 12
```

我们来创建一些 curry 函数.

```js
var curry = require('lodash').curry;

var match = curry(function(what, str) {
    return str.match(what);
});

var replace = curry(function(what, replacement, str) {
    return str.replace(what, replacement);
});

var filter = curry(function(f, ary) {
    return ary.filter(f);
});

var map = curry(function(f, ary) {
    return ary.map(f);
});
```

在上面的代码中遵循的是一种简单, 同时也是非常重要的模式. 即策略性地把要操作的数据, 放到最后一个参数里. 到使用它们的时候你就明白这样做的原因是什么了.

```js
match(/\s+/g, 'hello world');
// [ ' ' ]

match(/\s+/g)('hello world');
// [ ' ' ]

var hasSpaces = match(/\s+/g);
// function(x) { return x.match(/\s+/g) }

hasSpaces('hello world');
// [ ' ' ]

hasSpaces('spaceless');
// null

filter(hasSpaces, ['tori_spelling', 'tori amos']);
// ["tori amos"]

var findSpaces = filter(hasSpaces);
// function(xs) { return xs.filter(function(x) { return x.match(/\s+/g) }) }

findSpaces(['tori_spelling', 'tori amos']);
// ["tori amos"]

var noVowels = replace(/[aeiou]/gi);
// function(replacement, x) { return x.replace(/[aeiou]/ig, replacement) }

var censored = noVowels('*');
// function(x) { return x.replace(/[aeiou]/ig, "*") }

censored('Chocolate Rain');
// 'Ch*c*l*t* R**n'
```

这里表明的是一种"预加载"函数的能力

### 不仅仅是双关

curry 的用处非常广泛, 就像在`hasSpaces`,`findSpace`和`censored`看到的那样, 只需要传给函数一些参数就能得到一个新的函数.

使用`map`简单的把参数是单个元素的函数包裹一下, 就能把它转换成参数维数组的函数.

```js
var getChildren = function(x) {
    return x.childNodes;
};

var allTheChildren = map(getChildren);
```

只传给函数一部分参数通常也叫做 _局部调用_ , 能够大量减少样板文件代码. 考虑上面`allTheChildren`函数, 如果 loadsh 的普通`map`来写会是什么样的:

```js
var allTheChildren = function(elements) {
    return _.map(elements, getChildren);
};
```

通常不定义直接操作数组的函数, 因为只要内联调用`map(getChildren)`就能达到目的. 这一点同样适用于`sort`,`filter`以及其他的高阶函数.(高阶函数: 参数或返回值为函数的函数)

当我们谈论纯函数的时候, 我们说它们接受一个输入返回一个输出. curry 函数所做的正是这样: 每传递一个参数调用函数, 就返回一个新函数处理剩余的参数. 这就是一个输入对应一个输出.

## 代码组合

### 函数饲养

这就是 **组合** (compose, 以下将称之为组合)

```js
var compose = function(f, g) {
    return function(x) {
        return f(g(x));
    };
};
```

`f`和`g`都是函数, `x`是在它们之间通过"管道"传输的值.

**组合** 看起来像是在饲养函数. 你就是饲养员, 选择两个有特点又遭你喜欢的函数, 让它们结合, 产下下一个崭新的函数. 组合用法如下:

```js
var toUpperCase = function(x) {
    return x.toUpperCase();
};
var exclaim = function(x) {
    return x + '!';
};
var shout = compose(
    exclaim,
    toUpperCase
);

shout('send in the clowns');
//=> "SEND IN THE CLOWNS!"
```

两个函数组合之后返回一个新函数是完全讲得通的: 组合某种类型(本例中是函数)的两个元素本就该生成一个该类型的新元素. 把两个乐高积木组合起来绝不可能得到一个林肯积木. 所以这是有道理的.

在`compose`的定义中, `g`将先于`f`执行, 因此就创建了一个从右到左的数据流. 这样做的可读性远远高于嵌套一大堆的函数调用, 如果不用组合, `shout`函数将会是这样的:

```js
var shout = function(x) {
    return exclaim(toUpperCase(x));
};
```

让代码从右到左运行, 而不是由内而外运行. 下面看一个顺序很重要的例子:

```js
var head = function(x) {
    return x[0];
};
var reverse = reduce(function(acc, x) {
    return [x].concat(acc);
}, []);
var last = compose(
    head,
    reverse
);

last(['jumpkick', 'roundhouse', 'uppercut']);
//=> 'uppercut'
```

尽管我们可以定义一个从左向右的版本，但是从右向左执行更加能够反映数学上的含义——是的，组合的概念直接来自于数学课本。实际上，现在是时候去看看所有的组合都有的一个特性了。

```js
// 结合律（associativity）
var associative =
    compose(
        f,
        compose(
            g,
            h
        )
    ) ==
    compose(
        compose(
            f,
            g
        ),
        h
    );
// true
```

这个特性就是结合律, 符合结合律意味着不管是你把`g`和`h`分到一组, 还是把`f`和`g`分到一组都不重要. 所以, 如果我们想把字符串变为大写, 可以这么写:

```js
compose(
    toUpperCase,
    compose(
        head,
        reverse
    )
);

// 或者
compose(
    compose(
        toUpperCase,
        head
    ),
    reverse
);
```

因为如何为 `compose` 的调用分组不重要，所以结果都是一样的。这也让我们有能力写一个可变的组合（variadic compose），用法如下：

```js
// 前面的例子中我们必须要写两个组合才行，但既然组合是符合结合律的，我们就可以只写一个，
// 而且想传给它多少个函数就传给它多少个，然后让它自己决定如何分组。

var lastUpper = compose(
    toUpperCase,
    head,
    reverse
);

lastUpper(['jumpkick', 'roundhouse', 'uppercut']);
//=> 'UPPERCUT'

var loudLastUpper = compose(
    exclaim,
    toUpperCase,
    head,
    reverse
);

loudLastUpper(['jumpkick', 'roundhouse', 'uppercut']);
//=> 'UPPERCUT!'
```

运用结合律能为我们带来强大的灵活性, 还有对执行结果不会出现意外的那种平和心态.

结合律的一大好处是任何一个函数分组都可以被拆开来, 然后再以他们自己的组合方式打包在一起. 让我们来重构前面的例子:

```js
var loudLastUpper = compose(
    exclaim,
    toUpperCase,
    head,
    reverse
);

// 或
var last = compose(
    head,
    reverse
);
var loudLastUpper = compose(
    exclaim,
    toUpperCase,
    last
);

// 或
var last = compose(
    head,
    reverse
);
var angry = compose(
    exclaim,
    toUpperCase
);
var loudLastUpper = compose(
    angry,
    last
);

// 更多变种...
```

### pointfree

pointfree 模式指的是, 永远不必说出你的数据. 意思是, 函数无序提及将要操作的数据是什么样的. 一等公民的函数, 柯里化以及组合协作起来非常有助于实现这种模式.

```js
// 非 pointfree，因为提到了数据：word
var snakeCase = function(word) {
    return word.toLowerCase().replace(/\s+/gi, '_');
};

// pointfree
var snakeCase = compose(
    replace(/\s+/gi, '_'),
    toLowerCase
);
```

观察这里`replace`是如何被局部调用的. 这里所做的事情就是通过管道把数据在接受单个参数的函数间传递. 利用 curry, 我们能够做到让每个函数都先接收数据, 然后操作数据, 最后再把数据传递到下一个函数哪里去. 另外注意在 pointfree 版本中, 不需要`word`参数就能构造函数; 而在非 pointfree 版本中, 必须要有 word 才能进行一些操作.

再看一个例子:

```js
// 非 pointfree，因为提到了数据：name
var initials = function(name) {
    return name
        .split(' ')
        .map(
            compose(
                toUpperCase,
                head
            )
        )
        .join('. ');
};

// pointfree
var initials = compose(
    join('. '),
    map(
        compose(
            toUpperCase,
            head
        )
    ),
    split(' ')
);

initials('hunter stockton thompson');
// 'H. S. T'
```

pointfree 模式能够帮助我们减少不必要的命名, 让代码保持间接和通用. 对函数式代码来说, pointfree 是非常好的石蕊实验, 因为它能告诉我一个函数是否是接受输入返回输出的小函数. 比如, while 循环是不能组合的. 不过 pointfree 是一把双刃剑, 有时候也能混淆视听. 并非所有的函数式代码都是 pointfree 的. 可是使用它的时候就是用, 不能使用的时候就用普通函数.

### debug

组合的一个常见错误是, 在没有局部调用之前, 就组合类似`map`这样接受两个参数的函数.

```js
// 错误做法：我们传给了 `angry` 一个数组，根本不知道最后传给 `map` 的是什么东西。
var latin = compose(
    map,
    angry,
    reverse
);

latin(['frog', 'eyes']);
// error

// 正确做法：每个函数都接受一个实际参数。
var latin = compose(
    map(angry),
    reverse
);

latin(['frog', 'eyes']);
// ["EYES!", "FROG!"])
```

如果在 debug 组合的时候遇到了困难, 那么可以使用下面这个使用的, 但是不纯的`trace`函数来追踪代码的执行情况.

```js
var trace = curry(function(tag, x) {
    console.log(tag, x);
    return x;
});

var dasherize = compose(
    join('-'),
    toLower,
    split(' '),
    replace(/\s{2,}/gi, ' ')
);

dasherize('The world is a vampire');
// TypeError: Cannot read property 'apply' of undefined
```

这里报错了，来 `trace` 下：

```js
var dasherize = compose(
    join('-'),
    toLower,
    trace('after split'),
    split(' '),
    replace(/\s{2,}/gi, ' ')
);
// after split [ 'The', 'world', 'is', 'a', 'vampire' ]
```

`toLower` 的参数是一个数组，所以需要先用 map 调用一下它。

```js
var dasherize = compose(
    join('-'),
    map(toLower),
    split(' '),
    replace(/\s{2,}/gi, ' ')
);

dasherize('The world is a vampire');

// 'the-world-is-a-vampire'
```

`trace` 函数允许我们在某个特定的点观察数据以便 debug。像 haskell 和 purescript 之类的语言出于开发的方便，也都提供了类似的函数。
组合将成为我们构造程序的工具，而且幸运的是，它背后是有一个强大的理论做支撑的。

### 范畴学

范畴学（category theory）是数学中的一个抽象分支，能够形式化诸如集合论（set theory）、类型论（type theory）、群论（group theory）以及逻辑学（logic）等数学分支中的一些概念。范畴学主要处理对象（object）、态射（morphism）和变化式（transformation），而这些概念跟编程的联系非常紧密。下图是一些相同的概念分别在不同理论下的形式：

![avatar](/img/cat_theory.png)

在范畴学中, 有一个概念叫做...范畴. 有着以下这些组件(component)的搜集(collection)就构成一个范畴:

-   对象的搜索
-   态射的搜索
-   态射的组合
-   identity 这个独特的态射

范畴学抽象到足以模拟任何事物, 不过我们现在最关心的还是类型和函数, 所以让我们把范畴学运用到它们身上看看.

#### 对象的搜集

对象就是数据类型, 例如`String`,`Boolean`,`Number`和`Object`等等. 通常我们把数据类型是做所有可能的值得一个集合(set). 像`Boolean`就可以看做是`[true, false]`的集合, `Number`可以使所有实数的一个集合. 把类型当做集合对待是有好处的, 因为我们可以利用集合论(set theory)处理类型.

#### 态射的搜集

态射是标准的, 普通的纯函数.

#### 态射的组合

本章中介绍的组合, 我们在上面讨论的`compose`函数是符合结合律的. 这并非巧合, 结合律是在范畴学中对任何组合都适用的一个特性.

看一个具体的例子:

```js
var g = function(x) {
    return x.length;
};
var f = function(x) {
    return x === 4;
};
var isFourLetterWord = compose(
    f,
    g
);
```

#### identity 这个独特的态射

我们介绍一个名为`id`的使用函数. 这个函数接受随便什么输入然后原封不动的返回:

```js
var id = function(x) {
    return x;
};
```

我们在后面还要讨论这个函数, 暂时先把它当做一个可以替代给定值的函数-- 一个假装自己是普通数据的函数.

`id`函数跟组合一起使用简直完美. 下面这个特性对所有一元函数(只接受一个参数的函数) `f`都成立.

```js
// identity
(compose(
    id,
    f
) ==
    compose(
        f,
        id
    )) ==
    f;
// true
```

这就是实数的单位元(identity property).

除了类型和函数, 还有什么范畴呢? 比如我们可以定义一个有向图（directed graph），以节点为对象，以边为态射，以路径连接为组合。还可以定义一个实数类型（Number），以所有的实数为对象，以 >= 为态射（实际上任何偏序（partial order）或全序（total order）都可以成为一个范畴）。范畴的总数是无限的，但是要达到本书的目的，我们只需要关心上面定义的范畴就好了。

## 示例应用

### 声明式代码

从本章开始, 我们将不再只是计算机如何工作, 而是指出我们明确希望得到的结果.

与命令式不同, 声明式意味着我们要写表达式, 而不是一步一步的指示.

以 SQL 为例, 它就没有"先做这个, 在做那个"的命令, 有的只是一个指明我们想要从数据库去什么数据的表达式. 至于如何取数据则由它自己决定. 数据库的升级和 SQL 引擎的优化, 根本不需要更爱查询语句. 这是因为, 有多种方式解析一个表达式并得到相同的结果.

为了理解"声明式"这个概念, 下面来写几个例子找找感觉:

```js
// 命令式
var makes = [];
for (i = 0; i < cars.length; i++) {
    makes.push(cars[i].make);
}

// 声明式
var makes = cars.map(function(car) {
    return car.make;
});
```

命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器，把各种零零散散的东西都展示出来...实在是直白得有些露骨。  
使用 map 的版本是一个表达式，它对执行顺序没有要求。而且，map 函数如何进行迭代，返回的数组如何收集，都有很大的自由度。它指明的是做什么，不是怎么做。因此，它是正儿八经的声明式代码。

关于性能, 这里有一个 JIT 优化代码的相关知识: [这是一个视频(需要 FQ)](https://www.youtube.com/watch?v=65-RbBwZQdU)

再看一个例子:

```js
// 命令式
var authenticate = function(form) {
    var user = toUser(form);
    return logIn(user);
};

// 声明式
var authenticate = compose(
    logIn,
    toUser
);
```

虽然命令式的版本不一定是做的, 但还是硬编码了那种一部接一部的执行方式. 而`compose`表达式只是简单地指出了这样一个事实: 用户验证是`toUser`和`logIn`两个行为的组合. 这再次说明, 声明式潜在的代码更新提供了支持, 使得我们的应用代码成为了一种高级规范(high level specofication).

因为声明式代码不指定执行顺序, 所以它天然地适合进行并行运算.

### 一个函数式的 flickr

现在我们用一种声明式的, 可组合的方式创建一个实例应用, 暂时我们还是使用了一些副作用. 这个示例应用是一个浏览器 wedget, 功能是从 flickr 获取图片:

html:

```js
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.11/require.min.js"></script>
    <script src="flickr.js"></script>
  </head>
  <body></body>
</html>
```

flickr.js:

```js
requirejs.config({
    paths: {
        ramda: 'https://cdnjs.cloudflare.com/ajax/libs/ramda/0.13.0/ramda.min',
        jquery: 'https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min'
    }
});

require(['ramda', 'jquery'], function(_, $) {
    ////////////////////////////////////////////
    // Utils

    var Impure = {
        getJSON: _.curry(function(callback, url) {
            $.getJSON(url, callback);
        }),

        setHtml: _.curry(function(sel, html) {
            $(sel).html(html);
        })
    };

    var img = function(url) {
        return $('<img />', { src: url });
    };

    var trace = _.curry(function(tag, x) {
        console.log(tag, x);
        return x;
    });

    ////////////////////////////////////////////

    var url = function(t) {
        return 'https://api.flickr.com/services/feeds/photos_public.gne?tags=' + t + '&format=json&jsoncallback=?';
    };

    var mediaUrl = _.compose(
        _.prop('m'),
        _.prop('media')
    );

    var srcs = _.compose(
        _.map(mediaUrl),
        _.prop('items')
    );

    var images = _.compose(
        _.map(img),
        srcs
    );

    var renderImages = _.compose(
        Impure.setHtml('body'),
        images
    );

    var app = _.compose(
        Impure.getJSON(renderImages),
        url
    );

    app('cats');
});
```

这里使用了`ramda`库.

这里的代码做了四件事:

1. 根据特定搜索关键字构造 url
2. 向 flickr 发送 api 请求
3. 把返回的 json 转为 html 图片
4. 把图片放到屏幕上.

注意: 从 flickr 的 api 获取数据和在屏幕上放置图片这两件事. 我们吸纳来定义这两个动作以便隔离他们:

声明式规范, 只说做什么, 不说怎么做.

每一行代码都视作一个等式, 变量名所代表的的属性就是等式的含义.

### 有原则的重构

原有代码:

```js
var mediaUrl = _.compose(
    _.prop('m'),
    _.prop('media')
);

var srcs = _.compose(
    _.map(mediaUrl),
    _.prop('items')
);

var images = _.compose(
    _.map(img),
    srcs
);
```

等式推导加纯函数的特性,内联调用`srcs`和`images`:

```js
var mediaUrl = _.compose(
    _.prop('m'),
    _.prop('media')
);

var images = _.compose(
    _.map(img),
    _.map(mediaUrl),
    _.prop('items')
);
```

应用组合律:

```js
var mediaUrl = _.compose(
    _.prop('m'),
    _.prop('media')
);

var images = _.compose(
    _.map(
        _.compose(
            img,
            mediaUrl
        )
    ),
    _.prop('items')
);
```

现在只需要循环一次就可以把每一个对象都转为 img 标签了。我们把 map 调用的 compose 取出来放到外面，提高一下可读性。

```js
var mediaUrl = _.compose(
    _.prop('m'),
    _.prop('media')
);

var mediaToImg = _.compose(
    img,
    mediaUrl
);

var images = _.compose(
    _.map(mediaToImg),
    _.prop('items')
);
```

## Hindley-Milner 类型签名

### 初识类型

刚接触函数式编程的人容易深陷类型签名(type signatures)的泥淖.  
类型(type)是让所有不同背景的人都能高效沟通的元语言. 很大程度上, 类型签名是以"Hidley-Milne"系统写就的.

类型签名还衍生出了"自由定理 (free theorems) "的概念. 因为类型是可以推断的, 所以明确的类型签名并不是必要的;

```js
//  capitalize :: String -> String
var capitalize = function(s) {
    return toUpperCase(head(s)) + toLowerCase(tail(s));
};

capitalize('smurf');
//=> "Smurf"
```

这里, 我们关注`Hindley-Milner`系统中, 函数都写成类似`a->b`这个样子, 其中`a`和`b`是任意类型的变量. 因此, `capitalize`函数的类型签名可以理解为"一个接受`String`返回`String`的函数".

一些函数签名:

```js
//  strLength :: String -> Number
var strLength = function(s) {
    return s.length;
};

//  join :: String -> [String] -> String
var join = curry(function(what, xs) {
    return xs.join(what);
});

//  match :: Regex -> String -> [String]
var match = curry(function(reg, s) {
    return s.match(reg);
});

//  replace :: Regex -> String -> String -> String
var replace = curry(function(reg, sub, s) {
    return s.replace(reg, sub);
});
```

单独观察`match`函数, 在不了解细节时这样理解: 接受一个`Regex`和`String`, 返回一个`[String]`. 但是如下进行分组:

```js
//  match :: Regex -> (String -> [String])
var match = curry(function(reg, s) {
    return s.match(reg);
});
```

这样我们可以理解为`match`函数接受一个`Regex`作为参数, 返回一个从`String`到`[String]`的函数. 因为 curry, 造成的结果就是这样: 给`match`函数一个`Regex`,得到一个新函数, 能够处理`String`参数. 这样的看待方式, 有助于理解为何最后一个类型是返回值.

```js
//  match :: Regex -> (String -> [String])

//  onHoliday :: String -> [String]
var onHoliday = match(/holiday/gi);
```

这里的`onHoliday`就是已经有了`Regex`参数的`match`:

```js
//  replace :: Regex -> (String -> (String -> String))
var replace = curry(function(reg, sub, s) {
    return s.replace(reg, sub);
});
```

另一种更简单的思路是: `replace`接受三个参数, 分别是`Regex`,`String`和另一个`String`, 返回的还是一个`String`.

最后几点:

```js
//  id :: a -> a
var id = function(x) {
    return x;
};

//  map :: (a -> b) -> [a] -> [b]
var map = curry(function(f, xs) {
    return xs.map(f);
});
```

这里有个原则: 对于相同的变量名, 其类型也是一定相同.

对于`map`, 函数接受两个参数, 第一个是任意类型的`a`到`b`的函数; 第二个是一个数组, 元素是任意类型的`a`; 返回的是一个类型`b`的数组.

类型签名可以告诉我们函数做了什么事情.

辨别类型和它们的含义可以让我们在函数式编程的路上走的更远.

一些提供理解的例子:

```js
//  head :: [a] -> a
var head = function(xs) {
    return xs[0];
};

//  filter :: (a -> Bool) -> [a] -> [a]
var filter = curry(function(f, xs) {
    return xs.filter(f);
});

//  reduce :: (b -> a -> b) -> b -> [a] -> b
var reduce = curry(function(f, x, xs) {
    return xs.reduce(f, x);
});
```

看`reduce`函数的签名, 第一个参数是个函数, 该函数接受一个`b`和一个`a`并返回一个`b`, 签名中的第二个和第三个参数就是`b`和元素为`a`的数组, 唯一的假设是这里的`b`和每一个`a`都将传给前面的参数作为参数. 最后返回一个结果`b`, 也就是说`reduce`的第一个参数函数的输出就是`reduce`函数的输出. 知道了`reduce`的含义, 我们才能使得上面的假设是正确的.

### 缩小可能性范围

一旦引入一个类型变量, 就会出现一个奇怪的特性: parametricty ( https://en.wikipedia.org/wiki/Parametricity ) . 这个特性表明, 函数会议一种统一的行为作用于所有的类型.

```js
// head :: [a] -> a
```

`head`可以看到接受`[a]`返回`a`. 我们除了知道参数是个数组, 其他一概不知. 所以函数的功能就只限于操作这个数组上. `a`不是一个`特定`的类型, 意味着它可以是`任意`类型; 那么我们的函数对每一个可能的操作的类型都必须保持统一. 这就是 **parametricty** 的含义.

再看另一个例子:

```js
// reverse :: [a] -> [a]
```

仅从类型签名来看，reverse 可能的目的是什么？再次强调，它不能对 a 做任何特定的事情。它不能把 a 变成另一个类型，或者引入一个 b；这都是不可能的。那它可以排序么？答案是不能，没有足够的信息让它去为每一个可能的类型排序。它能重新排列么？可以的，我觉得它可以，但它必须以一种可预料的方式达成目标。另外，它也有可能删除或者重复某一个元素。重点是，不管在哪种情况下，类型 a 的多态性（polymorphism）都会大幅缩小 reverse 函数可能的行为的范围。

这种“可能性范围的缩小”（narrowing of possibility）允许我们利用类似 Hoogle 这样的类型签名搜索引擎去搜索我们想要的函数。类型签名所能包含的信息量真的非常大。

### 自由定理

类型签名除了能够帮助我们推断函数可能的实现, 还能够给我们带来 _自由定理( free theorems )_ 下面是两个例子(http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf):

```js
// head :: [a] -> a
compose(
    f,
    head
) ==
    compose(
        head,
        map(f)
    );

// filter :: (a -> Bool) -> [a] -> [a]
compose(
    map(f),
    filter(
        compose(
            p,
            f
        )
    )
) ==
    compose(
        filter(p),
        map(f)
    );
```

第一个例子说, 等式左边说的是, 先获得数组的`头部`, 然后对它调用函数`f`; 等式右边说, 先对数组中的每一个元素调用`f`, 然后再取返回其`头部`. 这两个表达式在结果上是等价的.

第二个例子说, 等式左边先组合`f`和`p`检查哪些元素要过滤. 再通过`map`实际调用`f`; 等式右边是说, 先调用`map`调用`f`, 然后再根据`p`过滤元素. 这两个也是相等的.

### 类型约束

签名可以吧类型约束为一个特定的接口(interface):

```js
// sort :: Ord a => [a] -> [a]
```

解释如下: `a`一定是一个`Ord`对象. 也就是说`a`必须要实现`Ord`对象. 这里的`Ord`如果强类型语言中, 它可能就是一个自定义的接口, 能够让不同的值排序. 通过这个方式, 我们不仅能够获取关于`a`的更多信息, 了解`sort`函数具体作用, 还能限制函数的作用范围. 我们这种接口声明叫做 _类型约束_(type constrains)

```js
// assertEqual :: (Eq a, Show a) => a -> a -> Assertion
```

这个例子中有两个约束: `Eq`和`Show`. 它们保证了我们可以检查不同的`a`是否相等, 并在有不相等的情况下打印出其中的差异.

## 特百惠

### 容器

我们通过管道把数据在一系列纯函数间传递的程序来书写函数式编程.

这些程序就是声明式的行为规范, 但是控制流(control flow), 异常处理(error handling), 异步操作(asynchronous actions)和状态(state), 还有更棘手的作用(effects)如何处理.

首先我们将创建一个容器(container), 这个容器必须能够装在任意类型的值, 并且是一个对象, 但是不会向这个对象的属性和方法. 我们将它当做一个百宝箱--一个存放宝贵的数据的特殊盒子.

```js
var Container = function(x) {
    this.__value = x;
};

Container.of = function(x) {
    return new Container(x);
};
```

使用`Container.of`作为构造器,就能构造`Container`对象:

-   `Container`是个只有一个属性的对象. 尽管容器可以由不止一个属性, 但是一般来说容器还是只有一个. 我们很对已地把`Container`的这个属性命名为`__value`.
-   `__value`不能是某个特定的类型.
-   数据一旦存放到`Container`, 就会一直待在哪里. 我们可以用`.__value`获取到数据.

### 第一个 functor

一旦容器里有了值, 不管这个值是什么, 我们需要一种方法来让别的函数操作它.

```js
// (a -> b) -> Container a -> Container b
Container.prototype.map = function(f) {
    return Container.of(f(this.__value));
};

//使用
Container.of(2).map(function(two) {
    return two + 2;
});
//=> Container(4)

Container.of('flamethrowers').map(function(s) {
    return s.toUpperCase();
});
//=> Container("FLAMETHROWERS")

Container.of('bombs')
    .map(concat(' away'))
    .map(_.prop('length'));
//=> Container(10)
```

这种方法能够在不离开`Container`的情况下操作容器内部的值. 我们把值传递给`map`函数之后就能任意的进行操作, 操作结束后, 为了防止意外在把它放回它所属的`Container`. 这样, 我们能连续的调用`map`, 运行任何我们想运行的函数, 甚至改变值得类型.

这里就出现了`functor`.(functor 是实现了`map`函数并遵守一些特定容器规则的容器类型.) _functor_ 就是一个签了合约的接口. functor 是范畴学的概念.

### 薛定谔的 Maybe

`Container`有时我们会称为`Identity`, 与`id`函数的作用相同, 除此之外吗还有另外一种 functor, 那就是实现了`map`函数的类似容器的数据类型, 这种`functor`在调用`map`的时候能够提供非常有用的行为.

```js
var Maybe = function(x) {
    this.__value = x;
};

Maybe.of = function(x) {
    return new Maybe(x);
};

Maybe.prototype.isNothing = function() {
    return this.__value === null || this.__value === undefined;
};

Maybe.prototype.map = function(f) {
    return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));
};
```

`Maybe`与`Container`非常类似, 但是有一点不同: `Maybe`会先检查自己的值是否为空, 然后才调用传进来的函数.

```js
Maybe.of('Malkovich Malkovich').map(match(/a/gi));
//=> Maybe(['a', 'a'])

Maybe.of(null).map(match(/a/gi));
//=> Maybe(null)

Maybe.of({ name: 'Boris' })
    .map(_.prop('age'))
    .map(add(10));
//=> Maybe(null)

Maybe.of({ name: 'Dinah', age: 14 })
    .map(_.prop('age'))
    .map(add(10));
//=> Maybe(24)
```

这种 点记法(dot notation synctax)已经足够函数式, 但是正如在第一部分所说, 保持一种 pointfree 的风格. 碰巧, `map`完全有能力以 curry 函数的方式来'代理'任何的 unfctor:

```js
//  map :: Functor f => (a -> b) -> f a -> f b
var map = curry(function(f, any_functor_at_all) {
    return any_functor_at_all.map(f);
});
```

这样我们就可以像平常一样使用组合，同时也能正常使用 map 了.

#### 用例

实际当中, `Maybe`最常用在那些可能会无法成功返回结果的函数中.

```js
//  safeHead :: [a] -> Maybe(a)
var safeHead = function(xs) {
    return Maybe.of(xs[0]);
};

var streetName = compose(
    map(_.prop('street')),
    safeHead,
    _.prop('addresses')
);

streetName({ addresses: [] });
// Maybe(null)

streetName({ addresses: [{ street: 'Shady Ln.', number: 4201 }] });
// Maybe("Shady Ln.")
```

有时候, 函数可以明确返回一个`Maybe(null)`来表明失败.

```js
//  withdraw :: Number -> Account -> Maybe(Account)
var withdraw = curry(function(amount, account) {
    return account.balance >= amount ? Maybe.of({ balance: account.balance - amount }) : Maybe.of(null);
});

//  finishTransaction :: Account -> String
var finishTransaction = compose(
    remainingBalance,
    updateLedger
); // <- 假定这两个函数已经在别处定义好了

//  getTwenty :: Account -> Maybe(String)
var getTwenty = compose(
    map(finishTransaction),
    withdraw(20)
);

getTwenty({ balance: 200.0 });
// Maybe("Your balance is $180.00")

getTwenty({ balance: 10.0 });
// Maybe(null)
```

#### 释放容器中的值

如果我们想返回一个自定义的值然后还能继续执行后面的代码的话, 是可以做到的; 要达到这一目的, 可以借助一个帮助函数: maybe:

```js
//  maybe :: b -> (a -> b) -> Maybe a -> b
var maybe = curry(function(x, f, m) {
    return m.isNothing() ? x : f(m.__value);
});

//  getTwenty :: Account -> String
var getTwenty = compose(
    maybe("You're broke!", finishTransaction),
    withdraw(20)
);

getTwenty({ balance: 200.0 });
// "Your balance is $180.00"

getTwenty({ balance: 10.0 });
// "You're broke!"
```

`Maybe`的真正实现会把它分为两种类型:一种是非空值, 另一种是控制. 这种实现允许我们遵守`map`的 parametricity 特性, 因此`null`和`undefined`能够依然被`map`调用, functor 里的值所需要的那种普遍性也能得到满足. 所以可以经常看到`Some(x)/None`或者`Just(x)/nothing`这样的容器类型在做空值检查, 而不是`Maybe`.

### "纯"错误处理

在这里看来, `throw/catch`并不十分"纯", 现在来介绍`Either`:

```js
var Left = function(x) {
    this.__value = x;
};

Left.of = function(x) {
    return new Left(x);
};

Left.prototype.map = function(f) {
    return this;
};

var Right = function(x) {
    this.__value = x;
};

Right.of = function(x) {
    return new Right(x);
};

Right.prototype.map = function(f) {
    return Right.of(f(this.__value));
};
```

`Left`和`Right`是我们称之为`Either`的抽象类型的两个子类. 略去创建`Either`父类:

```js
Right.of('rain').map(function(str) {
    return 'b' + str;
});
// Right("brain")

Left.of('rain').map(function(str) {
    return 'b' + str;
});
// Left("rain")

Right.of({ host: 'localhost', port: 80 }).map(_.prop('host'));
// Right('localhost')

Left.of('rolls eyes...').map(_.prop('host'));
// Left('rolls eyes...')
```

`Left`无视我们要`map`它的请求, `Right`的作用就像一个`Container`. 这里强大的地方在于: `Left`有能力在它内部嵌入一个错误消息.

假设现在有一个可能会失败的函数, 例如根据生日计算年龄. 我们可以用`Maybe(null)`来表示失败并把程序引向另一个分支, 但是这没有告诉我们额外信息.

```js
var moment = require('moment');

//  getAge :: Date -> User -> Either(String, Number)
var getAge = curry(function(now, user) {
    var birthdate = moment(user.birthdate, 'YYYY-MM-DD');
    if (!birthdate.isValid()) return Left.of('Birth date could not be parsed');
    return Right.of(now.diff(birthdate, 'years'));
});

getAge(moment(), { birthdate: '2005-12-12' });
// Right(9)

getAge(moment(), { birthdate: 'balloons!' });
// Left("Birth date could not be parsed")
```

就像`Maybe(null)`, 当返回一个`Left`的时候就直接让程序短路. 初次之外, 我们对程序为何脱离轨道有了一些头绪.

```js
//  fortune :: Number -> String
var fortune = compose(
    concat('If you survive, you will be '),
    add(1)
);

//  zoltar :: User -> Either(String, _)
var zoltar = compose(
    map(console.log),
    map(fortune),
    getAge(moment())
);

zoltar({ birthdate: '2005-12-12' });
// "If you survive, you will be 10"
// Right(undefined)

zoltar({ birthdate: 'balloons!' });
// Left("Birth date could not be parsed")
```

在这里例子里, 我们根据`brthdate`的合法性来控制代码的逻辑分支, 同时又让代码进行从右到左的直线运动, 而不用可用条件语句的大括号.

`Either`的能力远不止作为一个错误消息的容器. 比如: 它表示了逻辑或. 再比如, 它体现了范畴学了 coproduct 的概念. 但是作为一个 functor, 我们就用它进行错误处理.

就像 Maybe 可以有个 maybe 一样，Either 也可以有一个 either。两者的用法类似，但 either 接受两个函数（而不是一个）和一个静态值为参数。这两个函数的返回值类型一致：

```js
//  either :: (a -> c) -> (b -> c) -> Either a b -> c
var either = curry(function(f, g, e) {
    switch (e.constructor) {
        case Left:
            return f(e.__value);
        case Right:
            return g(e.__value);
    }
});

//  zoltar :: User -> _
var zoltar = compose(
    console.log,
    either(id, fortune),
    getAge(moment())
);

zoltar({ birthdate: '2005-12-12' });
// "If you survive, you will be 10"
// undefined

zoltar({ birthdate: 'balloons!' });
// "Birth date could not be parsed"
// undefined
```

过强制在 getAge 内部进行错误处理，我们的算命程序更加健壮了。结果就是，要么告诉用户一个残酷的事实并像算命师那样跟他击掌，要么就继续运行程序。好了，现在我们已经准备好去学习一个完全不同类型的 functor 了。

### Old McDonald had Effects...

在纯函数那一章, 有一个奇怪的例子. 这个例子中的纯函数会产生副作用, 但是我们通过把它包裹在另一个函数里的方式把它变得看起来想一个纯函数. 这里有一个类似的例子:

```js
//  getFromStorage :: String -> (_ -> String)
var getFromStorage = function(key) {
    return function() {
        return localStorage[key];
    };
};
```

如果我们没有把这个函数包在另一个函数中, 它的输出值就是不定的, 会随外部环境变化而变化. 有了这个包裹函数, 同一输入总是返回一个输出: 从`localstorage`取出某个特定元素的函数.

看看实际的运用:

```js
var IO = function(f) {
    this.__value = f;
};

IO.of = function(x) {
    return new IO(function() {
        return x;
    });
};

IO.prototype.map = function(f) {
    return new IO(
        _.compose(
            f,
            this.__value
        )
    );
};
```

跟之前的 functor 不同的地方在于, 它的`__vlaue`总是一个函数. 不过我们不把它当做一个函数. 这里: `IO`吧非纯执行动作(impure action)捕获包包裹函数里, 目的是延迟执行这个非纯动作. 所以, `IO`包含的是被包裹的执行动作的返回值, 而不是包裹函数本身.

```js
//  io_window_ :: IO Window
var io_window = new IO(function() {
    return window;
});

io_window.map(function(win) {
    return win.innerWidth;
});
// IO(1430)

io_window
    .map(_.prop('location'))
    .map(_.prop('href'))
    .map(split('/'));
// IO(["http:", "", "localhost:8000", "blog", "posts"])

//  $ :: String -> IO [DOM]
var $ = function(selector) {
    return new IO(function() {
        return document.querySelectorAll(selector);
    });
};

$('#myDiv')
    .map(head)
    .map(function(div) {
        return div.innerHTML;
    });
// IO('I am some inner html')
```

这里对`IO`的调用`map`已经积累了太多不纯的操作, 最后再运行它无疑会打破平静. 问题是在哪里打开. 答案是把责任推到调用者身上就可以了, 来看一个具体的例子:

```js
////// 纯代码库: lib/params.js ///////

//  url :: IO String
var url = new IO(function() {
    return window.location.href;
});

//  toPairs =  String -> [[String]]
var toPairs = compose(
    map(split('=')),
    split('&')
);

//  params :: String -> [[String]]
var params = compose(
    toPairs,
    last,
    split('?')
);

//  findParam :: String -> IO Maybe [String]
var findParam = function(key) {
    return map(
        compose(
            Maybe.of,
            filter(
                compose(
                    eq(key),
                    head
                )
            ),
            params
        ),
        url
    );
};

////// 非纯调用代码: main.js ///////

// 调用 __value() 来运行它！
findParam('searchTerm').__value();
// Maybe(['searchTerm', 'wafflehouse'])
```

注意: `IO`的`__value`并不是它包含的值, 也不是像两个下划线暗示的那样是一个私有属性. 这个值应当被调用者以最公开的方式调用. 来对他进行重命名为`unsafeperformIO`:

```js
var IO = function(f) {
    this.unsafePerformIO = f;
};

IO.prototype.map = function(f) {
    return new IO(
        _.compose(
            f,
            this.unsafePerformIO
        )
    );
};
```

### 异步任务

直接来看看 Folktale 中的`Data.Task`中的一些例子:

```js
// Node readfile example:
//=======================

var fs = require('fs');

//  readFile :: String -> Task(Error, JSON)
var readFile = function(filename) {
    return new Task(function(reject, result) {
        fs.readFile(filename, 'utf-8', function(err, data) {
            err ? reject(err) : result(data);
        });
    });
};

readFile('metamorphosis')
    .map(split('\n'))
    .map(head);
// Task("One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that
// in bed he had been changed into a monstrous verminous bug.")

// jQuery getJSON example:
//========================

//  getJSON :: String -> {} -> Task(Error, JSON)
var getJSON = curry(function(url, params) {
    return new Task(function(reject, result) {
        $.getJSON(url, params, result).fail(reject);
    });
});

getJSON('/video', { id: 10 }).map(_.prop('title'));
// Task("Family Matters ep 15")

// 传入普通的实际值也没问题
Task.of(3).map(function(three) {
    return three + 1;
});
// Task(4)
```

类比 promise, 我们发现`map`就是`then`, `Task`就是一个 promise...

和`IO`类似, `Task`在我们给它绿灯之前是不会运行的. 事实上, 正是由于此, `IO`实际上就被纳入`Task`名下, 代表所有的异步操作--`readFile`和`getJSON`并不需要一个额外的容器`IO`来变纯. 更重要的是, `Task`的工作方式和`IO`差不多: 把对未来的操作的指示放在一个时间胶囊中.

我们必须调用`fork`方法才能运行`Task`, 这种机制与`unsafePerformIO`类似. 但也有不同, 不同之处在于: 它会`fork`一个子进程运行它接受到的参数代码吗其他部分的执行不受影响, 主线程也不会阻塞. 当然这种效果也可以用其他一些技术比如线程来实现. 但是在这里, 这种方法工作起来就像一种普通的异步调用, 而且 eventloop 能够不受影响的继续运转.

```js
// Pure application
//=====================
// blogTemplate :: String

//  blogPage :: Posts -> HTML
var blogPage = Handlebars.compile(blogTemplate);

//  renderPage :: Posts -> HTML
var renderPage = compose(
    blogPage,
    sortBy('date')
);

//  blog :: Params -> Task(Error, HTML)
var blog = compose(
    map(renderPage),
    getJSON('/posts')
);

// Impure calling code
//=====================
blog({}).fork(
    function(error) {
        $('#error').html(error.message);
    },
    function(page) {
        $('#main').html(page);
    }
);

$('#spinner').show();
```

在这段线性的控制流中, 我们按顺序阅读就能理解代码(即使在运行中会跳来跳去), 这种方式使得阅读和理解应用程序的代码比那种在各种回调和错误处理代码块之间调阅的方式容易的多.

并且, `Task`居然也包含了`Either`. 就算有了`Task`, `IO`和`Either`还是能派上用处的, 看下这个简单的例子:

```js
// Postgres.connect :: Url -> IO DbConnection
// runQuery :: DbConnection -> ResultSet
// readFile :: String -> Task Error String

// Pure application
//=====================

//  dbUrl :: Config -> Either Error Url
var dbUrl = function(c) {
    return c.uname && c.pass && c.host && c.db
        ? Right.of('db:pg://' + c.uname + ':' + c.pass + '@' + c.host + '5432/' + c.db)
        : Left.of(Error('Invalid config!'));
};

//  connectDb :: Config -> Either Error (IO DbConnection)
var connectDb = compose(
    map(Postgres.connect),
    dbUrl
);

//  getConfig :: Filename -> Task Error (Either Error (IO DbConnection))
var getConfig = compose(
    map(
        compose(
            connectDB,
            JSON.parse
        )
    ),
    readFile
);

// Impure calling code
//=====================
getConfig('db.json').fork(logErr("couldn't read file"), either(console.log, map(runQuery)));
```

### 一点理论

functor 的概念来自于范畴学, 并满足一些定律.

```js
// identity
map(id) === id;

// composition
compose(
    map(f),
    map(g)
) ===
    map(
        compose(
            f,
            g
        )
    );
```

**同一律** 很简单但是很重要. 因为这些定律都是可运行的代码, 所以我们完全可以在我们自己的 functor 上实验:

```js
var idLaw1 = map(id);
var idLaw2 = id;

idLaw1(Container.of(2));
//=> Container(2)

idLaw2(Container.of(2));
//=> Container(2)
```

再看一看组合:

```js
var compLaw1 = compose(
    map(concat(' world')),
    map(concat(' cruel'))
);
var compLaw2 = map(
    compose(
        concat(' world'),
        concat(' cruel')
    )
);

compLaw1(Container.of('Goodbye'));
//=> Container('Goodbye cruel world')

compLaw2(Container.of('Goodbye'));
//=> Container('Goodbye cruel world')
```

在范畴学中, functor 接受一个范畴的对象和态射(morphism), 然后把它们映射(map)到另一个范畴里去. 根据定义, 这个新范畴一定会有一个单位元(identity), 也一定能够组合态射;这是由前面的定律保证的.

我们来理解一下范畴的定义: 我们可以把范畴想象成一个有着多个对象的网络, 对象之间靠态射链接. 那么 functor 可以把一个范畴映射到另外一个, 而且不会破坏原有的网络. 如果一个对象`a`属于源范畴`C`, 那么通过 functor `F` 把 `a` 映射到目标范畴`D`上之后, 就可以使用`F a`来指代`a`对象. 看图理解:

![avatar](/img/catmap.png)

例如: `Maybe`就是把类型和函数的范畴映射到这样一个范畴: 即每个对象都有可能不存在, 每个态射都有空值检查的范畴. 这个结果在代码中的实现方式是用`map`包裹每一个函数, 用 functor 包裹每一个函数, 用 functor 包裹每一个类型, 这样就能保证每个普通的类型和函数都能在新环境下继续使用组合.

我们看看一个例子:

```js
//  topRoute :: String -> Maybe(String)
var topRoute = compose(
    Maybe.of,
    reverse
);

//  bottomRoute :: String -> Maybe(String)
var bottomRoute = compose(
    map(reverse),
    Maybe.of
);

topRoute('hi');
// Maybe("ih")

bottomRoute('hi');
// Maybe("ih")
```

看图:

![avatar](/img/functormapmaybe.png)

根据所有 functor 都有的特性, 我们可以立即理解代码, 重构代码.

functor 也能嵌套使用:

```js
var nested = Task.of([Right.of('pillows'), Left.of('no sleep for you')]);

map(map(map(toUpperCase)), nested);
// Task([Right("PILLOWS"), Left("no sleep for you")])
```

`nested`是一个将来的数组, 数组的元素有可能是程序抛出的错误. 我们使用`map`剥开每一层的嵌套, 然后对数组的元素调用传递进去的函数. 可以看到, 这中间没有回调, `if/else`语句和`for`循环, 只有一个明确的上下文. 看起来我们需要`map(map(map(f)))`才能运行最终的函数, 但是, 我们可以组合 functor:

```js
var Compose = function(f_g_x) {
    this.getCompose = f_g_x;
};

Compose.prototype.map = function(f) {
    return new Compose(map(map(f), this.getCompose));
};

var tmd = Task.of(Maybe.of('Rock over London'));

var ctmd = new Compose(tmd);

map(concat(', rock on, Chicago'), ctmd);
// Compose(Task(Maybe("Rock over London, rock on, Chicago")))

ctmd.getCompose;
// Task(Maybe("Rock over London, rock on, Chicago"))
```

## Monad

### pointed functor

作者要向我坦白一件事: 关于前面创建的容器类上的`of`方法, 他没说出全部实情. 真实情况是, `of`方法不是用来避免使用`new`关键字的, 而是用来把值放到 _默认最小化上下文_ .

`of`没有真正地取代构造器, 它是一个我们称之为 pointed 的重要接口的一部分.

> pointed functor 是实现了 of 方法的 functor。

这里的关键是吧任意值丢到容器里然后开始到处使用`map`的能力.

```js
IO.of('tetris').map(concat(' master'));
// IO("tetris master")

Maybe.of(1336).map(add(1));
// Maybe(1337)

Task.of([{ id: 2 }, { id: 3 }]).map(_.prop('id'));
// Task([2,3])

Either.of('The past, present and future walk into a bar...').map(concat('it was tense.'));
// Right("The past, present and future walk into a bar...it was tense.")
```

### 混合比喻

来看看 monad 的定义:

> monad 是可以变扁（flatten）的 pointed functor。

一个 functor, 只要定义了一个`join`方法和一个`of`方法, 并遵守一些定律, 那么它就是一个 monad.

monad 还被比喻为洋葱. 我们以一个常见的场景来说明这点:

```js
// Support
// ===========================
var fs = require('fs');

//  readFile :: String -> IO String
var readFile = function(filename) {
    return new IO(function() {
        return fs.readFileSync(filename, 'utf-8');
    });
};

//  print :: String -> IO String
var print = function(x) {
    return new IO(function() {
        console.log(x);
        return x;
    });
};

// Example
// ===========================
//  cat :: IO (IO String)
var cat = compose(
    map(print),
    readFile
);

cat('.git/config');
// IO(IO("[core]\nrepositoryformatversion = 0\n"))
```

我们的得到了一个`IO`, 但是想要使用它, 我们必须这样调用:`map(map(f))`; 想要观察它的作用, 必须这样: `unsafePerformIO().unsafePerformIO()`.

```js
//  cat :: String -> IO (IO String)
var cat = compose(
    map(print),
    readFile
);

//  catFirstChar :: String -> IO (IO String)
var catFirstChar = compose(
    map(map(head)),
    cat
);

catFirstChar('.git/config');
// IO(IO("["))
```

monad 就像洋葱, 要使用一层一层的`map`拨开嵌套的 functor 以获取内部的值. 不过, 我们可以使用一个`join`方法:

```js
var mmo = Maybe.of(Maybe.of('nunchucks'));
// Maybe(Maybe("nunchucks"))

mmo.join();
// Maybe("nunchucks")

var ioio = IO.of(IO.of('pizza'));
// IO(IO("pizza"))

ioio.join();
// IO("pizza")

var ttt = Task.of(Task.of(Task.of('sewers')));
// Task(Task(Task("sewers")));

ttt.join();
// Task(Task("sewers"))
```

两层相同类型的嵌套可以使用`join`将其压扁. 它的实现并不太复杂:

```js
Maybe.prototype.join = function() {
    return this.isNothing() ? Maybe.of(null) : this.__value;
};
```

看看如何应用到上面的`firstAddressStreet`例子上:

```js
//  join :: Monad m => m (m a) -> m a
var join = function(mma) {
    return mma.join();
};

//  firstAddressStreet :: User -> Maybe Street
var firstAddressStreet = compose(
    join,
    map(safeProp('street')),
    join,
    map(safeHead),
    safeProp('addresses')
);

firstAddressStreet({ addresses: [{ street: { name: 'Mulburry', number: 8402 }, postcode: 'WC2N' }] });
// Maybe({name: 'Mulburry', number: 8402})
```

### chain 函数

我们总是在`map`的后面调用`join`, 现在把这个行为抽象到`chain`函数中:

```js
//  chain :: Monad m => (a -> m b) -> m a -> m b
var chain = curry(function(f, m) {
    return m.map(f).join(); // 或者 compose(join, map(f))(m)
});
```

这里仅仅是吧 map/join 进行打包到一个单独的函数. 如果之前了解过 monad, `chain`叫做`>>=`(读作 bind)或者`flatMap`, 这些都是同一个概念的不同名称. 因为它是 JS 里接受程度最高的一个. 我们用`chain`重构上面的两个例子:

```js
// map/join
var firstAddressStreet = compose(
    join,
    map(safeProp('street')),
    join,
    map(safeHead),
    safeProp('addresses')
);

// chain
var firstAddressStreet = compose(
    chain(safeProp('street')),
    chain(safeHead),
    safeProp('addresses')
);

// map/join
var applyPreferences = compose(
    join,
    map(setStyle('#main')),
    join,
    map(log),
    map(JSON.parse),
    getItem
);

// chain
var applyPreferences = compose(
    chain(setStyle('#main')),
    chain(log),
    map(JSON.parse),
    getItem
);
```

`chain`的能力不止于此, 它可以嵌套多个作用, 以一种纯函数使得方式来表示 _序列_(sequence)和 _变量赋值_(variable assignment).

```js
// getJSON :: Url -> Params -> Task JSON
// querySelector :: Selector -> IO DOM

getJSON('/authenticate', { username: 'stale', password: 'crackers' }).chain(function(user) {
    return getJSON('/friends', { user_id: user.id });
});
// Task([{name: 'Seimith', id: 14}, {name: 'Ric', id: 39}]);

querySelector('input.username').chain(function(uname) {
    return querySelector('input.email').chain(function(email) {
        return IO.of('Welcome ' + uname.value + ' ' + 'prepare for spam at ' + email.value);
    });
});
// IO("Welcome Olivia prepare for spam at olivia@tremorcontrol.net");

Maybe.of(3).chain(function(three) {
    return Maybe.of(2).map(add(three));
});
// Maybe(5);

Maybe.of(null)
    .chain(safeProp('address'))
    .chain(safeProp('street'));
// Maybe(null);
```

在第一个例子中, 可以看到两个`Task`通过`chain`连接形成了一个异步操作的序列, 它先获取`user`, 然后用`user.id`查找`friends`. 避免了`Task(Task([Friend]))`这种操作.

第二个例子用`querySelector`查找几个 input 然后创建一条欢迎信息.

### 炫耀

```js
// readFile :: Filename -> Either String (Future Error String)
// httpPost :: String -> Future Error JSON

//  upload :: String -> Either String (Future Error JSON)
var upload = compose(
    map(chain(httpPost('/uploads'))),
    readFile
);
```

这里, 代码不止一次在不同的分支执行. 从类型签名可以看出, 我们要预防了三个错误: readFile 使用 Either 来验证输入（或许还有确保文件名存在）；readFile 在读取文件的时候可能会出错，错误通过 readFile 的 Future 表示；文件上传可能会因为各种各样的原因出错，错误通过 httpPost 的 Future 表示。我们就这么随意地使用 chain 实现了两个嵌套的、有序的异步执行动作。

所有操作都在一个从左到右的线性流中完成, 是完完全全的纯的, 声明式的代码, 可以进行等式推导并拥有可靠特性.

来和标准的命令式的实现比较:

```js
//  upload :: String -> (String -> a) -> Void
var upload = function(filename, callback) {
    if (!filename) {
        throw 'You need a filename!';
    } else {
        readFile(filename, function(err, contents) {
            if (err) throw err;
            httpPost(contents, function(err, json) {
                if (err) throw err;
                callback(json);
            });
        });
    }
};
```

### 理论

这个我们要看到的结合律不是你熟悉的那个结合律:

```js
// 结合律
compose(
    join,
    map(join)
) ==
    compose(
        join,
        join
    );
```

这些定律表明了 monad 的嵌套本质，所以结合律关心的是如何让内层或外层的容器类型 join，然后取得同样的结果。用一张图来表示可能效果会更好：

![avator](/img/monad_associativity.png)

第二个是同一律:

```js
// 同一律 (M a)
(compose(
    join,
    of
) ==
    compose(
        join,
        map(of)
    )) ==
    id;
```

这表示, 对任意的 monad`M`,`of`和`join`相当于`id`. 也可以使用`map(of)`由内而外实现相同效果. 看图, 我们把这个定律叫做"三角同一律":

![avator](/img/triangle_identity.png)

## Applicative Functor

### 应用

假设有两个同类型的 functor, 我们想把这两个作为一个函数的两个参数传递过去来调用这个函数. 简单的例子, 比兔让两个`Container`的值相加:

```js
// 这样是行不通的，因为 2 和 3 都藏在瓶子里。
add(Container.of(2), Container.of(3));
//NaN

// 使用可靠的 map 函数试试
var container_of_add_2 = map(add, Container.of(2));
// Container(add(2))
```

我们创建了一个`Container`, 它内部的值是一个局部调用的(partially applied)的函数. 确切点讲就是, 我们想让`Container(add(2))`中的`add(2)`应用到`Container(3)`中的`3`上来完成调用.

也就是说, 我们想把一个 functor 应用到另一个上.

巧了, 我们可以先`chain`然后再`map`那个局部调用的`add(2)`, 就像这样:

```js
Container.of(2).chain(function(two) {
    return Container.of(3).map(add(two));
});
```

这里有一个问题是关于 monad 的顺序执行: 所有的代码都只会在前一个 monad 执行完毕之后才执行. 想想看, 我们的这两个值足够强健且相互独立, 如果仅仅是为了满足 monad 的顺序要求而延迟`Container(3)`的创建, 则是没有必要的.

### 瓶中之船

`ap`能够把一个 functor 的函数值应用到另一个 functor 的值上.

```js
Container.of(add(2)).ap(Container.of(3));
// Container(5)

// all together now
Container.of(2)
    .map(add)
    .ap(Container.of(3));
// Container(5)
```

强调一点, 这里的`add`是被`map`所局部调用的, 所以`add`必须是一个`curry`函数.

可以这样定义一个`ap`函数:

```js
Container.prototype.ap = function(other_container) {
    return other_container.map(this.__value);
};
```

`this.__value`是一个函数, 将会接受另一个 functor 作为参数, 所以我们只需要`map`它, 有词我们可以得出`applicative functor`的定义:

> applicative functor 是实现了 `ap` 方法的 pointed functor

注意`pointed`这个前提. 看下面这个例子:

```js
F.of(x).map(f) == F.of(f).ap(F.of(x));
```

这行代码翻译成人类语言就是，map 一个 f 等价于 ap 一个值为 f 的 functor。或者更好的译法是，你既可以把 x 放到容器里然后调用 map(f)，也可以同时让 f 和 x 发生 lift（参看第 8 章），然后对他们调用 ap。这让我们能够以一种从左到右的方式编写代码：

```js
Maybe.of(add)
    .ap(Maybe.of(2))
    .ap(Maybe.of(3));
// Maybe(5)

Task.of(add)
    .ap(Task.of(2))
    .ap(Task.of(3));
// Task(5)
```

### 协调与激励

假设我们要创建一个旅行网站, 既需要获得游客目的地的列表, 还需要获得地方时间的列表. 这两个请求就是相互独立的 api 调用.

```js
// Http.get :: String -> Task Error HTML

var renderPage = curry(function(destinations, events) {
    /* render page */
});

Task.of(renderPage)
    .ap(Http.get('/destinations'))
    .ap(Http.get('/events'));
// Task("<div>some page with dest and events</div>")
```

两个请求将会立即执行, 当两个的响应都返回之后, `renderPage`就会被调用. 这里, 我们使用局部调用的函数来达成上述的结果, 因此我们必须要保证`renderage`是 curry 函数, 否则它就不会一直等到两个 Task 都完成.

另一个例子:

```js
// 帮助函数：
// ==============
//  $ :: String -> IO DOM
var $ = function(selector) {
    return new IO(function() {
        return document.querySelector(selector);
    });
};

//  getVal :: String -> IO String
var getVal = compose(
    map(_.prop('value')),
    $
);

// Example:
// ===============
//  signIn :: String -> String -> Bool -> User
var signIn = curry(function(username, password, remember_me) {
    /* signing in */
});

IO.of(signIn)
    .ap(getVal('#email'))
    .ap(getVal('#password'))
    .ap(IO.of(false));
// IO({id: 3, email: "gg@allin.com"})
```

signIn 是一个接收 3 个参数的 curry 函数，因此我们需要调用 ap 3 次。在每一次的 ap 调用中，signIn 就收到一个参数然后运行，直到所有的参数都传进来，它也就执行完毕了。

我们可以继续扩展这种模式，处理任意多的参数。另外，左边两个参数在使用 getVal 调用后自然而然地成为了一个 IO，但是最右边的那个却需要手动 lift，然后变成一个 IO，这是因为 ap 需要调用者及其参数都属于同一类型。

### lift

尝试以一种 pointfree 的方式调用 applicative functor. 因为`map`等价于`of/ap`, 那么我们就可以定义无数个能够`ap`通用函数.

```js
var liftA2 = curry(function(f, functor1, functor2) {
    return functor1.map(f).ap(functor2);
});

var liftA3 = curry(function(f, functor1, functor2, functor3) {
    return functor1
        .map(f)
        .ap(functor2)
        .ap(functor3);
});

//liftA4, etc
```

`liftA2`让那些小代码块发生 lift, 称为 applicative functor 中的一员

看看实际用例:

```js
// checkEmail :: User -> Either String Email
// checkName :: User -> Either String String

//  createUser :: Email -> String -> IO User
var createUser = curry(function(email, name) {
    /* creating... */
});

Either.of(createUser)
    .ap(checkEmail(user))
    .ap(checkName(user));
// Left("invalid email")

liftA2(createUser, checkEmail(user), checkName(user));
// Left("invalid email")
```

`createUser` 接收两个参数，因此我们使用的是 `liftA2`。上述两个语句是等价的，但是使用了 `liftA2` 的版本没有提到 `Either`，这就使得它更加通用灵活，因为不必与特定的数据类型耦合在一起。

我们试试以这种方式重写前一个例子:

```js
liftA2(add, Maybe.of(2), Maybe.of(3));
// Maybe(5)

liftA2(renderPage, Http.get('/destinations'), Http.get('/events'));
// Task("<div>some page with dest and events</div>")

liftA3(signIn, getVal('#email'), getVal('#password'), IO.of(false));
// IO({id: 3, email: "gg@allin.com"})
```

### 免费开瓶器

我们知道 applicative 首先是一个 functor, 因此, 如果有一个 applicative, 那么可以依此定义一个 functor.

前面提到, `of/ap`等价于`map`, 那么我们就可以利用这点来定义`map`:

```js
// 从 of/ap 衍生出的 map
X.prototype.map = function(f) {
    return this.constructor.of(f).ap(this);
};
```

monad 处在食物链的顶端, 因此如果有一个`chain`函数, 那么就可以免费得到`functor`和`applicative`:

```js
// 从 chain 衍生出的 map
X.prototype.map = function(f) {
    var m = this;
    return m.chain(function(a) {
        return m.constructor.of(f(a));
    });
};

// 从 chain/map 衍生出的 ap
X.prototype.ap = function(other) {
    return this.chain(function(f) {
        return other.map(f);
    });
};
```

### 定律

applicative functor 是"组合关闭"(closed under composition)的, 意味着`ap`永远不会改变容器类型.

```js
var tOfM = compose(
    Task.of,
    Maybe.of
);

liftA2(_.concat, tOfM('Rainy Days and Mondays'), tOfM(' always get me down'));
// Task(Maybe(Rainy Days and Mondays always get me down))
```

#### 同一律(identity)

```js
// 同一律
A.of(id).ap(v) == v;
```

对一个 functor 应用`id`不会改变`v`中的值:

```js
var v = Identity.of('Pillow Pets');
Identity.of(id).ap(v) == v;
```

#### 同态(homomorphism)

```js
// 同态
A.of(f).ap(A.of(x)) == A.of(f(x));
```

_同态_ 就是一个能够保持结构的映射. 实际上, functor 就是一个在不同范畴间的同态, 因为 functor 在经过映射之后保持了原始范畴的结构.

事实上, 我们不过是把普通的函数和值放进了一个容器, 然后在里面进行各种计算. 所以不管是把所有的计算都烦放在容器内部还是现在外面进行计算, 然后再方法到容器里, 结果都是一样的.

#### 互换(interchange)

互换（interchange）表明的是选择让函数在 ap 的左边还是右边发生 lift 是无关紧要的。

```js
// 互换
v.ap(A.of(x)) ==
    A.of(function(f) {
        return f(x);
    }).ap(v);
```

这里有个例子:

```js
var v = Task.of(_.reverse);
var x = 'Sparklehorse';

v.ap(Task.of(x)) ==
    Task.of(function(f) {
        return f(x);
    }).ap(v);
```

#### 组合(composition)

组合不过是在检查标准的函数组合是否适用于容器内部的函数调用。

```js
// 组合
A.of(compose)
    .ap(u)
    .ap(v)
    .ap(w) == u.ap(v.ap(w));
```

```js
var u = IO.of(_.toUpper);
var v = IO.of(_.concat('& beyond'));
var w = IO.of('blood bath ');

IO.of(_.compose)
    .ap(u)
    .ap(v)
    .ap(w) == u.ap(v.ap(w));
```
