---
title: '[笔记]算法的乐趣(一)'
date: 2018-09-30 16:49:00
mathjax: true
category:
    - 笔记
    - 算法的乐趣
tags:
    - 算法
    - javascript
---

> 算法的乐趣: 第一章到第七章

<!-- more -->

# 算法的乐趣JS代码实现+笔记(一)

> 主要内容来自算法的乐趣一书. [推荐购买](https://item.jd.com/11670027.html)

---

## 第一/二章 算法介绍

### 算法的四大特征(Kunth)

-   确定性: 算法的每个步骤都是明确的, 对结果的预期也是确定的.
-   有穷性: 算法必须由有限个步骤组成的过程.
-   可行性: 算法中的每一个步骤都是可行的.
-   输入和输出: 必须有输入和输出, 缺一都不成为算法.

综上: (本书中)算法是为解决一个特定问题而精心设计的一套数学模型以及在这套数学模型上的一系列操作步骤, 这些操作步骤将问题描述的输入数据逐步处理, 传唤, 并在最后得到一个确定的结果.


## 第三章 算法设计的常用思想

### 贪婪法

贪婪法(greedy algorithm), 又称贪心算法, 用于寻找最优解问题的常用方法.

#### 基本思想

贪婪法的基本设计思想有以下三个步骤:  
(1) 建立对问题精确描述的数学模型, 包括定义最优解的模型.  
(2) 将问题分解为一些列子问题, 同时定义子问题的最优解结构.  
(3) 应用贪心原则确定每个子问题的局部最优解, 并根据最优解的模型, 用子问题的局部最优解堆叠出全局最优解.

#### 例子: 0-1 背包问题

-   问题: 有 N 件物品和一个承重为 C 的背包, 每件物品的重量是 w(i), 价值是 p(i), 求解将哪几件物品装入背包可使这些物品在重量综合不超过 C 的情况下价值总和最大.

背包问题(knapsack problem)是此类组合优化的 NP 完全问题的统称, 比如或相撞或问题, 货船载物问题等吗最初来源于如何选择合适的物品装在背包中而得名.

这里有一个隐含的条件, 就是限定每件物品只能选择 0 或 1 个, 因此被称为 0-1 背包问题.

看一个具体的例子: 有一个背包最多称重 C=150, 有 7 个物品,编号为 1~7, 重量为 w(i)=[35,30,60,50,40,10,25], 价值 p(i)=[10,40,30,50,35,40,30],选择一个或多个装入背包是价值最大.

对于本题, 常见的贪婪策略有三种.

-   第一种策略是根据物品价值选择, 每次选择价值最高的物品, 据此,选择 4,2,6,5, w=130,p=165.
-   第二种策略是根据物品重量徐娜则, 每次选最轻的物品, 据此, 选择 6,7,2,1,5,w=140,p=155.
-   第三种策略是定义价值密度 s(i)=(p(i)/w(i)), 价值密度一次 s(i)=[0.286,1.333,0.5,1.0,0.875,4.0,12], 据此, 选择 6,,2,7,4,1, w=150, p=170.

JS 代码实例:

```js
//背包问题(0-1背包问题)

//物品
let tagObejct = {
    weight: null, //重量
    price: null, //价值
    status: 0 //0:未选中,1:已选中,2:已超重,不可选
};

//背包
let tagKnapsackProblem = {
    objes: [],
    totalC: 150
};

//贪婪算法主体
function GreedyAlgo(problem, spfunct) {
    let idx;
    let ntc = 0;
    while ((idx = spfunct(problem.objes, problem.totalC - ntc)) != -1) {
        console.log(idx);
        if (ntc + problem.objes[idx].weight <= problem.totalC) {
            problem.objes[idx].status = 1;
            ntc += problem.objes[idx].weight;
        } else {
            problem.objes[idx].status = 2;
        }
    }

    PrintResult(problem.objes);
}

/**
 * 选择策略-价值最高优先
 * @param {*} objes 物品列表
 * @param {*} c 剩余承重
 */
function Choosefunc1(objes, c) {
    let index = -1;
    let mp = 0;
    for (let i = 0; i < objes.length; i++) {
        if (objes[i].status == 0 && objes[i].price > mp) {
            mp = objes[i].price;
            index = i;
        }
    }

    return index;
}

function PrintResult(objes) {
    console.log(objes);
}

(function main() {
    let wArray = [35, 30, 60, 50, 40, 10, 25];
    let pArray = [10, 40, 30, 50, 35, 40, 30];
    for (let i = 0; i < 7; i++) {
        let tempObj = {
            weight: wArray[i],
            price: pArray[i],
            status: 0
        };
        tagKnapsackProblem.objes.push(tempObj);
    }

    GreedyAlgo(tagKnapsackProblem, Choosefunc1);
})();
```

虽然这里是第三种策略得到了最好的结果, 实际上只是对这组数据的验证结果而已, 如果换一组数据, 结果可能完全相反. 对于一些可以证明贪婪法得到的就是最优解的问题, 应用贪婪法可以高效地求得结果, 比如求最小生成树的 Prim 算法和 Kruskal 算法.

大多数情况下, 贪婪法只能得到比较接近最优解的近似的最优解. 但是作为一种启发式辅助方法, 常用雨其他算法中, 比如 Dijkstra 的单源最短路径算法.

事实上, 在任何算法中, 只要某个阶段使用了只考虑局部最优情况的选择策略, 都可以理解为使用了贪婪算法.

### 分治法

分治, 顾名思义, 分而治之. 分治法的设计思想是将无法着手的解决的大问题分解成一系列规模较小的相同问题, 然后逐个解决. 分治法产生的子问题与原始问题相同, 只是规模见笑, 反复使用分治法, 直到能够被直接求解为止.

应用分治法, 一般处于两个目的: 1. 通过分解问题, 是无法着手解决的大问题变成容易解决的小问题. 2. 通过见笑问题的规模, 降低解决问题的复杂度(或计算量).

#### 基本思想

分治法基本可以归纳为以下三个步骤:

1. 分解: 将问题分解为若干个规模较小, 相互独立且与原问题形式相同的子问题, 确保各个子问题具有相同的子结构.
2. 解决: 如果上一步分解得到的子问题可以解决, 则解决这些子问题, 否则, 对每个子问题使用和上一步相同的方法再次分解, 然后求解分解后的子问题, 这个过程可能是一个递归的过程.
3. 合并: 将上一步解决的各个子问题的解通过某种规则合并起来, 得到原问题的解.

分治法的实现可以是递归的, 也可以是非递归的. 这里是几个例子:

-   快速排序算法的分解思想是选择一个标兵数, 将待排序的序列分成两个子序列, 其中一个子序列中的树都小于标兵数,另一个子序列中的数都大于标兵数,然后分别对两个子序列排序,其合并思想就是将两个已经排序的子序列一前一后拼接在标兵数的前后, 组成一个完整的有序序列.

-   快速傅里叶变换的分解思想是将一个 N 点离散傅里叶变换, 按照奇偶关系分成两个 N/2 点李轩傅里叶变换, 其合并思想就是将两个 N/2 离散傅里叶变换的结果按照蝶形运算的位置关系重新排列成一个 N 点序列.

#### 例子: 大整数 Karatsuba 乘法算法

-   两个 n 位的大整数想成的时间复杂度为 O(n^2);  
    Anatolii Alexeevitch Karatsuba 博士在 1960 年提出一种快速乘法算法, 时间复杂度为 O(3n^1.585)(1.585=log2(3)). 这就是 Karatsuba 乘法算法.

该算法利用分治法的思想, 将 n 位大整数分解成两个接近 n/2 位的大整数, 通过 3 次 n/2 位大整数的惩罚和少量假发操作, 避免了直接进行 n 位大整数惩罚计算, 有效降低了乘法计算的计算量.

Karatsuba 代码实现(没有考虑健壮性):

```js
//Karatsuba大数乘法
class Karatsuba {
    caculateRes(mul1, mul2) {
        if (this.getBigNCount(mul1) == 1 || this.getBigNCount(mul2) == 1) {
            return mul1 * mul2;
        }

        let high1, high2, low1, low2;
        let k = Math.floor(
            Math.max(this.getBigNCount(mul1), this.getBigNCount(mul2)) / 2
        );

        low1 = mul1.toString().substr(-k) - 0;
        high1 = mul1.toString().substr(0, mul1.toString().length - k) - 0;
        low2 = mul2.toString().substr(-k) - 0;
        high2 = mul2.toString().substr(0, mul2.toString().length - k) - 0;

        if (isNaN(high1) || isNaN(low1) || isNaN(high2) || isNaN(low2)) {
            console.log("return error");
            return 0;
        }
        let z0 = this.caculateRes(low1, low2);
        let z1 = this.caculateRes(low1 + high1, low2 + high2);
        let z2 = this.caculateRes(high1, high2);

        let zk = z1 - z2 - z0;

        z2 = z2 * Math.pow(10, 2 * k);
        zk = zk * Math.pow(10, k);

        return z2 + zk + z0;
    }

    getBigNCount(mul) {
        //mul为大整数
        let numStr = mul.toString();
        return numStr.length;
    }
}

(function main() {
    let kara = new Karatsuba();
    let res = kara.caculateRes(34534521, 328962);
    console.log(res);
    console.log(34534521 * 328962);
})();
```

### 动态规划

#### 基本思想

动态规划(dynamic programming)是解决多阶段决策问题常用的最优化理论. 该理论提出后在数学, 计算机科学, 经济管理和工程技术领域得到了广泛的应用, 例如最短路线, 库存管理, 资源分配, 设备更新, 排序, 装在等问题, 用动态规划方法往往比朴素的方法更高效.

动态规划方法的原理就是把多阶段决策过程转化为一系列的但阶段决策过程问题, 利用各个阶段之间的递推关系, 逐个确定每个阶段的最优化决策, 最终堆叠出多阶段决策的最优化决策结果.

每种方法都有自身的局限性. 动态规划适合求解多阶段(状态转换)决策问你的最优解, 也可用于含有线性或非线性递推关系的最优解问题. 但是这些问题都必须满足最优化原理和子问题的"无后向性":

-   最优化原理: 最优化原理其实就是问题的最优子结构的性质, 如果一个问题的最优子结构是不论过去状态和决策如何, 对前面的决策所形成的的状态而言, 其后的决策必须构成最优策略, 也就是说, 不管之前决策是否是最优决策, 都必须保证从现在开始的决策时在之前决策基础上的最有决策, 则这样的最优子结构就符合最优化原理.
-   无后向性(无后效性): 所谓"无后向性", 就是当各个阶段的子问题确定以后, 对于某个特定阶段的子问题来说, 它之前的各个阶段的子问题的决策只能影响该阶段的决策, 对该阶段之后的决策不产生影响, 也就是说, 每个阶段的决策仅收之前决策的影响, 但是不影响之后各阶段的决策.

使用动态规划一把需要四个步骤, 分别为定义最优子问题, 定义状态 定义决策和状态转换方程以及确定边界条件.

1. 定义最优子问题

定义最优子问题, 也就是确定问题的优化目标以及如何决策最优解, 并对决策过程划分阶段. 所谓阶段, 可以理解为一个问题从开始到解决所需经过的环节, 这些环节前后关联, 划分阶段没有固定的方法, 根据问题的结构可以按照时间顺序划分阶段, 也可以按照问题的状态划分阶段. 阶段划分以后, 对问题的求解就变成对各个阶段分别进行最优化决策.

> 以装配站问题为例, 装配站问题的阶段划分比较清晰, 把工件从一个装配站移到下一个装配站就可以看作是一个阶段, 其子问题就可以定义为从一个装配站转移到下一个装配站. 知道最后一个装配站完成工作组装.

2. 定义状态

状态既是决策的对象, 也是决策的结果. 对于每个阶段来说, 对起始状态施加决策, 使得状态发生改变, 得到决策的结果状态. 初始状态经过每一个阶段的决策之后, 最终的到的状态就是问题的解. 只有一个决策序列能得到最优解. 状态的定义建立在子问题定义的基础上, 状态必须满足"无后向性".

> 装配站问题的实质就是在不同的装配线之间选择装配站, 使得工件装配完成的事件最短, 其状态`s[i,j]`就可以定义为通过第`i`条装配线的第`j`个装配站所需要的最短时间.

3. 定义决策和状态转换方程

定义侧巨额和状态转换方程. 决策就是能使状态发生转变的选择动作, 如果选择动作有多个, 则决策就是取其中能使得阶段结果最优的哪一个. 状态转换方程是描述状态转换关系的一系列等式, 也就是从 n-1 阶段到 n 阶段演化的故意率. 状态转换取决于子问题的堆叠方式, 如果状态定义的不合适, 就会导致子问题之间没有重叠, 也就不存在状态转换关系了. 没有状态转换关系, 动态规划也就没有意义了, 实际算法就退化为像分治法那样的朴素递归搜索算法.

> 对于装配站问题, 其决策就是选择在当前在工作线上的下一个工作站继续装配, 或者花费一定的开销将其转移到另一条工作线上的下一个工作站继续装配. 如果定义`a[i,j]`为第`i`条工作线的第`j`个装配站需要的装配之间, `k[i,j]`为另一条工作线转移到第`i`条工作线的第`j`个装配站所需要的转移开销, 则装配站问题的状态转换方程可以描述为:
>
> ```js
> s[(1, j)] = min(
>     s[(1, j - 1)] + a[(1, j)],
>     s[(2, j - 1)] + k[(1, j)] + a[(1, j)]
> );
> s[(2, j)] = min(
>     s[(2, j - 1)] + a[(2, j)],
>     s[(1, j - 1)] + k[(2, j)] + a[(2, j)]
> );
> ```

4. 决定边界条件

对于递归加备忘录方式(记忆搜索)实现的动态规划方法, 边界条件时间上就是递归终结条件, 无需额外的计算. 对于使用地推关系直接实现的动态规划方法, 需要确定状态转换方程的递推式的初始条件或边界条件, 否则无法开始递推计算.

> 对于装配站, 初始条件就是工件通过第一个装配站的时间, 对于两条装配线磊说,工件通过第一个装配站的时间虽然不相同, 但是都是确定的值, 就是移入装配线的开销加上一个装配站的装配时间, 因此装配站问题的边界条件就是:
>
> ```js
> s[(1, 1)] = k[(1, 1)] + a[(1, 1)];
> s[(2, 1)] = k[(2, 2)] + a[(2, 2)];
> ```

#### 例子: 字符串的编辑距离

-   我们把两个字符串的相似度定义为: 将一个字符串转换成另外一个字符串时需要付出的代价. 转换可以采用插入, 删除和替换三种编辑方式, 因此转换的代价就是对字符串的编辑次数. 字符串转换的方法不唯一, 不同转换的方法需要编辑的次数也不一样, 最少的那个编辑次数就是字符串的编辑距离(edit distance).

我们先展示一下使用普通的递归法来实现这个算法:

```js
function EditDistance(srcArr, destArr) {
    if (srcArr.length == 0 || destArr.length == 0)
        return Math.abs(srcArr.length - destArr.length);
    if (srcArr[0] == destArr[0]) {
        return EditDistance(srcArr.slice(1), destArr.slice(1));
    }

    let edIns = EditDistance(srcArr, destArr.slice(1)) + 1; //插入字符
    let edDel = EditDistance(srcArr.slice(1), destArr) + 1; //删除字符
    let edRep = EditDistance(srcArr.slice(1), destArr.slice(1)) + 1; //替换字符

    return Math.min(Math.min(edIns, edDel), edRep);
}
```

对于朴素的递归算法, 事件复杂度是 O(3^n). 当字符串的长度非常大的时候, 这个算法将变得无法接受.

现在考虑用动态规划的方法对这个算法进行改进, 这个问题的阶段划分不是很明显, 我们首先定义出问题的状态, 从状态转换关系开始定义阶段和子问题的递推关系.

假设`source`字符串有 n 个字符, `target`字符串有 m 个字符. 如果将问题定义为求解将`source`的`[1...n]`个字符转换为`target`的`[1...m]`个字符所需要的最少编辑次数, 则其子问题定义为将`source`的前`[1...i]`个字符所需要的最少编辑次数. 这就是本问题的最优子结构, 因此我们将状态`d[i,j]`定义为从子串`source[1...i]`到子串`target[1...j]`之间的编辑距离.

根据状态的定义, 两个长度是 5 的字符串最多可以有 25 个状态, 朴素递归方法之所以递归的次数达到了 3^5 数量级, 就是因为大量的状态是重复计算的, 没有剪枝优化. 现在采用动态规划的思想对朴素递归算法进行改造, 首先映入状态的概念, 递归接口增加状态标志参数 `i`和`j`, 其次是引入备忘录概念, 用一个二维表记录每个状态的值, 递归过程中优先进行查表. 所有的状态记录在一个二维表中, 二维表的每个元素定义:

```js
memo[i][j] = {
    distance: null, //编辑距离
    refCount: 0 //0表示没有状态的记录.
};
```

调整后的算法如下所示:

```js
function EditDistance(src, dest, i, j) {
    // console.log(memo[i][j]);
    //查表, 直接返回
    if (memo[i][j].refCount != 0) {
        memo[i][j].refCount++;
        return memo[i][j].distance;
    }

    let distance = 0;

    if (src.substr(i).length == 0) {
        distance = dest.substr(j).length;
    } else if (dest.substr(j).length == 0) {
        distance = src.substr(i).length;
    } else {
        if (src[i] == dest[j]) {
            distance = EditDistance(src, dest, i + 1, j + 1);
        } else {
            let edIns = EditDistance(src, dest, i, j + 1) + 1; //插入字符
            let edDel = EditDistance(src, dest, i + 1, j) + 1; //删除字符
            let edRep = EditDistance(src, dest, i + 1, j + 1) + 1; //替换字符
            distance = Math.min(Math.min(edIns, edDel), edRep);
        }
    }

    memo[i][j].distance = distance;
    memo[i][j].refCount = 1;

    return distance;
}
```

现在已经定义了状态, 并且 EDitDistance()函数中也体现了状态转换关系和状态的边界条件, 接下来我们可以直接给出状态递推关系方式的动态规划算法. 根据决策方式, d[i,j]的递推关系, 分为两种情况, 分别是 source[i]等于 target[j]和 source[i]不等于 target[j]. 两种情况下, d[i,j]的递推关系如下:

-   d[i,j]=d[i,j]+0; source[i]等于 target[j]
-   d[i,j]=min(d[i,j-1]+1,d[i-1,j]+1),d[i-1,j-1]+1); source[i]不等于 target[j].

当其中一个字符串为空字符串, 编辑距离相当于另一个字符串的长度. 所以得到边界条件:

-   d[i,0]=source.length
-   d[o,j]=target.length

确定了递推关系和边界条件, 就可以给出直接利用状态递推关系实现的动态规划算法.

```js
function EditDistance(src, dest) {
    let i = 0;
    let j = 0;
    let d = [];
    for (let i = 0; i <= src.length; i++) {
        d[i] = [];
        for (let j = 0; j <= dest.length; j++) {
            if (i == 0) {
                d[i][j] = j;
            } else if (j == 0) {
                d[i][j] = i;
            } else {
                if (src[i - 1] == dest[j - 1]) {
                    d[i][j] = d[i - 1][j - 1]; //不需要编辑操作
                } else {
                    let edIns = d[i][j - 1] + 1; //source 插入字符
                    let edDel = d[i - 1][j] + 1; //source 删除字符
                    let edRep = d[i - 1][j - 1] + 1; //source 替换字符

                    d[i][j] = Math.min(Math.min(edIns, edDel), edRep);
                }
            }
        }
    }
    //   console.log(d);
    return d[src.length][dest.length];
}
```

虽然动态规划比较抽象, 但是只要确定了问题的实质, 按照上面给出的四个步骤逐步分析, 实现动态规划也不是很困难的事. 如果直接用递推方式很难写出的算法实现, 不妨考虑采用带备忘录的递归方式, 也可以叫动态规划不是吗.

### 解空间的穷举搜索

**穷举法(穷举搜索法)** 的解空间, 又称状态空间, 是所有可能是解的候选解的集合, 之所以特别强调在解空间内穷举搜索, 就是想要传达, 穷举并不是漫无目的的查找, 它是一种在有限的解空间内按一定策略进行查找的算法. 有时候, 也叫枚举.

穷举通常被称为"最后的办法", "不是办法的办法", 然而它是很多问题的唯一解决方法.

基本思想:

1. 确定问题的解的定义, 解空间的范围和正确解的判定条件.
2. 根据解空间的特点选择搜索策略.

#### 解空间搜索策略:

1. 盲目搜索法

常见的盲目搜索算法有广度优先搜索和深度优先搜索等.

2. 启发式搜索算法

当问题到达一定规模, 盲目搜索算法就因为低效而不可接受. 利用搜索过程中出现的额外信息直接跳过一些状态避免盲目, 机械式的搜索, 就可以加快搜索算法的收敛, 就是死启发式搜索.

3. 剪枝策略

对解空间穷举搜索时, 对一些状态节点可以进行排除, 跳过此状态节点的遍历, 将极大的提高算法的执行效率, 这就是剪枝策略.

4. 搜索算法的评估和收敛

当解空间的规模大到无法对解空间进行完整的搜索, 这时候就需要对搜索算法进行评估, 并确定一些收敛原则. 收敛原则就是只要能找到一个较好的解就返回, 并根据解的评估判断时候需要继续下一次搜索. 很多棋类游戏就利用了这种算法.

#### 例子: Google 方程式

-   有一个由字符组成的等势:WWWDOT - GOOGLE = DOTCOM , 每个字符代表一个 0~9 之间的数字, WWWDOT,GOOGLE,DOTCOM 都是合法的数字, 不能以 0 开头. 请找出一组字符和数字的对应关系, 使它们相互替换, 并且替换后的数字能够满足等式.

现在来考虑一种解决这种字符方程问题的通用解法. 从数据结构定义上, 首先要避免使用固定 9 个字符的方法, 因此定义一个可变化的字符元素列表, 每个字符元素包含 3 个属性: 字母本身, 字母代表的数字, 是否是数字的最高位:

```js
let tagCharItem = {
    c: "",
    value: -1,
    leading: false
};
```

对于此题, 可以初始化列表:

```js
//字母的数据结构
function tagCharItem(c, value, leading) {
    this.c = c;
    this.value = value;
    this.leading = leading;
}

//用来表示数字是否已经被使用的数据结构
function tagCharValue(used, value) {
    this.used = used;
    this.value = value;
}

let chatItem = [
    new tagCharItem("W", -1, true),
    new tagCharItem("D", -1, true),
    new tagCharItem("O", -1, false),
    new tagCharItem("T", -1, false),
    new tagCharItem("G", -1, true),
    new tagCharItem("L", -1, false),
    new tagCharItem("E", -1, false),
    new tagCharItem("C", -1, false),
    new tagCharItem("M", -1, false)
];

let charValue = [
    new tagCharItem(false, 0),
    new tagCharItem(false, 1),
    new tagCharItem(false, 2),
    new tagCharItem(false, 3),
    new tagCharItem(false, 4),
    new tagCharItem(false, 5),
    new tagCharItem(false, 6),
    new tagCharItem(false, 7),
    new tagCharItem(false, 8),
    new tagCharItem(false, 9)
];
```

搜索主体算法如下:

```js
let max_char_count = charItem.length;
let max_num_count = charValue.length;

function SearchingResult(ci, cv, index, callback) {
    if (index >= max_char_count) {
        callback(ci);
        return;
    }

    for (let i = 0; i < max_num_count; i++) {
        if (isValueValid(ci[index], cv[i])) {
            cv[i].used = true;
            ci[index].value = cv[i].value;
            SearchingResult(ci, cv, index + 1, callback);
            cv[i].used = false;
        }
    }
}
```

评估函数如下:

```js
function isValueValid(ci, cv) {
    if ((cv.value == 0 && ci.leading) || cv.used) {
        return false;
    } else {
        return true;
    }
}
```

回调函数:

```js
function onCharListReady(ci) {
    let minuend = "WWWDOT";
    let subtrahead = "GOOGLE";
    let diff = "DOTCOM";

    let m = makeIntegerValue(ci, minuend);
    let s = makeIntegerValue(ci, subtrahead);
    let d = makeIntegerValue(ci, diff);

    if (m - s == d) {
        console.log(`${m} - ${s} = ${d}`);
    }
}
```

转换函数:

```js
function makeIntegerValue(ci, str) {
    let t_str = str.toString().split("");
    let p_number = [];
    for (let i = 0; i < t_str.length; i++) {
        for (let j = 0; j < ci.length; j++) {
            if (t_str[i] == ci[j].c) {
                p_number.push(ci[j].value);
            }
        }
    }
    return parseInt(p_number.join(""));
}
```

对于本题, 合法的答案如下:

-   777589 - 188103 = 589486
-   777589 - 188106 = 589483

## 第四章 阿拉伯数字与中文数字

### 中文数字的特点

-   中文数字的每个计数数字都跟着一个权位, 这个权位就是这个数字的量值, 相当于阿拉伯数字的数位. 最低位的数组没有权位.
-   中文计数的另一特点是以万为小节. 每一个小节都有一个节权位, 万以下的节没有节权位, 万以上的节权位就是万, 再大就是亿.
-   "零"的使用变化多端. 阿拉伯数字中数字的权位依靠数字在占整个数字长度中的偏移位置确定, 因此数字中间出现的 0 用于标记数字的偏移位置, 即便是连续出现的 0 也不能省略. 中文计数方式中每个数字的权位直接跟在数字后面, 因此可以用一个"零"表示连续出现的若干个 0. 此外还有不使用"零"的时候, 总结规则如下:
    -   以 10000 为小节, 小节结尾不使用零
    -   小节内两个非零数字之间如果有零就要使用零
    -   小节的千位为 0,且小节前一小节无其他数字, 则不用零

### 阿拉伯数字转中文数字

大致上解决三个问题:

1. 单个字符转换
2. 节权识别
3. 零的处理

```js
//数字映射
let chnNumChar = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九"];

//节权
let chnUnitSection = ["", "万", "亿", "万亿"];

//节内数字权位
let chnunitChat = ["", "十", "百", "千"];

function Number2Chinese(num) {
    let unitPost = 0;
    let strIns = "";
    let chnStr = "";
    let needZero = false;

    while (num > 0) {
        let section = parseInt(num % 10000);
        if (needZero) {
            chnStr = chnNumChar[0] + chnStr;
        }
        strIns = Selection2Chinese(section);

        // 是否需要节权位
        strIns += section != 0 ? chnUnitSection[unitPost] : chnUnitSection[0];
        chnStr = strIns + chnStr;
        // 下一节需要补零
        needZero = section < 1000 && section > 0;
        num = parseInt(num / 10000);
        unitPost++;
    }

    return chnStr;
}

//将一个节的数字转换成中文数字
function Selection2Chinese(section) {
    let strIns = "";
    let chnStr = "";
    let unitPost = 0;
    let zero = true;
    while (section > 0) {
        let v = parseInt(section % 10);
        if (v == 0) {
            if (section == 0 || !zero) {
                zero = true;
                chnStr = chnNumChar[v] + chnStr;
            }
        } else {
            zero = false;
            strIns = chnNumChar[v];
            strIns += chnunitChat[unitPost];
            chnStr = strIns + chnStr;
        }
        unitPost++;
        section = parseInt(section / 10);
    }

    return chnStr;
}
```

提示：
只需要把数组中的中文数字和权位明恒进行相应的修改, 使用相同的换算方法就可以. 如果用于人民币记账, 可调整节权位的名称, 加上"圆"或"圆整".

### 中文数字转阿拉伯数字

从中文数字转阿拉伯数字的基本方法就是从中文数字中逐个识别出数字和权位的组合, 然后根据权位和阿拉伯数字倍乘的对应关系计算出每个数字和权位组合的值, 最后求和得到结果.

```js
//数据结构
function CHN_NAME_VALUE(name, value, secUnit) {
    this.name = name; //中文权位名称
    this.value = value; //10的倍数值
    this.secUnit = secUnit; //是否是节权位
}

// 建立关系表
let chnValuePair = [
    new CHN_NAME_VALUE("十", 10, false),
    new CHN_NAME_VALUE("百", 100, false),
    new CHN_NAME_VALUE("千", 1000, false),
    new CHN_NAME_VALUE("万", 10000, true),
    new CHN_NAME_VALUE("亿", 100000000, true)
];

function Chinese2Number(chnString) {
    let rtn = 0;
    let section = 0;
    let number = 0;
    let secUnit = { value: false };
    let pos = 0;

    while (pos < chnString.length) {
        let num = Chinese2Value(chnString.substr(pos, 1));
        // console.log(num,pos,chnString,chnString.length);
        if (num >= 0) {
            //数字还是单位
            number = num;
            pos++;
            if (pos >= chnString.length) {
                //如果最后一位是数字, 直接结束
                section += number;
                rtn += section;
                break;
            }
        } else {
            let unit = Chinese2Unit(chnString.substr(pos, 1), secUnit);
            if (secUnit.value) {
                //节权位, 说明一个节已经结束
                section = (section + number) * unit;
                rtn += section;
                section = 0;
            } else {
                section += number * unit;
            }

            number = 0;
            pos++;
            if (pos >= chnString.length) {
                rtn += section;
                break;
            }
        }
    }
    return rtn;
}

function Chinese2Value(str) {
    //映射表
    let chn_num_char = [
        "零",
        "一",
        "二",
        "三",
        "四",
        "五",
        "六",
        "七",
        "八",
        "九"
    ];

    for (let i = 0; i < chn_num_char.length; i++) {
        const el = chn_num_char[i];
        if (el == str) {
            return i;
        }
    }

    return -1;
}

function Chinese2Unit(str, secUnit) {
    for (let i = 0; i < chnValuePair.length; i++) {
        const el = chnValuePair[i];
        if (str == el.name) {
            if (el.secUnit) {
                secUnit.value = true;
            } else {
                secUnit.value = false;
            }
            return el.value;
        }
    }

    console.error("非法权位:" + str);
    return false;
}
```

## 第五章 三个水桶等分八升水

-   有三个容积分别是 3 升, 5 升, 8 升的水桶, 其中 8 升的水桶中装满了水, 另外两个则是空水桶. 水桶没有体积刻度, 现在需要将大水桶的 8 升水等分成两份, 每份都是 4 升水, 附加条件是只能使用另外两个空水桶, 不能借助其他辅助容器.

如果是用人的思维方式, 那么问题的关键是如何凑出 1 升水或能容纳 1 升水的空间.

但是计算机不会理解这个"1"的重要性, 就很难按照人类的思维方式来推导出答案.

使用穷举法，首先要定义问题的解, 并分析解空间的范围和拓扑结构. 然后根据解空间的范围和拓扑结构设计遍历算法.

对于这个问题, 如果我们把某一是个三个水桶中存水的情况称为一个状态, 则问题的初始状态是 8 升水装满, 3/5 升水桶为空. 最终状态为 3 升水桶为空, 5/8 升水桶各 4 升水.

针对这个问题的 **穷举法** 的实质就是从初始厨师开始, 根据某种状态变化的规则搜索全部可能的状态, 每当找到一个从初始胡状态到最终状态的变化路径, 就可以理解为找到了一个解, 这条从初始状态到最终状态的路径就是倒水问题的一种状态.

状态都是静止的, 从初始状态到最终状态的变化需要一种 **推动力**, 接下来需要找到一种 **推动力**推动状态发生变化. 这个推动力就隐含在问题描述中的"倒水动作". 每个动作试试的结果就是从一个水桶倒水到另一各水桶. 水桶中水的状态就发生变化了, 于是状态也就变化了. 如果能找到一种方式, 持续地促使倒水动作发生, 是的状态能不停地随动作变化, 那就等于找到了本体的解空间搜索方法.

### 建立数学模型

#### 状态的数学模型与状态树

所谓的静止状态, 就是某一时刻三个水桶中存留水的体积, 我们用长度为 3 的一维向量来描述这个状态, 这组向量的是哪个值分别是容积为 8/5/3 升桶水量. 所以初始状态就可以描述为[8,0,0], 终止状态为[4,4,0].

倒水动作与静止状态的结合就产生了状态变化, 持续的状态变化就产生了一颗状态树, 这个状态树上的所有状态就构成了穷举算法的解空间.

![an image](/img/funofAL/TIM截图20181002134521.png)

#### 倒水动作的数学模型

两个静止状态是通过倒水动作建立关联的, 这里说的倒水动作必须是合法的倒水动作. 因为水桶是没有体积刻度的. 因此倒水动作不能是任意的, 必须符合一定的规则.

一个合法的倒水动作包含三个要素: 倒出水的桶, 导入水的桶和倒水体积. 我们一样用一个三元组来描述倒水动作: {from, to, water}.

某一时刻三个水桶中的存水状态, 经过某个倒水动作后演变到一个新的存水状态. 这是对状态转换的文字描述, 对算法来讲, 倒水状态描述就是 "静止状态" + "倒水动作". 讲静止状态和倒水动作组合在一起可以输出结果.

这个模型的特例就是如何得到第一个状态. 我们用 -1 表示未知的水桶编号, 因此第一个状态对应的倒水动作就是{-1,1,8}. 应用本模型对前面提到的第一种解决方法惊醒状态转换描述, 整个过程如下所示:

![an image](/img/funofAL/TIM截图20181002142543.png)

### 搜索算法

确定了状态模型后, 就需要解决算法面临的第二个问题: 状态树的搜索算法. 一个静止状态结合不同的倒水动作会迁移到不同的状态, 所有状态转换所展示的就是一个状态树.

对于本问题, 状态树只有一个根节点. 对于树状结构的搜索, 可以采用深度优先算法或者广度优先算法. 两种方法各有优缺点, 广度优先算法不会因为状态重复出现而导致状态环路, 缺点是需要比较多的存储空间记录中间状态. 深度优先搜索的优点是在同一时间只需要存储从根节点到当前搜索状态节点这一条路径上的状态节点, 需要的存储空间比较小, 缺点是要对搜索过程中因出现重复状态导致的状态环路做特殊处理, 避免状态搜索时出现死循环的情况.

状态树的搜索就是对整个状态树进行遍历, 其中暗含了状态的生成. 状态树一开始只有一个初始状态的根节点, 当搜索(遍历)操作完成时, 状态树才完整. 就本题而言, 深度优先算法更加适合, 因为要记录从初始状态到最终状态.

#### 状态的遍历

状态树的遍历暗含状态生成的过程, 就是促使状态树上的一个状态向下一个状态转换的驱动过程. 本题状态树遍历的关键是找到三个水桶之间所有合法的倒水动作, 用这些倒水动作分别 "生成" 各自相应的新状态.

遍历所有可能的倒水动作就是对三个水桶任取两个进行全排列, 这种排列的结果可以得到 6 种水桶的排列关系， 意味着 6 种对应的倒水动作. 将这 6 中倒水动作依次应用到当前状态, 就可以生成 6 种新状态, 从而驱动状态发生变化. 当然, 受当前水桶的状态影响, 不是 6 种倒水动作都是合法的. 这个需要根据当前的存水状态进行判断.

#### 剪枝和重复状态判断

采用深度优先搜索状态树, 会遇到重复状态导致的状态环路. 具体比如, 某一四个从 1 号桶倒 3 升水倒 3 号桶, 下一时刻又从 3 号桶倒 3 升水到 1 号桶, 就行了状态贿赂. 或者几个状态之后再回到原来的状态. 会是的状态树分之陷入死循环.

此外, 如果对一个状态树分支上的某个状态经过检索, 已经得到了它的结果, 那再在其他分支遇到这个状态, 应当直接给出结果, 或跳过搜索. 这就是一种形式的"剪枝", 可以使得深度优先搜寻很快收敛到初始状态.

还有一个要求, 在搜索到最终状态时, 输出搜索过程中记录的状态, 以便还原整个过程的倒水动作. 这也需要一个列表用于记录一次深度优先遍历过程中已经处理过的状态. 算法设计时可以考虑将这两个表合二为一. 如此一来, 这个列表不仅要支持从一端插入和删除状态, 还要支持从头到尾的遍历所有记录. 从这两方面考虑, 我们采用双端队列数据结构来维护这个记录列表.

### 算法实现

一些小的函数就不贴了, 核心代码如下:

```js
//状态搜索算法的核心
//首先检查当前状态列表的最后一个状态是否是结果需要的最终状态
//否则通过两重循环遍历6中可能的倒水动作
//将这些动作分别于当前状态结合形成新的状态, 然后继续搜索新的状态
function SearchState(states) {
    //每次搜索都从当前状态开始
    let current = states[states.length - 1];
    // console.log(current);
    if (IsFinalState(current)) {
        PrintResult(states);
        return;
    }
    for (let j = 0; j < BUCKETS_COUNT; j++) {
        for (let i = 0; i < BUCKETS_COUNT; i++) {
            SearchStateOnAction(states, current, i, j);
        }
    }
}

function SearchStateOnAction(states, current, from, to) {
    if (CanTakeDumpAction(from, to, current)) {
        let res = DumpWater(from, to, current);
        if (res && !IsProcessedState(states, res)) {
            states.push(res);
            SearchState(states);
            states.pop();
        }
    }
}

//完成实际的倒水动作
function DumpWater(from, to, current) {
    let curState = current.curstate;
    let to_water = bucketArr[to].c - curState[to]; //to水桶中可倒的水
    let from_water = curState[from]; //from水桶中有的水
    let water = -1;
    if (from_water < to_water) {
        water = from_water;
    } else {
        water = to_water;
    }

    if (water == -1) {
        console.log("get water error");
        return false;
    } else {
        let state = curState.concat();
        state[from] -= water;
        state[to] += water;

        let newAction = new tagACTION(from, to, water);
        let newState = new BuckState(newAction, state);

        return newState;
    }
}
```

## 第六章 妖怪与和尚过河问题

-   有三个和尚和三个妖怪, 要利用唯一一条小船过河, 这条小船一次只能载两个人, 同时, 无论在河的两岸还是在船上, 只要妖怪的数量大于和尚的数量, 妖怪们就会将和尚吃掉. 现在要选择一种过河的安排, 保证和尚和妖怪都能过河且和尚不能被妖怪吃掉.

这里有一种过河的方法:

1. 两个妖怪过河, 一个妖怪返回
2. 两个妖怪过河, 一个妖怪返回
3. 两个和尚过河, 一个妖怪和一个和尚返回
4. 两个和尚过河, 一个妖怪返回
5. 两个妖怪过河, 一个妖怪返回
6. 两个妖怪过河

### 问题与求解思路

这个问题里的几个关键因素, 就是 和尚, 妖怪, 小船, 以及它们的位置.

如果把任意时刻的 妖怪, 和尚和小船 的位置信息合在一起看做一个"状态", 则要解决这个问题只需要找到一条从初始状态变换到终止状态的路径就可以了. 这样考虑这个问题, 就可以尝试使用前面一章中的穷举法, 遍历所有由妖怪, 和尚和小船的位置构成的状态空间, 寻找一条或多条从初始状态到最终状态的转换路径.

### 建立数学模型

这里介绍的算法和前一章的算法类似, 都是从一个根状态开始对状态空间进行搜索, 其结果也是一棵状态搜索树. 解决本问题的关键是建立状态和动作的数学模型, 并找到一种持续驱动动作产生的搜索方法.

#### 状态的数学模型与状态树

观察本问题的状态, 我们可以用四个属性来表示, 分别是 河左岸和尚的数量, 河左岸妖怪的数量, 河右岸和尚的数量和河右岸妖怪的数量. 每当有妖怪或和尚随船移动发生变化时, 只需要修改和尚和妖怪的河两岸的数量即可完成状态的转换. 除了和尚和妖怪的数量, 还有一个关键因素也会影响到状态的变化, 那就是小船的位置. 小船的位置会决定状态的差异, 并且会影响后序动作的选择.

最后的状态模型中, 和尚与妖怪的状态就是数值, 船有两个枚举状态, 河左岸(LOCAL)和在河对岸(REMOTE). 我们用一个五元组来表示某个时刻的过河状态: [本地和尚数, 本地妖怪数, 对岸和尚数, 对岸妖怪数, 船的位置].

所以, 初始状态就是 [3, 3, 0, LOCAL]. 最终过河状态是[0, 0, 3, 3, REMOTE].

```ts
interface ItemState {
    local_monster: number;
    local_monk: number;
    remote_monster: number;
    remote_monk: number;
    boat: boolean;
}
```

状态模型确定以后, 整个状态空间的树模型也就确定了.

#### 过河动作的数学模型

河两岸的和尚与妖怪的数量发生变化的直接原因是小船的位置关系发生变化, 因为船上至少要有一个和尚或者一个妖怪, 所以只要船的位置发生变化, 必然会引起状态的变化. 过河动作是促使船的位置发生变化的原因, 也就是连接装个状态的转换关系. 这个转换关系包含两个部分内容, 一部分是船的位置变化, 另一部分是船上的妖怪或和尚的数量, 这个数量会引起两岸的和尚和妖怪的数量发生变化.

过河动作的数学模型需要明确定义两个内容, 也就是动作引起的船的位置变化情况和此动作移动的和尚或妖怪的数量. 数据结构定义如下:

```ts
interface tagActionEffection {
    act: ACTION_NAME;
    boat_to: BOAT_LOCATION; //船移动的方向
    move_monster: number; //此次移动的妖怪数量
    move_monk: number; //此次移动的和尚数量
}
```

"三个水桶等分水问题"中的动作是通过排列组合三个水桶的关系产生的. 但是过河问题没有这个条件. 虽然不能通过排列组合产生动作, 但是通过对问题的观察, 过河问题的所有过河动作其实是一个有限的动作集合. 看一下上面的数据结构, 所有的过河动作其实是一个有限的动作集合, 所有一共的过河动作有:

-   一个妖怪过河
-   两个妖怪过河
-   一个和尚过河
-   两个和尚过河
-   一个和尚和一个妖怪过河
    以及相应的返回动作. 总共 10 种. 通过整理可以归纳为以下动作列表:

```js
let actEffect=[
  {ONE_MONSTER_GO,           REMOTE,-1,0},
  {TWO_MONSTER_GO,           REMOTE,-2,0},
  {ONE_MONK_GO,              REMOTE,0,-1},
  {TWO_MONK_GO,              REMOTE,0,-2},
  {ONE_MONSTER_ONE_MONK_GO,  REMOTE,-1,-1},
  {ONE_MONSTER_BACK,         LOCAL,1,0},
  {TWO_MONSTER_BACK,         LOCAL,2,0},
  {ONE_MONK_BACK,            LOCAL,0,1},
  {TWO_MONK_BACK,            LOCAL,0,2},
  {ONE_MONSTER_ONE_MONK_BACK,LOCAL,1,1}
]
```

这里负数表示从本地移动到河对岸, 这个动作列表是进行状态转换一致性处理的基础, 直接使用这张表就不需要对每种动作都进行特殊处理, 避免使用长的 if 语句或 switch 语句.

### 搜索算法

本章使用的仍然是深度优先遍历算法, 每次遍历只暂时保存当前搜索的分支的所有状态, 之前搜索过的分支上的状态是不保存的, 只在必要的时候输出结果. 所以, 算法不需要完成的树状结构保存整个状态树, 只需要一个队列就可以暂时存储当前搜索分支上的所有状态.

### 算法实现

其他部分不贴了, 核心代码如下:

```js
//算法核心
//函数每次从状态队列尾部去除当前要处理的状态,
//首先判断是否是最终的过河状态, 如果是则输出一组过河方案, 如果不是,
//则尝试用动作列表中的动作与当前状态结合, 看看能够生成合法的新状态.
function SearchState(states) {
    let current = states[states.length - 1];
    if (IsFinalState(current)) {
        PrintResult(states);
        return;
    }
    //分别用10中动作与当前状态组合
    for (let i = 0; i < actEffect.length; i++) {
        SearchSatesOnNewAction(states, current, actEffect[i]);
    }
}

function SearchSatesOnNewAction(states, current, action) {
    let nextState = MakeActionNewSate(states, current, action);
    if (
        nextState &&
        IsValidState(nextState.state) &&
        !IsProcessdState(states, nextState.state)
    ) {
        states.push(nextState);
        SearchState(states);
        states.pop();
    }
}

//执行动作

function MakeActionNewSate(states, current, action) {
    if (CanTakeAction(current.state, action)) {
        let newstate = clone(current.state);
        newstate.local_monster += action.monster;
        newstate.local_monk += action.monk;
        newstate.remote_monster -= action.monster;
        newstate.remote_monk -= action.monk;
        newstate.boat = action.boat_to;
        let newNode = new ItemState(newstate, action);
        return newNode;
    }

    return false;
}
```

## 第七章 稳定匹配与舞伴问题

### 稳定匹配问题描述

什么是稳定匹配?

假设 n 个未婚男人的集合`M={m1,m2,...,mn}`和 n 个未婚女人的集合`W={w1,w2,...,wn}`, 令 MxW 为所有可能的形如`(mj,wi)`有序对的集合, 其中`mj∈M`,`wi∈W`.

根据上述定义,

-   匹配: 匹配 S 是来自 MxW 中的有序对的集合, 并且具有以下性质: 每个 M 的成员和每个 W 的成员之多出现在 S 的一个有序对中.
-   完美匹配: 完美匹配 S'是一个具有以下性质的匹配, M 的每个成员和 W 的每个成员恰好出现在 S'的一个对里. S 和 S'这两个定义的差别就在于"至多"和"恰好". 实际上就是说,S 中不一定所有成员都能配对成功, 还有剩余的男人和女人. 而完美匹配 S'则是指所有人都配对成功, 不存在单身的男人和女人.

现在在完美匹配的背景下引入优先或偏好的概念, 每个男人都按照个人喜好对所有女人排名, 如果某个男人 m 给女人 w 的排名高于给 w'的排名, 就可以理解为 m 喜好 w 胜过 w'. 反之女士亦然. 以上排名不存在并列. 那么什么是稳定匹配呢?

稳定匹配就是在引入优先排名的情况下, 一个完美配位 S 如果不存在不稳定因素, 则称这个完美匹配是稳定匹配. 什么是不稳定因素呢? 假设在完美匹配 S 中存在着两个配对(m,w)和(m',w'), 但是从优先排名上, m 更偏好 w', 同时 w'更偏好 m. 在这种情况下, 我们称这个完美匹配 S 是不稳定的. 像(m,w')这样有"私奔"倾向的不稳定对(unstable pair)就是 S 的一个不稳定因素.

稳定匹配满足两个条件: 1. 它是一个完美匹配. 2. 它不含任何不稳定因素.

Gale-ShapLey 算法就是一种著名的稳定匹配算法. 下面简单的介绍一下该算法的原理.

### Gale-Shapley 算法原理

先看一下算法的伪代码:

```
初始化所有的m∈M,w∈W, 所有的m和w都是自由状态
while(存在男人是自由的, 并且他还没有对每个女人都求过婚){
  选择一个这样的男人m;
  w=m的优先选择表中还没有求过婚的排名最高的女人;
  if(w是自由状态){
    将(m,w)的状态设置为约会状态;
  }else{//w已经和其他男人约会了
    m* = w当前约会的男人;
    if(w更喜爱m'而不是m){
      m保持单身状态(w不更换约会对象)
    }else{//w更喜欢m而不是m*
      将(m,w)的状态设置为约会状态
      将m'设置为自由状态
    }
  }
}

给出已经匹配的集合S
```

基于男女平等的原则, 也可以是女士优先选择, 男士被动接受, 这就是常被提到的两个策略: "男士优先"和"女士优先".

可以通过反证法证明该算法满足稳定匹配的两个条件.

### Gale-Shapley 算法的应用实例

舞伴问题: 有 n 个男孩和 n 个女孩, 每个男孩和女孩都交给主持一个名单, 写上他(她)偏好的舞伴名称. 无论男孩还是女孩, 提交给主持人的名单都是按照偏爱程度排序的, 排在前面的都是他们最中意的舞伴. 主持人在收到名单后, 是否可以将他们分成 n 对, 使每个人都能和他们中意的舞伴结伴跳舞? 要求这些舞伴的关系是稳定的.

#### 算法实现

根据题意, 一个舞伴至少需要包含两个属性: 每个人的偏好舞伴列表和当前选择的舞伴. 根据 Gale-Shapley 算法的规则, 还需要有一个属性表示下一次要向哪个偏好的舞伴提出跳舞要求. 但是用"男士优先"策略时, 这个属性提供给男士列表, 反之, 提供给女士列表.

此外, 我们给每个舞伴加上名字, 数据结构定义如下:

```js
function tagPartner(name, next, current, pCount, perfect) {
    this.name = name; //名字
    this.next = next; //下一个邀请对象
    this.current = current; //当前舞伴, -1表示没有
    this.pCount = pCount; //偏爱列表中舞伴个数
    this.perfect = perfect; //偏爱列表
}
```

根据标准来说, `pCount`的值应当和`perfect`的长度是一致的. 如果这里的长度不一致, 最后得出的结果不一定是稳定匹配的结果, 就需要设置相应的条件并使用更加复杂的证明方法.

算法实现如下:

```js
//按照名字搜索序列号
function FindIndexByName(name, datas) {
    for (let i = 0; i < datas.length; i++) {
        if (datas[i].name == name) {
            return i;
        }
    }

    return -1;
}

//算法主体
function Gale_Shapley(boys, girls, count) {
    let bid = FindFreePartner(boys, count);
    while (bid >= 0) {
        let girlName = boys[bid].perfect[boys[bid].next];
        let gid = FindIndexByName(girlName, girls);
        if (girls[gid].current == -1) {
            boys[bid].current = gid;
            girls[gid].current = bid;
        } else {
            let bpid = girls[gid].current;

            let bpname = boys[bpid].name;
            let bname = boys[bid].name;
            //女孩更喜欢bid超过当前舞伴pbid
            if (
                GetPerfectPosition(girls[gid], bpname) >
                GetPerfectPosition(girls[gid], bname)
            ) {
                boys[bpid].current = -1; //当前舞伴恢复自由
                boys[bid].current = gid; //结交新舞伴
                girls[gid].current = bid;
            }
        }
        boys[bid].next++; //无论是否配对成功, 只对同一个女孩邀请一次
        bid = FindFreePartner(boys, count);
    }
    return IsAllPartnerMatch(boys, count);
}

//从男孩列表中找一个还没有舞伴, 并且偏好列表中还没有邀请过女孩的男孩, 返回男孩的索引.
function FindFreePartner(boys, count) {
    for (let i = 0; i < count; i++) {
        if (boys[i].current == -1) {
            return i;
        }
    }
    return -1;
}

//用于判断女孩喜欢一个舞伴的程度, 通过返回舞伴在自己偏爱列表中的位置索引, 索引越小, 程度越高
function GetPerfectPosition(girl, boyName) {
    for (let i = 0; i < girl.pCount; i++) {
        if (girl.perfect[i] == boyName) {
            return i;
        }
    }

    return -1;
}

function IsAllPartnerMatch(boys, count) {
    for (let i = 0; i < count; i++) {
        if (boys[i].current == -1) {
            return false;
        }
    }
    return true;
}
```

#### 改进优化: 空间换时间

为了避免在多伦选择过程中频繁遍历每个`partner`的偏好舞伴列表, 需要对 partner 到底更偏爱哪个舞伴的判断策略进行改进.

改进的原则就是"空间换时间". 简单来讲, 就是用一张初始化号的表存储这些位置关系, 在使用过程中, 以时间复杂度的方式直接查表确定偏爱舞伴的关系. 这样的表可以是线性表, 也可以是哈希表这样的映射表. 对于这个问题, 我们使用二维表来存储这些位置关系, 假设存在二维表 `priority[w][m]` 表示 m 在 w 的偏好列表中的位置, 这个值越小, 表示 m 在 w 的偏好列表中的位置越靠前.

开始算法之前, 首先初始化这个关系表:

```js
function produceTable(cCount, boys_origin, girls_origin) {
    let priority = [];
    for (let w = 0; w < cCount; w++) {
        let perfect = girls_origin[w][4];
        let priority_col = [];
        for (let j = 0; j < cCount; j++) {
            let index = perfect.indexOf(boys_origin[j][0]);
            priority_col.push(index);
        }
        priority.push(priority_col);
    }
    return priority;
}
```

最后将对`GetPerfectPostion()`函数的调用替换成查表即可.

### 有多少稳定匹配

稳定匹配的结果不是唯一的, 其实只要将计算策略从"男士优先"转换成"女士优先", 就可以得到另外一个完全不同的稳定匹配结果, 同样调整男士的位置, 也能得到一个完全不同的稳定匹配结果.

那么, 到底有多少个稳定匹配? 稳定屁屁额首先必须是完美匹配, 而且稳定匹配的个数小于或等于完美匹配, 理论上完美匹配的数量应该是

```math
  M=C(1/n)C(1/n-1)...=n!
```

仅仅从排列组合问题考虑, 随着男士顺序的变化, 这个数字会成倍的增加, N 个男孩全排列有 n!种变化, 所以最终有(n!)^2 种结果, 其中很多是互选的重复和无意义的.

#### 穷举所有完美匹配

想要知道到底有多少稳定匹配, 首先要知道有多少完美匹配. 其具体的方法就是使用迁居方法找到全部的完美匹配, 然后根据条件将包含不稳定因素的完美匹配过滤掉, 剩下的就是稳定匹配. 遵循这个原则, 先来穷举所有的完美匹配算法.

穷举算法的数据结构定义仍然使用前面 PARTNER 的定义, 其中的 next 属性用不上. 穷举的方法就是每一为一个男孩选择一个舞伴, 选择的方法就是从男孩的偏爱列表中找一个还没有舞伴的女孩, 确定为这个男孩的舞伴, 同时将男孩和女孩对应的 current 属性指向对方.

```js
function SearchStableMatch(index, boys, girls) {
    if (index == UNIT_COUNT) {
        if (IsStableMatch(boys, girls)) {
            //如果是稳定的就输出这一组的完美稳定匹配
            PrintResult(boys, girls, UNIT_COUNT);
        }
        return;
    }

    for (let i = 0; i < boys[index].pCount; i++) {
        let gname = boys[index].perfect[i];
        let gid = -1;
        girls.forEach((item, index) => {
            if (item.name == gname) gid = index;
        });
        if (
            !IsPartnerAssigned(girls[gid]) &&
            IsFavoritePartner(girls[gid], index, boys)
        ) {
            boys[index].current = gid;
            girls[gid].current = index;
            SearchStableMatch(index + 1, boys, girls);
            boys[index].current = -1;
            girls[gid].current = -1;
        }
    }
}
```

#### 不稳定因素的判断算法

不稳定因素的判断算法就是在一个完美匹配中找出的情况, 这种情况有两个特征:

1. 首先男孩的当前的舞伴不是状态列表中排在第一位的女孩, 也就是说, 男孩更偏爱其他女孩胜过自己当前的舞伴;
2. 其次, 男孩更偏爱的那个女孩刚好也喜欢这个男孩胜过自己当前的舞伴.

于是, 不稳定因素的判断算法就呼之欲出了, 重点就是上诉两个特征的识别. 判断一个完美匹配是否是稳定匹配算法流程如下:

1. 找出这个男孩的当前舞伴在男孩的偏爱列表中的位置, 如果当前舞伴排在偏爱列表的第一位, 则表示这个男孩不存在不稳定因素的可能, 转步骤 4. 如果当前舞伴不是男孩偏爱列表的第一位, 则转到步骤 2
2. 男孩的偏爱列表中如果还有排在当前舞伴之前但还没有进行判断处理的女孩, 则转步骤 3, 否则转步骤 4
3. 找到女孩的当前舞伴在女孩的偏爱列表中的位置和当前处理的男孩在女孩的偏爱列表中的位置, 如果女孩当前舞伴的位置比当前处理的男孩的位置靠前, 则表示对该女孩不存在不稳定因素, 转步骤 2. 如果当前处理的男孩的位置比女孩当前舞伴的位置靠前, 则表示存在不稳定因素, 直接转步骤 6
4. 如果对全部男孩判断完毕, 转步骤 5. 否则, 继续对下一个男孩进行不稳定因素判断转步骤 1
5. 结束, 没有找到不稳定因素
6. 结束, 找到不稳定因素, 此完美匹配不是稳定匹配.

算法实现如下:

```js
//判断是否稳定匹配
function IsStableMatch(boys, girls) {
    for (let i = 0; i < UNIT_COUNT; i++) {
        //找到男孩当前舞伴在自己的偏好列表中位置
        let gpos = GetPerfectPosition(boys[i], boys[i].current, girls);
        //在position位置之前的舞伴, 男孩喜欢她们胜过current
        for (let k = 0; k < gpos; k++) {
            let gname = boys[i].perfect[k];
            let gid = -1;
            girls.forEach((item, index) => {
                if (item.name == gname) gid = index;
            });
            //找到男孩在这个女孩的偏好列表中的位置
            let bpos = GetPerfectPosition(girls[gid], i, boys);
            //找到女孩的当前舞伴在这个女孩的偏好列表中的位置
            let cpos = GetPerfectPosition(girls[gid], girls[gid].current, boys);
            if (bpos < cpos) {
                //女孩也是喜欢这个那还胜过喜欢自己当前的舞伴, 这是不稳定因素
                return false;
            }
        }
    }
    return true;
}
```

#### 穷举的结果

至此, 我们有了穷举法搜索全部稳定匹配结果的算法.

有一个有意思的结论, 稳定匹配的个数总是 2 的整数幂, 此外, 当所有女孩的偏爱列表都完全一样的时候, 无论男孩们的偏爱列表如何选择,最终都只有一种稳定匹配结果. 这里只给出结论, 不予证明.

程序中使用的数据如下:

```js
let boys_origin = [
    ["吕布", -1, 5, ["貂蝉", "大乔", "小乔", "阿丑", "尚香"]],
    ["刘备", -1, 5, ["貂蝉", "小乔", "大乔", "尚香", "阿丑"]],
    ["孔明", -1, 5, ["阿丑", "貂蝉", "小乔", "大乔", "尚香"]],
    ["周瑜", -1, 5, ["小乔", "大乔", "尚香", "貂蝉", "阿丑"]],
    ["曹操", -1, 5, ["小乔", "貂蝉", "大乔", "尚香", "阿丑"]]
];

let girls_origin = [
    ["貂蝉", -1, 5, ["曹操", "吕布", "刘备", "周瑜", "孔明"]],
    ["大乔", -1, 5, ["周瑜", "刘备", "孔明", "吕布", "曹操"]],
    ["小乔", -1, 5, ["周瑜", "孔明", "刘备", "曹操", "吕布"]],
    ["尚香", -1, 5, ["吕布", "刘备", "周瑜", "孔明", "曹操"]],
    ["阿丑", -1, 5, ["孔明", "周瑜", "曹操", "刘备", "吕布"]]
];
```

根据数据, 总共有三种稳定匹配的结果:

```
第1种稳定匹配
第1对: 吕布 <==> 大乔
第2对: 刘备 <==> 貂蝉
第3对: 孔明 <==> 阿丑
第4对: 周瑜 <==> 尚香
第5对: 曹操 <==> 小乔
第2种稳定匹配
第1对: 吕布 <==> 阿丑
第2对: 刘备 <==> 貂蝉
第3对: 孔明 <==> 大乔
第4对: 周瑜 <==> 尚香
第5对: 曹操 <==> 小乔
第3种稳定匹配
第1对: 吕布 <==> 阿丑
第2对: 刘备 <==> 貂蝉
第3对: 孔明 <==> 尚香
第4对: 周瑜 <==> 大乔
第5对: 曹操 <==> 小乔
```

### 二部图与二分匹配

之前讨论的稳定匹配问题时, 我们把完美匹配定义为每个男人和女人都属于某个匹配中的某个对, 并不是很直观, 现在我们准备用图的属于更一般地表达完美匹配的概念.

首先介绍一下二部图, 二部图`G=(V,E)`是这样的一个图, 它的顶点集合 V 可以分为 X 和 Y 两个集合, 它的边集合 E 中的每条边都有一个端点在 X 集合, 另一个端点在 Y 集合. 如下所示:

![an image](/img/funofAL/TIM截图20181006190504.png)

求二部图的最大匹配可以使用最大流(maximal flow)或匈牙利算法(Hungarian algorithm), 接下来我们来介绍匈牙利算法.

#### 最大匹配与匈牙利算法

寻找二部图最大匹配的匈牙利数学家 Edmonds 在 1965 年提出一个简化的最大流算法. 该算法根据二部图匹配这个问题的特点将最大流算法进行了简化, 提高了效率. 图通的最大流算法一般都是基于带权网络模型的, 二部图匹配问题不需要区分图中的源点和汇点, 也不关心边的方向, 因此不需要复杂的网络图模型, 这就是匈牙利算法简化的原因. 正是因为这个原因, 匈牙利算法成为一种很简单的二分匹配算法. 基本流程如下:

```
将图 G 最大匹配初始化为空;
while(从 Xi 点开始在图 G 中找到新的增广路径){
  将增广路径加入到最大匹配中;
}
输出图 G 的最大匹配;
```

根据该算法的流程, 寻找图 G 的增广路径(Augment Path)是匈牙利算法的关键. 先来看看什么是增广路径, 二部图中的增广路径具有以下的性质:

-   路径中边的条数是技术
-   路径的起点在二部图的左半边, 终点在二部图的右半边;
-   路径上的点一个在左半边, 一个在右半边, 交替出现, 整条路径上没有重复的点.
-   只有路径的起点和终点都是未覆盖的点, 路径上其他的点都已经配对;
-   对路径上的边按照顺序编号, 所有奇数编号的边都不在已知的匹配中, 所有偶数编号的边都在已知的匹配中;
-   对增广路径进行"取反"操作, 新的匹配数就比已知匹配数增加一个, 也就是说, 可以得到一个更大的匹配.

所谓的增广路径取反操作, 就是把增广路径上奇数编号的边加入到已知匹配中, 并把增广路径上偶数编号的边从已知匹配中删除. 每做一次"取反"操作, 得到的匹配就比原匹配多一个. 匈牙利算法的思路就是不断的寻找增广路径, 增加匹配个数, 当不能再找到增广路径时, 算法就结束了,得到的匹配就是最大匹配.

增广路径的起点总是在二部图的左边, 因此寻找增广路径的算法总是从一侧的顶点开始, 逐个顶点搜索. 从 Xi 顶点开始搜索增广路径的流程如下:

```
while(从Xi的邻接表中找到下一个关联顶点Yj){
  if(Yj不在增广路径上){
    将Yj加入增广路径;
    if(Yj是未覆盖点或者从与Yj相关联的顶点(Xk)能找到增广路径){
      将Yj的关联顶点修改为Xi;
      从顶点Xi开始有增广路径, 返回true;
    }
  }
  从顶点Xi开始没有增广路径, 返回false;
}
```

在这个算法流程中, "从与 Yj 相关连的顶点(Xk)能找到增广路径"这一步体现的是一个递归过程. 因为如果之前的搜索已经将 Yj 加入到增广路径中, 说明 Yj 在 X 集合中一定有一个关联点, 我们假设 Yj 在 X 集合中的这个关联点是 Xk, 所以要从 Xk 开始继续寻找增广路径. 当从 Xk 开始的递归搜索完成后, 通过"将 Yj 的关联顶点修改为 Xi"这一步操作, 将其与 Xi 联在一起, 形成一条更长的增广路径.

代码示意如下:

```js
//数据结构
function tagMaxMatch(edge, on_path, path, max_match) {
    this.edge = edge; //顶点与边的关系表, 用来表示二部图
    this.on_path = on_path; //定点Yj是否已经在当前搜索过程中形成的增广路径上
    this.path = path; //当前找到的增广路径
    this.max_match = max_match; //当前增广路径中边的条数.
}

//搜索算法
function FindAugmentPath(match, xi) {
    for (let yj = 0; yj < UNIT_COUNT; yj++) {
        if (match.edge[xi][yj] == 1 && !match.on_path[yj]) {
            match.on_path[yj] = true;
            if (
                match.path[yj] == -1 ||
                FindAugmentPath(match, match.path[yj])
            ) {
                match.path[yj] = xi;
                return true;
            }
        }
    }
    return false;
}

//入口函数
function Hungary_Match(match) {
    for (let xi = 0; xi < UNIT_COUNT; xi++) {
        if (FindAugmentPath(match, xi)) {
            match.max_match++;
        }
        ClearOnPathSign(match);
    }
    return match.max_match == UNIT_COUNT;
}
```

匈牙利算法的实现以顶点集合 V 为基础, 每次 X 集合中选一个顶点 Xi 做增广路径的起点搜索增广路径. 搜索增广路径需要遍历边集 E 内所有边, 遍历方法可以采用深度优先遍历或者广度优先遍历. 但无论什么方法, 其时间复杂度是 O(V\*E).

#### 带权匹配与 Kuhn_Munkress 算法

在上一节的匈牙利算法中, 不要求每个个体给出的偏爱列表包含所有异性成员. 这一节我们让问题更加复杂一点, 为舞伴问题引入带权优先表的概念, 为每一个配对指定一个权重, 表明我们更希望哪一对成为舞伴. 通过控制每一对舞伴关系的权重, 使得最后的完美匹配结果中有尽量多的舞伴是我们期望的配对关系.如果使用穷举法的思路, 我们可以穷举所有完美匹配, 然后计算每个完美匹配中个边的权重之和, 取权重之和最大的一个作为最后的结果. 这虽然是一种解决方案, 但是不到万不得已最好不要使用这个方法. 实际上, 这个问题已经演化成了求解二部图的带权匹配问题. 即求出一个匹配集合, 使得集合中各边的权值之和最大或最小. 二部图的最大权或最小权匹配, 不要求这个匹配是完美匹配或最大匹配. 如果一个匹配同时满足最大权匹配和完美匹配, 则这个匹配可以称为最佳匹配.

Kuhn-Munkres 算法, 也称 KM 算法. 是一种求解最大最小权匹配问题的经典算法. 最初的 KM 算法以矩阵为基础结构, 在匈牙利算法发布以后, KM 算法基于匈牙利算法进行了改进. KM 算法通过给每个顶点设置一个标号(顶标)的方式把最大权匹配问题转化为求完美匹配的问题, 最终得到一个最大权完美匹配.

我们假设二部图中 X 顶点集合中每个顶点 Xi 的顶标是 A[i], Y 顶点集合中每个顶点 Yi 的顶标 B[i], 顶点 Xi 和 Yi 之间的边的权重是 weight[i][j], 则 KM 算法的原理就是基于以下定理:

若由二部图中所有满足 `A[i]+B[j]=weight[i,j]` 的边 `(Xi,Yj)` 构成的子图(称作相等子图)有完美匹配, 那么这个完美匹配就是二分图的最大权匹配.

转换原理就是先找出问题对应的相等子图, 然后求相等子图的完美匹配即可. 只要在算法过程中始终满足`"A[i]+B[j]≥weight[i,j]"`这个条件, 这个定理就成立. 因为对于二分图的任意一个匹配, 如果这个匹配是相等子图的匹配, 那么它的边权重之和就等于所有顶点的顶标之和(显然这是最大的); 如果这个匹配不是相等子图的匹配(它的某些边不属于相等子图), 那么它的边权重之和就小于所有顶点的顶标和. 所以只要始终满足上面那个等势的相等子图的完备匹配一定是二分图的最大权匹配.

KM 算法的大致流程如下:

1. 初始化各个顶点的顶标值;
2. 找出符合 `A[i]+B[j]=weight[i,j]`条件的边构成相等子图, 使用匈牙利算法寻找相等子图的完美匹配.
3. 如果找到相等子图的完美匹配, 则算法结束, 否则调整相关顶点的顶标值
4. 重复 2,3, 直到找到完美匹配

初始化顶点的顶标值, 可以使用下面的公式:

$$
\begin{cases}
    A[x_i] = max \\\{ weight[x_i][y_0],weight[x_i][y_1],...,weight[x_i][y_n] \\\} , x_i \in X\\\\
    B[y_j] = 0 , y_j \in Y
\end{cases}
$$

因为A[i]总是取与之相邻的边中最大的权值作为初始值, 因此初始阶段能保证满足`"A[i]+B[j]≥weight[i,j]"`这个条件. 如果在第2步的相等子图中没有找到完美匹配, 说明相等子图中某个顶点出发的增广路径不能覆盖所有顶点. 此时需要调整各个顶点的顶标值, 然后重新再相等子图中寻找完美匹配. 调整顶标的目的是为了扩大相等子图, 使得更多的边进入相等子图, 并最终能够找到一个完美匹配. 设当前增广路径上所有属于X集合的顶点构成一个子集S, 所有属于Y集合的顶点构成一个子集T,dx对顶标调整的变化量, 则dx可采用下面的计算方法:

$$
dx=min\\\{A[x_i]+B[y_j]-weight[x_i][y_j], x_i ∈ S, y_j \notin T \\\}
$$

由dx的计算公式可知, 如果把S集合中所有顶点的顶标都减少dx, 一定会有一条一端在S中, 另一端不在T中的边 因为满足 `A[i]+B[j]=weight[i,j]` 的条件而进入相等子图, 这就扩大了相等子图. 对S集合中所有顶点的顶标都减少dx之后, 为了使原来已经在相等子图中的边继续留在相等子图中, 需要将T集合中所有顶点的顶标值增加dx, 使A[i]+B[j]之和不变. 

总的来说, 采用第一个式子计算出dx, 然后将S集合中所有顶点的顶标值减少dx, 同时将T集合中所有顶点的顶标值增加dx, 这样调整, 整个图上的所有顶点会产生如下四种结果:

- 对于两度那点都在当前相等子图的增广路径上的边 $(x_i,y_j)$, 其顶标值`A[i]+B[j]`的和没有变化. 
- 对于两端点都不在当前相等子图的增广路径上的边, A[i]和B[j]的值没有变化, 也就是说此边和相等子图的关系没有变化
- 对于 $x_i$ 在当前相等子图的增广路径上, $y_j$不在当前路径的边上, 顶标值之和减少, 原来不属于, 现在可能属于, 扩大子图
- 相反的, 顶标值增大, 原来不属于, 现在不属于. 

下面给一个情景来应用KM算法:

#### KM算法应用场景

某公司有5名技术工人, 他们都可以完成5中工作. 每个工人的技术侧重点和熟练程度不同, 所以完成同样工作所产生的经济效益也不同. 效益矩阵如下:

![an image](/img/funofAL/360截图1814122298142123.png)

算法的主要部分如下所示:

```js
//在相等子图中寻找Xi为起点的增广路径
function FindAugmentPath(km, xi) {
  for (let yj = 0; yj < UNIT_COUNT; yj++) {
    if (!km.y_on_path[yj] && km.sub_map[xi][yj]) {
      km.y_on_path[yj] = true;
      let xt = km.path[yj];
      km.path[yj] = xi;
      if (xt == -1 || FindAugmentPath(km, xt)) {
        return true;
      }
      km.path[yj] = xt;
      if (xt != -1) {
        km.x_on_path[xt] = true;
      }
    }
  }
  return false;
}

function ResetMatchPatch(km) {
  for (let i = 0; i < UNIT_COUNT; i++) {
    km.path[i] = -1;
  }
}

function ClearOnPathSign(km) {
  for (let i = 0; i < UNIT_COUNT; i++) {
    km.x_on_path[i] = false;
    km.y_on_path[i] = false;
  }
}

function Kuhn_Munkress_Match(km) {
  let A = new Array(UNIT_COUNT),
    B = new Array(UNIT_COUNT);
  for (let i = 0; i < UNIT_COUNT; i++) {
    B[i] = 0;
    A[i] = -INFINITY;
    for (let j = 0; j < UNIT_COUNT; j++) {
      A[i] = Math.max(A[i], km.edge[i][j]);
    }
  }
  while (true) {
    //初始化带权二分图的相等子图
    for (let i = 0; i < UNIT_COUNT; i++) {
      for (let j = 0; j < UNIT_COUNT; j++) {
        km.sub_map[i][j] = A[i] + B[j] == km.edge[i][j];
      }
    }
    //使用匈牙利算法寻找相等子图的完备匹配
    let match = 0;
    ResetMatchPatch(km);
    for (let xi = 0; xi < UNIT_COUNT; xi++) {
      ClearOnPathSign(km);
      if (FindAugmentPath(km, xi)) {
        match++;
      } else {
        km.x_on_path[xi] = true;
        break;
      }
    }
    //如果找到完备匹配就返回结果
    if (match == UNIT_COUNT) {
      return true;
    }
    //调整顶标, 继续算法
    let dx = INFINITY;
    for (let i = 0; i < UNIT_COUNT; i++) {
      if (km.x_on_path[i]) {
        for (let j = 0; j < UNIT_COUNT; j++) {
          if (!km.y_on_path[j]) {
            dx = Math.min(dx, A[i] + B[j] - km.edge[i][j]);
          }
        }
      }
    }
    for (let i = 0; i < UNIT_COUNT; i++) {
      if (km.x_on_path[i]) {
        A[i] -= dx;
      }
      if (km.y_on_path[i]) {
        B[i] += dx;
      }
    }
  }
}
```

运行结果如下: 

```
x: 1<--->y:0
x: 2<--->y:1
x: 0<--->y:2
x: 4<--->y:3
x: 3<--->y:4
total cost: 14
```

根据表格, 结果如下: 
- 工人1 分配 工作3 (经济效益: 5)
- 工人2 分配 工作1 (经济效益: 2)
- 工人3 分配 工作2 (经济效益: 4)
- 工人4 分配 工作5 (经济效益: 0)
- 工人5 分配 工作4 (经济效益: 3)

最大经济效益评价为14

对于同一个问题, 其最大权匹配的结果可能不唯一, 也就是说, 存在多个匹配的权重之和同为最大值的情况. KM算法可以找出其中的一个, 但是无法找到全部匹配结果. 
