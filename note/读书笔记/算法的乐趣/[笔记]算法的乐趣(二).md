---
title: '[笔记]算法的乐趣(二)'
date: 2018-10-09 22:42:39
mathjax: true
category:
    - 笔记
    - 算法的乐趣
tags:
    - 算法
    - javascript
---


> 算法的乐趣: 第1七章到第十四章

<!-- more -->

# 算法的乐趣 JS 代码实现+笔记(二)

> 主要内容来自算法的乐趣一书. [推荐购买](https://item.jd.com/11670027.html)

---

## 第八章 爱因斯坦的思考题

题目是这样的: 据说有五个不同颜色的房间排成一排, 每个房间的人不同国籍, 喝不同牌子的饮料, 抽不同牌子的烟, 养不同的宠物. 线索如下:

1. 英国人住在红色的房子里
2. 瑞典人养狗
3. 丹麦人喝茶
4. 绿房子紧靠白房子, 在白房子左边
5. 绿房子主人喝咖啡
6. PallMall 牌子香烟的主人养鸟
7. 黄房子的人抽 Dunhill
8. 中间房子的人喝牛奶
9. 挪威人住第一个房子
10. 抽 Blends 香烟的人和养猫的人相邻
11. 养马的人和 Dunhill 香烟的主人相邻
12. 抽 BlueMaster 香烟的人和啤酒
13. 德国人抽 Prince 牌香烟
14. 挪威人和住蓝房子的人相邻
15. 抽 Blends 香烟的人和喝矿泉水的人相邻

### 问题的数学模型

整个问题的描述分成两部分吗一部分是对问题基本结构的描述, 另一部分是对线索的描述. 基本数据结构只是定义了推理结果的框架, 则线索就可以理解为不同属性之间的绑定关系, 来填充基本结构. 故而建模分成两部分, 一部分是基本模型定义, 另一部分是线索模型定义.

#### 基本模型定义

总共有 5 种房子, 5 种国籍, 5 种饮料, 5 种宠物, 5 种香烟. 每种属性都可以用 "类型 + 值" 二元组 来描述. 比如说: "黄色房子"就是 "房子(类型)"+"黄色(值)". 数据结构定义为:

```js
function tagItem(type, value) {
    this.type = type;
    this.value = value;
}
```

其中`type`是个枚举类型, 只有 房子颜色, 国际, 饮料, 宠物, 香烟 5 个值. `value`的值取`0~4`对应不同的类型有不同的含义.

若任由这 25 个属性离散存在, 会给设计算法带来困难. 一般算法建模会用各种数据结构将这些属性组织起来. 这 25 个属性在两个维度上存在关系, 可以按照类型组织, 也可以按照同一推理之间的关系组织. 每一个人住在一个房子, 喝一种饮料, 养一只宠物, 抽一种香烟. 这些关系是固定的. 构成一个组:

```js
let tagItemType = {
    type_house: 0,
    type_nation: 1,
    type_drink: 2,
    type_pet: 3,
    type_cigaret: 4
};

function tagGroup(itemValue) {
    this.itemValue = itemValue;
}
```

#### 线索模型定义

这 15 条线索大致可以分成:

-   描述某些属性之间具有固定绑定关系的线索(1,2,3,5,6,7,12,13)
-   描述某些属性类型所在的组所具有的相邻关系的线索(10,11,14,15)
-   不能描述属性之间固定关系或者关系表若的线索.(4,8,9)

对于第一类线索, 定义如下:

```js
function tagBind(first_type, first_val, second_type, second_val) {
    this.first_type = first_type;
    this.first_val = first_val;
    this.second_type = second_type;
    this.second_val = second_val;
}

let binds = [
    new tagBind(type_house, COLOR_RED, type_nation, NATION_ENGLAND),
    new tagBind(type_nation, NATION_SWEDEND, type_pet, PET_DOG),
    new tagBind(type_nation, NATION_DANMARK, type_drink, DRINK_TEA),
    new tagBind(type_house, COLOR_GREEN, type_drink, DRINK_COFFEE),
    new tagBind(type_cigaret, CIGARET_PALLMALL, type_pet, PET_BIRD),
    new tagBind(type_house, COLOR_YELLOW, type_cigaret, CIGARET_DUNHILL),
    new tagBind(type_cigaret, CIGARET_BLUEMASTER, type_drink, DRINK_BEER),
    new tagBind(type_nation, NATION_GERMANY, type_cigaret, CIGARET_PRINCE)
];
```

对于第二类线索, 定义如下:

```js
function tagRelation(type, val, relation_type, relation_val) {
    this.type = type;
    this.val = val;
    this.relation_type = relation_type;
    this.relation_val = relation_val;
}

let relations = [
    new tagRelation(type_cigaret, CIGARET_BLENDS, type_pet, PET_CAT),
    new tagRelation(type_pet, PET_HORSE, type_cigaret, CIGARET_DUNHILL),
    new tagRelation(type_nation, NATION_NORWAY, type_house, COLOR_BLUE),
    new tagRelation(type_cigaret, CIGARET_BLENDS, type_drink, DRINK_WATER)
];
```

对于第三类线索, 无法建立统一的数学模型, 只能在枚举算法进行过程中直接使用它们过略屌一些不符合条件的组合结果.

### 算法设计

和其他穷举算法一样, 两步:

-   第一步, 穷举所有的结果.
-   第二步: 结果判断和剪枝.

前面几张也有介绍和使用穷举法, 但都是一维线性组合的枚举. 本题需要对不同类型的元素分别用穷举法进行枚举, 因此不是简单的线性组合. 这个算法采用的穷举方法是对不同类型的元素分别进行枚举, 然后再按照组的关系组合在一起, 这个组合不是线性关系的组合,而是类似阶乘的几何关系的组合. 具体思路就是按照 group 中的元素顺序, 首先对房子颜色组合进行穷举, 每得到一组房子颜色组合后, 就在此基础上对住在房子里的人的国籍进行穷举, 在房子颜色和国籍的组合基础上, 对饮料进行穷举, 以此类推.

算法实现如下:

```js
/* 遍历房子颜色*/
function EnumHouseColors(groups, groupIdx) {
    if (groupIdx == GROUPS_COUNT) {
        /*递归终止条件*/
        ArrangeHouseNations(groups);
        return;
    }

    for (let i = COLOR_BLUE; i <= COLOR_YELLOW; i++) {
        if (!IsGroupItemValueUsed(groups, groupIdx, type_house, i)) {
            groups[groupIdx].itemValue[type_house] = i;
            if (i == COLOR_GREEN) {
                //应用线索(4)：绿房子紧挨着白房子，在白房子的左边；
                groups[++groupIdx].itemValue[type_house] = COLOR_WHITE;
            }

            EnumHouseColors(groups, groupIdx + 1);
            if (i == COLOR_GREEN) {
                groupIdx--;
            }
        }
    }
}
```

这个线性枚举结束的时候继续调用`ArrangeHouseNations()`函数继续对房间内住的人的国际进行枚举.

对线索 9 的特殊处理在`ArrangeHouseNations()`函数中, 算法如下:

```js
function ArrangeHouseNations(groups) {
    /*应用规则(9)：挪威人住在第一个房子里面；*/
    groups[0].itemValue[type_nation] = NATION_NORWAY;
    EnumHouseNations(groups, 1); /*从第二个房子开始*/
}
```

#### 根据线索进行判断

根据前面的分析, 一共有三类线索, 其中第三类线索已经融入到枚举过程中了, 因此判断结果的正确性只需要使用第一类和第二类线索进行过滤即可.

## 第九章 项目管理与图的拓扑排序

无论是大项目还是小项目, 最终都可以通过工作分解结构(WBS)的方式分解成一系列的任务, 然后再细分为具体的活动. 每个活动对应一个工作, 当这些活动都结束的时候, 项目也就完成了. 项目中的这些活动都不是鼓励的, 它们之间存在前后依赖的关系. 有的活动没有先决条件, 可以安排在任意时间开始, 有的活动则依赖其他活动, 需要在其依赖的活动都完成后才能开始. 面对一堆关系错综复杂的活动, 如何安排和组织这些活动, 就是项目管理所做的事情.

举个栗子: 某工程分解后得到 P1~P9 九个活动, 这些活动之间依赖关系如下图所示:

![an image](/img/funofAL/360截图17321128418342.png)

将以上活动按照开始时间进行排序, 就能得到各个活动开始的一次顺序: P1,P2,P5,P3,P7,P8,P4,P6,P9. 关键路径是: P1->P3->P4->P6.

对于整个工程项目, 人们最担心的是两个问题: 一个是工程是否能够春丽进行. 另一个是估算整个工程能够顺利进行. 同样, 只要找到了活动序列中的关键路径, 就可以估算出工程完工的最短时间. 这背后的算法就是图论中的有向图的拓扑排序和关键路径查找, 下面来看看这些有趣的算法.

### AOV 网和 AOE 网

在图论中, 如果某个有向图无法从某个顶点出发经过若干条边回到该点, 则称这个图为 **有向无环图(Directed Acyclic Craph, DAG)**. 有向无环图是描述工程或项目进行过程的有效工具, 项目分解后所得到的具体活动之间的关系, 可以用有向无环图表示, 很显然, 这些活动如果存在构成换的顺序依赖关系, 会造成环中的活动都无法进行.

图的主要元素是顶点和边, 用有向无环图表示 工程活动之间的关系时, 根据顶点和边所代表的意义不同, 通常有两种常用的表示方式, 分别是 AOV 网和 AOE 网. 如果途中的顶点代表的是活动, 有向边代表的是与此边相连的两个活动的前后关系, 则这样的有向无环图被称为 **顶点表示活动网(Activity On Vertex network)**, 简称 AOV 网, AOV 网常用通过拓扑排序决定活动开始关系. 下图就是上面的例子中用 AOV 网表示的有向无环图:

![an image](/img/funofAL/360截图17001016265925.png)

如果图中边代表的是活动, 边的权表示完成活动所需要的事件, 与边相连的两个顶点分别表示活动的开始事件和结束事件, 则这样的有向无环图就被称为 **边表示活动图(Activity On Edge network)**, 简称 AOE 网. AOE 网是一种带权的有向无环图, AOE 网常用于估算工程完工时间, 下图就是上面的例子的 AOE 网:

![an image](/img/funofAL/360截图17140309162235.png)

### 拓扑排序

在图论中, 一个有向无环图的所有顶点可以排成一个线性序列, 当这个线性序列满足以下条件时, 称该序为一个满足图的 **拓扑次序(topological order)** 的序列:

-   图中的每个顶点在序列中只出现一次
-   对于图中任意一条 有向边(u,v), 在该序列中顶点 u 一定位于顶点 v 之前.

这样的序列也被称为 _拓扑排序_, 对有向图的所有顶点排序, 获得拓扑排序的过程就是有向图的拓扑排序. 拓扑排序并不仅仅用于有向图, 它是一种利用数据元素中某个属性的偏序关系得到数据元素的全排序序列方法. 本章中我们只关注有向图的拓扑排序方法.

### 拓扑排序的基本过程

对有向图进行拓展排序可以得到顶点的拓扑序列, 拓扑排序的基本过程如下:

1. 从有向图选择中选择一个没有前驱(入度为 0)的顶点, 输出这个顶点
2. 从有向图中删除该顶点, 同时删除有顶点发出的所有有向边

重复 1 和 2, 直到图中不再有入度为 0 的顶点为止. 此时, 如果所有的顶点都已经输出, 则顺序输出的顶点序列就是一个拓扑序列. 如果图中还有为输出的顶点, 但是入度都不为 0, 则说明有向图中存在环路, 不能进行拓扑排序.

拓扑排序的现实意义在于, 如果按照拓扑序列中的顶点次序安排活动, 则在每一项活动开始的时候, 能够保证它所以来的前驱活动都已经完成, 从而使得整个工程可以顺利进行, 不出现冲突, 需要注意的是, 对于一个有向无环图来说, 有时候不止一个有序的拓扑序列.

#### 按照活动开始时间排序

工程实施过程中, 我们总是希望每个活动尽早开始. 对一个工程的所有活动进行拓扑排序时, 如果能将活动的最早开始时间考虑进来, 让拓扑序列中的每个活动都尽早开始, 这样的排序序列对工程实施具有非常大的实用性.

这一节中我们仿照 Project 软件实现一个按照开始时间对活动进行拓扑排序的算法. 当然, 这背后其实就是拓扑排序.

在一个工程中, 每个活动的开始时间受前置活动的约束, 不可能随时开始, 但是活动的开始时间可以根据前置活动之间的关系推算出来, 具体的推算方法如下:

-   如果一个活动没有前驱活动, 则这个活动的开始时间是 0;
-   如果一个活动有前驱活动, 则这个活动的开始时间是前驱活动的开始时间和前驱活动持续时间的和, 如果一个活动有多个前驱活动, 则这个活动的开始时间是这些和中最大的一个.

对于 AOV 网, 用领接表方式定义有向图的数据是最常用的方式. 对于上面的例子, 领接表方式定义的数据结构应该如图所示:

![](/img/funofAL/360截图173211219910579.png)

首先定义图的顶点, 其数据结构描述如下所示:

```js
//定义图的顶点
function tagVertexNode(name, days, sTime, inCount, adjacent, adjacentNode) {
    this.name = name; //活动名称
    this.days = days; //完成活动所需要的时间
    this.sTime = sTime; //活动最早开始时间
    this.inCount = inCount; //活动的前驱节点个数
    this.adjacent = adjacent; //相邻活动的个数
    this.adjacentNode = adjacentNode; //相邻活动列表(节点索引)
}
```

对于`adjacentNode`属性, 这个列表中存储的是邻接顶点在图中的节点索引, 如果图采用数据方式组织所有顶点, 则这个表中存储的就是邻接顶点在数组中的位置.图的定义如下:

```js
//图的定义
function tagGraph(count, vertexs) {
    this.count = count; //图的顶点个数
    this.vertexs = vertexs; //图的顶点列表
}
```

根据上文中介绍的基本拓扑排序过程, 有两个细节需要算法特殊处理, 第一是同一时刻有多个入度为 0 的顶点的情况如何处理, 其二是删除一个顶点发出的所有有向边对新产生的入度为 0 的顶点如何处理. 基本排序过程对这些情况不做任何特殊处理, 也就是说对于同时出现入度为 0 的顶点, 以任何持续输出都是合法的. 但是如果开始考虑时间属性, 就需要对这些入度为 0 的顶点按照开始时间排序, 才能保证最后输出是按照开始时间拓扑排序的结果.

按照基本拓扑排序要求, 同时出现的入度为 0 的顶点要按照"先进先出"的原则进行处理, 同时, 还要能够根据开始时间排序. 使用"优先级队列"管理算法处理过程中同时出的入度为 0 的顶点就是一个最好的选择. 这些顶点首先按照出现的先后次序入列, 同时根据开始时间调整在队列中的位置, 保证开始时间较小的顶点能先于开始是阿金较大的顶点输出.

正如`TopologicalSorting()`函数代码所展示的那样, 整个排序宣发的核心就是对这个"优先级队列"的处理.

1. 遍历有向图的所有顶点, 将所有入度为 0(inCOunt 为 0)的顶点入队. (队列中: P1,P2);
2. 围绕这个优先级队列进行处理, 首先出队 P1, 同时删除 P1 发出的两条有向边, 删除有向边的操作是通过减少与之相邻的顶点的 inCount 值来实现的, 删除 P1 的有向边会导致 P7 顶点的入度为 0, 因此 P7 加入队列, 因为 P7 开始时间是 8, 因此 P7 排在 P2 之后, 队列中剩下(P2,P7).
3. 第二轮队列处理, P2 出队, 删除 P2 两条有向边, 回导致 P3 和 P5 两个顶点的入度为 0, P3 和 P5 分别入队, P5 的开始时间是 5 ,小于 P3 和 P7 的 8, P5 排在队列的最前面, 此时队列中为(P5,P3,P7)
4. 重复以上过程, 直到队列为空时算法结束, 此时判断输出的排序列表 sortedNode, 如果 sortedNode 中的节点个数与图的顶点个数相同, 则说明所有顶点都已经输出, 拓扑排序完成, 否则就说明图中存在环路, 无法进行拓扑排序. 代码实现如下:

```js
//拓扑排序算法主题
function TopologicalSorting(g, sortedNode) {
    let nodeQueue = [];
    for (let i = 0; i < g.count; i++) {
        if (g.vertexs[i].inCount == 0) {
            EnQueue(nodeQueue, i, g.vertexs[i].sTime);
        }
    }
    while (nodeQueue.length != 0) {
        let node = DeQueue(nodeQueue); //按照开始时间优先级出队
        sortedNode.push(node); //输出当前节点
        //遍历节点node的所有邻接点, 将表示有向边的inCount值减1
        for (let j = 0; j < g.vertexs[node].adjacent; j++) {
            const adjNode = g.vertexs[node].adjacentNode[j];
            g.vertexsp[adjNode].inCount--;
            //如果inCount值为0, 则该节点入队列
            if (g.vertexs[adjNode].inCount == 0) {
                EnQueue(nodeQueue, adjNode, g.vertexs[adjNode], sTime);
            }
        }
    }
    return sortedNode.length == g.count;
}
```

### 关键路径算法

前面提到的, 对于工程管理, 人们最关注的两个问题分别是工程能否顺利进行, 以及估算整个工程所需要的最短时间和影响工程时间的关键活动. 前一个问题可用拓扑排序解决, 后一个问题则需要找出的关键路径, 关键路径上的活动完成所需要的时间就是工程完成所需要的最短时间. 关键路径通常是所有工程活动中最长的路径, 关键路径上的活动如果延期将直接导致工程延期.

利用 AOV 网表示有向图, 可以对活动进行拓扑排序, 根据排序结果对工程中活动的先后顺序做出安排. 但是寻找关键路径, 估算工程活动的结束时间, 则需要使用 AOE 网表示有向图. AOE 网中用顶点表示时间, 有向边表示活动, 边上的权值表示活动持续的事件. 只有在某顶点所代表的事件发生后, 从该顶点出发的各有向边所代表的活动才能开始, 反之亦然, 只有在指向某一顶点的各有向边所代表的活动都已经结束后, 该顶点所代表的事件才能发生. AOE 网只有一个入度为 0 的顶点(源点)和一个出度为 0 的顶点(汇点), 分别代表开始时间和结束事件, 其他的顶点则表示两个意义, 其一是此点之前的所有活动都已经结束, 其二是此点之后的活动可以开始了.

计算关键路径的算法需要根据 AOE 网的特征调整图的数据结构定义, 本节介绍的算法仍然使用邻接表来表示图, 但是需要重新定义顶点和边的数据结构. 因为 AOE 网的边代表具体的活动, 需要在数据结构中明确体现"边"的定义, 调整后的边和顶点的定义如下:

```js
function EDGE_NODE(vertexIndex, name, duty) {
    this.vertexIndex = vertexIndex; //活动边终点顶点索引
    this.name = name; //活动边的名称
    this.duty = duty; //活动边的时间(权重)
}

function VERTEX_NODE(sTime, eTime, inCount, edgs) {
    this.sTime = sTime; //事件最早开始时间
    this.eTime = eTime; //事件最晚开始时间
    this.inCount = inCount; //活动的前驱节点个数
    this.edgs = edgs; //相邻边表
}
```

算法开始之前, 要对每个顶点进行初始化:

```js
function InitGraph(g, vertex) {
    g.count = vertex;
    for (let i = 0; i < vertex; i++) {
        g.vertex[i].sTime = 0;
        g.vertex[i].eTime = 0x7fffffff;
        g.vertex[i].inCount = 0;
    }
}
```

#### 什么是关键路径

开始讨论关键路径之前, 先来介绍一下活动的最早开始时间和最晚是开时间. 工程中一个活动何时开始依赖于其前驱活动何时结束, 只是所有的前驱活动都结束后这个活动才可以开始, 前驱活动都结束的事件就是这个活动的最早开始时间, 于此同时, 在不影响工程完工时间的前提下, 有些活动的开始时间存在一些余量, 在时间余量允许的范围之内推迟一段时间活动也不会影响工程的最终完成时间, 活动的最早开始时间加上这个时间余量就是活动的最晚开始时间. 活动不能再最早开始时间之前开始, 当然, 也不能在最晚时间开始之后开始, 否则会导致工期延误.

如果一个活动的事件余量为 0, 即该活动的最早开始时间和最晚开始时间相同, 则这个活动就是关键活动, 由这些关键活动串起来的一个工程活动路径就是关键路径. 根据关键路径的定义, 一个工程中的关键路径可能不止一个, 我们常说的关键路径指的是工程时间最长的那条路径, 也就是从源点到汇点之间最长的那条活动路径.

#### 计算关键路径

计算关键路径的基础是先找出工程中的所有关键活动, 确定一个活动是否是关键活动的一句就是活动的最早开始时间的最晚开始时间, 因此需要先介绍如何计算活动是否是关键活动的依据就是活动的最早开始时间和最晚开始时间, 因此需要先介绍如何计算活动的最早开始时间和最晚开始时间.

在 AOE 网中, 事件 ei 必须在指向 ei 的所有活动都结束后才能发生, ei 发生以后, 从 ei 发出的才能开始, 因此 ei 的最早发生时间就是 ei 发出的所有活动的最早开始时间. 如果`est[i]`表示事件 ei 的最早开始时间, 用`duty[i,j]`表示连接事件 ei 和事件 ej 的活动需要持续的时间, 则事件 ej 的最早开始时间可以用以下关系推算:

1. est[0]=0;
2. est[n]=max{est[i]+duty[i,n],est[j]+duty[j,n],...,est[k]+duty[k,n]}
   (其中 I,j,...,k 是事件 n 的前驱事件)

根据以上推算关系, 可以将图中 e0~e3 几个事件的最早开始时间推算出来:

```
est[0]=0;
est[1]=est[0]+duty[0,1]=0+8=8;
est[2]=est[0]+duty[0,2]=0+5=5;
est[3]=max{est[1]+duty[1,3],est[2]+duty[2,3]}=max{8+0,5+0}=8;
```

很显然, 这个推算关系是建立在合法的拓扑序列的基础上的, 因此, 推算事件的最早开始时间需要对图中的事件节点进行拓扑排序. 拓扑排序的算法已经介绍过了, 现在我们只关注最早开始时间的计算方法. 假设 sortedNode 参数中存放的图的拓扑排序结果. CalcESTime()函数从拓扑序列的第一个顶点开始(变量 u 代表的顶点), 遍历这个顶点发出的有向边指向的相邻顶点(变量 v 代表的顶点), 如果该顶点的最早开始时间与有向边代表的活动持续时间的和(这个结果存放在临时变量 uvst 中)大于有向边指向的相邻顶点的最早开始时间, 则更新这个相邻顶点的最早开始时间. 需要注意的是, 算法并没有直接利用推算关系中的 max 选择处理, 而是按照 sortedNode 序列中的顶点先后关系, 只在处理到相邻顶点是才更新最早开始时间, 当 sortedNode 序列中的所有顶点都处理完之后, 就相当于变相的实现了 max 选择的处理:

```js
function CalcESTime(g, sortedNode) {
    g.vertexs[0].sTime = 0; //est[0]=0

    for (let i = 0; i < sortedNode.length; i++) {
        let u = sortedNode[i];
        let eit = g.vertexs[u].edges;
        //遍历u发出的所有有向边
        for (let j = 0; j < eit.length; j++) {
            let v = eit[j].vertexIndex;
            let uvst = g.vertexs[i].sTime + eit[j].duty;
            if (uvst > g.vertexs[v].sTime) {
                g.vertexs[v].sTime = uvst;
            }
        }
    }
}
```

事件 ei 的最晚开始时间定义为：ei 的后继时间 ej 的最晚开始时间减去 ei 和 ej 之间的活动的持续时间的差，当 ei 有多个后继事件时，则取这些差值中最小的一个作为 ei 的最晚开始时间，如果用 lst[j]表示事件 ej 的最晚开始时间，用 duty[i,j]表示事件 ei 和后继事件 ej 之间的活动需要持续的时间，则事件 ei 的最晚开始事件可以用以下关系推算：

1. lst[n]=est[n]
2. est[i]=min{lst[j]-duty[i,j],est[k]-duty[i,k],...,est[m]-duty[i,m]}

推算一下 e5,e7,e8 和 e9:

```
lst[9]=est[9]=25
lst[5]=lst[9]-duty[5,9]=25-7=18
lst[7]=lst[9]-duty[5,9]=25-4=21
lst[8]=min{lst[7]-duty[8,7],lst[5]-duty[8,5]}=min{21,18}=18
```

这个最晚开始时间的推算关系是建立在合法的拓扑排序的逆序基础上的, CalcLsTime()函数对 sortedNode 序列的处理顺序和 CalcEsTime()函数刚好相反, 从拓扑序列的最后一个顶点(变量 u 代表的顶点)开始向前遍历吗如果该顶点的后继顶点(变量 v 代表的顶点)的最晚开始时间与连接这两个顶点的活动的持续时间的差小于该顶点(u 顶点)的最晚开始时间, 则更新该顶点的最晚开始时间. 和 CalcESTime()函数一样,CalcLSTime 函数也没有直接利用 min 选择处理, 但是通过逆序遍历 sortedNode 序列中的所有顶点, 变相的实现了 min 选择的处理.

```js
function CalcLSTime(g, sortedNode) {
    //最后一个节点的最晚开始时间等于最早开始时间
    g.vertexs[g.count - 1].eTime = g.vertexs[g.count - 1].sTime;
    for (let i = sortedNode.length - 1; i >= 0; i--) {
        let u = sortedNode[i];
        let eit = g.vertexs[i].edges;
        for (let j = 0; j < eit.length; j++) {
            let v = eit[j].vertexIndex;
            let uvet = g.vertexs[v].eTime - eit[j].duty;
            if (uvet < g.vertexs[u].eTime) {
                g.vertexs[u].eTime = uvet;
            }
        }
    }
}
```

在 AOE 网中计算好每个顶点代表的事件的最早开始时间和最晚开始时间之后, 就可以很容易计算出每条边代表的活动的最早开始时间和最晚开始时间. 加入某个活动两端的事件分别是 ei 和 ej, 则该活动的最早开始时间就是事件 ei 的最早开始时间, 该活动的最晚开始时间就是时间 ej 的最晚开始时间减去该活动的持续时间. 用这个关系计算出所有活动的最早开始时间和最晚开始时间, 只要最早开始时间和最晚开始时间相同的活动都是关键活动, 按照事件顶点的拓扑序列的先后关系, 顺序输出这些事件顶点相关的关键活动, 得到的关键活动序列就是关键路径.

步骤如下:

1. 对事件顶点进行拓扑排序, 得到事件的拓扑序列
2. 计算事件顶点的最早开始时间
3. 计算事件顶点的最晚开始时间
4. 计算活动的最早开始时间和最晚开始时间, 并按照事件的拓扑顺序逐次输出关键活动, 得到关键路径.

```js
function CriticalPath(g) {
    let sortedNode = [];
    if (!TopologicalSorting(g, sortedNode)) {
        //步骤1
        return false;
    }
    CalcESTime(g, sortedNode); //步骤2
    CalcLSTime(g, sortedNode); //步骤3
    console.log(g);
    //步骤4： 输出关键路径上的活动名称
    for (let i = 0; i < sortedNode.length; i++) {
        const u = sortedNode[i];
        let eit = g.vertexs[u].edges;
        for (let j = 0; j < eit.length; j++) {
            const v = eit[j].vertexIndex;
            //是否是关键活动？
            // console.log(g.vertexs[u].sTime,g.vertexs[v].eTime - eit[j].duty);
            if (g.vertexs[u].sTime == g.vertexs[v].eTime - eit[j].duty) {
                if (eit[j].name) {
                    //过滤连接事件顶点的虚拟活动边
                    console.log(eit[j].name);
                }
            }
        }
    }
    return true;
}
```

输出路径为 P1,P3,P4,P6;

## 第十章 RLE 压缩算法和 PCX 图像文件格式

RLE(Run Length Encoding) 压缩算法即行程长度压缩算法, 也称游程长度压缩算法, 是最早出现, 也是最简单的无损数据压缩算法. RLE 压缩算法对于黑白图像和基于调色板的单调图像有很高的压缩效率, 不仅常用于处理图像数据, 在传真机上也得到了广泛的应用.

### RLE 压缩算法

RLE 压缩算法的基本思路是把数据按照线性序列分成两种情况,

-   一种是连续的重复数据块, 另一种是连续的不重复数据块. RLE 算法的原理就是用一个表示块数的属性加上一个数据块代表原来连续的若干块数据, 从而达到节省存储空间的目的. 一般 RLE 算法都选择数据块的长度为 1 字节, 表示块数的属性也用 1 字节表示, 对于颜色数小于 256 色的图像文本或文本文件, 块长度选择 1 字节是比较合适的.

#### 连续重复数据的处理

RLE 算法有很多优化和改进的变种算法, 这些算法与连续重复数据的处理方式基本上都是一样的. 对于连续重复出现的数据, RLE 算法一般用两字节表示原来连续的多字节重复数据. 我们用一个例子更直观的说明 RLE 算法对这种情况.

假如原始数据有 5 字节的连续数据:

```
[data][data][data][data][data]
```

则压缩后的数据就包含块数和[data]两字节, 其中[data]只存储了一次, 节省了空间:

```
[5][data]
```

需要注意的是, 一般 RLE 算法都采用插入一个长度属性字节存储连续数据的重复次数, 因此能够表达的最大值就是 255 字节, 如果连续的相同数据超过 255 字节时, 就从第 255 字节处断开, 将第 256 字节以及 256 字节后面的数据当成新的数据处理. 随着 RLE 算法采用的优化方式不同, 这个长度属性字节所表达的意义也不同, 对于本章给出的这种优化算法, 长度属性字节的最高位被用来做一个标示位, 只有 7 位用来表示长度, 这一点在下一节会具体说明.

#### 连续的非重复数据的处理

对于连续的非重复数据, RLE 算法有两种处理方法, 一种处理方法是将每个不重复的数据当做只重复一次的连续重复数据处理, 在算法实现上就和处理连续重复数据一样, 另一种处理方法时不对数据进行任何处理, 直接将原始数据作为压缩后的数据存储. 假如有以下 5 字节的连续非重复数据:

```
[data1][data2][data3][data4][data5]
```

第一种处理方式如下:

```
[1][data1][1][data2][1][data3][1][data4][1][data5]
```

第二种处理方式则与原始数据一致.

第一种处理方式不仅不能达到压缩数据的目的, 还会引起数据膨胀. 如果使用第二种方式处理连续非重复数据, 就引入的一个新的问题: 在 RLE 数据解码的时候, 如何区分连续重复和非重复数据.

前面已经提到, 如果把非重复数据当作独立的单次重复数据处理, 反而会造成数据膨胀, 但是如果把连续非重复数据也当成一组数据整理考虑呢? 首先, 给连续重复数据和连续非重复数据都附加一个表示长度的属性字节, 并利用这个长度属性字节的最高位来区分两种情况. 长度属性字节的最高位如果是 1, 则表示后面紧跟的是个重复数据, 需要重复的次数由长度属性字节的低 7 位(最大值是 127)表示. 长度属性字节的最高位如果是 0, 则表示后面紧跟的是非重复数据, 长度也由长度属性字节的低 7 位表示.

采用这种优化方式, 压缩后的数据非常有规律, 两种类型的数据都从长度属性字节开始, 除了标志位的不同, 后跟的数据也不同. 第一种情况后跟一个字节的重复数据, 第二种情况后跟的是若干个字节的连续非重复数据.

#### 算法实现

采用上一节中给出的优化方法, 编码算法不仅要能够识别连续重复数据和连续非重复数据两种情况, 还有能够统计出两种情况下数据块的长度. 编码算法从原始数据的起始位置开始向后搜索, 如果发现后面是重复数据且重复次数超过 2, 则设置连续重复数据的标志并继续向后查找, 知道找到第一个与之不同的数据位置, 将这个数据纪委下次搜索的起始位置, 根据位置差计算重复次数, 最后长度属性字节以及一个字节的原始重复数据一起写入压缩数据, 如果后面数据不是连续重复数据, 则继续向后搜索查找连续重复数据, 知道发现连续重复的数据且重复次数大于 2 为止, 然后设置不重复数据标记, 将新位置记为下次搜索的起始为止.

```js
/**
 *
 * @param {Array} inbuf 输入待编码字符串
 * @param {Number} inSize 字符串长度
 * @param {Array} outbuf 输出编码后字符串
 * @param {Number} onuBufSize 缓冲区长度
 */
function Rle_Encode(inbuf, inSize, outbuf, onuBufSize) {
    let src = inbuf;
    let encSize = 0;
    let srcLeft = inSize;
    let index = 0;
    while (srcLeft > 0) {
        let count = 0;
        //是否连续三个字节数据相同
        if (IsRepetitionStart(src.slice(index), srcLeft)) {
            if (encSize + 2 > onuBufSize) {
                console.log('输出缓冲区空间不足');
                return -1;
            }
            count = GetRepetitionCount(src.slice(index), srcLeft);
            outbuf[encSize++] = count | 0x80;
            outbuf[encSize++] = src[index];
            index += count;
            srcLeft -= count;
        } else {
            count = GetNonRepetitionCount(src.slice(index), srcLeft);
            if (encSize + count + 1 > onuBufSize) {
                console.log('输出缓冲区空间不足');
                return -1;
            }
            outbuf[encSize++] = count;
            //逐个复制这些数据
            for (let i = 0; i < count; i++) {
                outbuf[encSize++] = src[index++];
            }
            srcLeft -= count;
        }
    }
    return encSize;
}
```

上面这个函数是 RLE 算法的实现, 它通过调用`IsRepetitionStart()`函数判断从 src 开始的数据是否是连续重复数据. 如果是连续重复数据, 则调用`GetRepetitionCount`杉树计算出连续重复数据的长度, 将长度属性字节的最高位置 1 并向缓冲区写入一个字节的重复数据. 如果不是连续重复数据, 则调用`GetMonRepetitionCount()`函数计算连续非重复数据的长度, 将长度属性字节的最高位置 0 并向输出缓冲区复制连续的多个非重复数据. 根据算法的要求, 只有数据重复出现两次以上才算作连续重复数据, 因此`IsRepetitionStart()`函数检查连续的 3 字节是否是相同的数据, 如果是则判定为出现连续重复数据.

解压缩算法相较简单, 因为两种情况下的压缩数据首部都是 1 字节长度属性标识, 只要根据这个标识判断如何处理就可以了. 首先从压缩数据中提取出 1 字节的长度属性标识, 然后判断是连续重复数据的标识还是连续非重复数据的标识, 如果是连续重复数据, 则将标识字节后面的数据重复赋值 n 份写入输出缓冲区;如果是连续非重复数据, 则将标识字节后面的 n 个数据赋值输出缓冲区. n 的值是标识字节与 0x3F 做与操作后得到的, 因为标识字节低 7 位就是数据长度属性:

```js
function Rle_Decode(inbuf, inSize, outbuf, onuBufSize) {
    let src = inbuf;
    let decSize = 0;
    let count = 0;
    let index = 0;
    while (index < src.length + inSize) {
        let sign = src[index++];
        let count = sign & 0x3f;
        if (decSize + count > onuBufSize) {
            console.log('输出缓冲区空间不足');
            return -1;
        }
        //连续重复数据标志
        if (sign & (0x80 == 0x80)) {
            for (let i = 0; i < count; i++) {
                outbuf[decSize++] = src[index];
            }
            index++;
        } else {
            for (let i = 0; i < count; i++) {
                outbuf[decSize++] = src[index++];
            }
        }
    }
    return decSize;
}
```

### RLE 与 PCX 图像文件格式

PCX 图像文件格式是 Zspft 公司在 20 世纪 80 年代初设计的一种图像文件格式, 专用于存储该公司开发的 PC Paintbrush 绘图软件所生成的图像画面数据. 在计算机普遍只能处理单色图像的年代, PCX 图像文件格式就超前的引入了彩色图像概念. PCX 支持单色图像文件以及 16 色/256 色的彩色图像文件. PCX 文件采用 RLE 孙发, 对绘图类型的图像具有比较高的压缩效率, 但是对于照片和视屏图像效果不佳.

其中 256 色的图像格式非常简单, 我们在其中介绍一些 RLE 算法的应用.

#### PCX 图像文件格式

PCX 文件最初被设计为一种与特定图形显示硬件密切相关的图像处理格式. 比如少于 16 中颜色的 PCX 文件的数据被分成 4 个颜色层存放.

![](/img/funofAL/360截图17911011101538.png)

PCX 文件结构分成三个域, 分别是文件头, 图像数据和最后附加的 256 色调色板数据. 文件头是一个大小和格式化都固定的表头, 长度是 128 字节, 主要存放定义图像的尺寸, 彩色调色板和其他有关的图像数据.

-   manufacture: 固定的 0x0a, 这是识别 PCX 文件的唯一标志.
-   version: 说明 PCX 文件的版本,5 对应的版本开始支持 256 色图像.
-   encoding: 表示图像数据压缩编码方式, 1 表示采用 RLE 压缩编码方法.
-   bits_per_pixel: 说明每个像素的位数, 对于 256 色 PCX 图像, 要么不用, 要么为 8.
-   xmin,ymin,xmax,ymax: 定义文件的图像尺寸, xmax-xmin 为图像的实际宽度, ymax-ymin 是图像的实际高度. 单位为像素. 大多数情况下, xmin 和 ymin 为 0;
-   hres,vres: 分别是图像的水平和垂直分辨率.
-   palette: 是长度为 48 字节的才色调色板. 只用于 16 色以下图像使用.
-   byte_per_line: 代表图像解码后每一行图像数据所需要的字节数, 图像解码软件可直接只用这个值分配解码缓冲区, 省去重新计算的麻烦.

PCX 文件的第二部分采用 PCX_RLE 算法压缩的图像数据, 这也是 RLE 算法的一个变种.

### PCX_RLE 算法

对 RLE 算法的优化主要集中在对连续非重复数据的处理方式上, 各种优化方法的差别则体现在图和区分连续重复数据和连续重复数据上, 各种优化方法的差别则体现在图和区分连续数据和连续非重复数据上. PCX_RLE 算法根据长度属性字节的最高位和次高位来标识这个标识, 对于连续非重复数据则不使用任何标识字节. 也就是说, 如果一个数据的最高两个比特都是 1, 则表示这个字节本身就是非重复数据. 但是如果非重复数据本身最高位是两个 1, 那怎么做呢. PCX_RLE 的方法时将这样的数据当做长度为 1 的连续重复数据处理, 也就是在数据前插入一个 0xC1 标识.

```js
function PcxRle_Encode(inbuf, inSize, outbuf, onuBufSize) {
    let src = inbuf;
    let i;
    let encSize = 0;

    let index = 0;

    while (index < inbuf.length + inSize) {
        let value = src[index++];
        i = 1;
        while (src[index] == value && i < 63) {
            index++;
            i++;
        }

        if (encSize + i + 1 > onuBufSize) {
            console.log('输出缓冲区空间不足');
            return -1;
        }
        if (i > 1) {
            outbuf[encSize++] = i | 0xc0;
            ouitbuf[encSize++] = value;
        } else {
            // 如果非重复数据最高两位是1， 插入标识字节
            if (value & (0xc0 == 0xc0)) {
                outbuf[encSize++] = 0xc1;
            }
            outbuf[encSize++] = value;
        }
    }
    return encSize;
}
```

对于颜色比较简单的绘图文件, 颜色数一般不多, 加上对调色板的优化, 可以使大部分数据避开最高两个比特是 1 的情况, 应用这个算法的 PCX 文件还具有很好的压缩效果.

#### 256 色 PCX 文件的解码和显示

256 色 PCX 文件的图像数据并不是对应点的颜色, 而是对应点的颜色在调色板中的索引. 需要根据这个索引从调色板中查找到真正的颜色才能显示图像. 由于不需要处理与显示设备相关的颜色位平面问题, 256 色 PCX 文件的解码和显示算法非常简单. 首先从文件开始位置读取 128 字节的文件头结构, 判断时候是 256 色 PCX 文件, 然后从文件尾部向前便宜 769 字节, 读取颜色数和调色板数据, 最后定位到图像数据部分,逐行解码并显示图像数据. 解码算法如下:

```js
function PcxRle_Decode(inbuf, inSize, outbuf, onuBufSize) {
    let src = inbuf;
    let decSize = 0;
    let count = 0;
    let index = 0;
    while (index < inbuf.length + inSize) {
        let value = src[index++];
        count = 1;
        if ((value & 0xc0) == 0xc0) {
            count = value & 0x3f; //低6位是count
            value = src[index++];
        } else {
            count = 1;
        }
        if (decSize + count > onuBufSize) {
            console.log('输出缓冲区空间不够了');
            return -1;
        }
        for (let i = 0; i < count; i++) {
            outbuf[decSize++] = value;
        }
    }
    return decSize;
}
```

## 第十一章 算法与历法

### 格里历(公历)生成算法

格里历历法规则很简单, 它首先将年份分成平常年(平年, Common Year)和闰年(Leap Year)两种. 格里历一年分为十二个月, 1,3,5,7,8,10,12 是大月, 每月 31 天, 4,6,9,11 是小月, 每月 30 天, 2 月天数在闰年是 29 天, 平年是 28 天. 平年一年 365 天, 闰年 366 天.

-   当年数为 4 的倍数且不为 100 的倍数, 则为闰年
-   当年数为 400 的倍数也为闰年.
-   否则为平年

计算星期几的关键是求出两个日期之间相隔的天数. 有两种常用的方法计算两个日期之间相隔的天数. 一种是利用公历的月和年的规则直接计算, 另一种是利用儒略日计算. 除此之外, 还可以利用 Zeller 公式计算某一天是星期几,下面分别介绍一下这三种常用方法:

1. 直接根据日期的差值

利用公历规则直接计算两个日期之间相差的天数, 最简单的方法就是将两个日期之间相隔的天数分成三部分: 前一个日期所在年份还剩下的天数, 两个日期之间相隔的整年数所包含的天数以及后一个日期所在的年过去的天数. 分别计算这三个部分的天数然后求个得到两个日期最红相差的天数.

2. 利用儒略日计算日期的差值

另一种计算两个日期相差天数的方法时利用儒略日(Julian Day)进行计算. 首先介绍一下儒略日, 儒略日是一种不计年, 不计月, 只记日的立法, 是由法国学者 Joseph Justus Scaliger(1540-1609)提出的一种以天数为计量单位的流水日历. 儒略日和儒略历没有任何关系. 简单来讲, 儒略日就是指从公元前 4713 年 1 月 1 日 UTC12:00 开始所经过的天数, JD0 就被指定为公元前 4713 年 1 月 1 日 12:00 到公元前 4713 年 1 月 2 日 12:00 之间的 24 个小时. 依次春推, 每一天都被赋予一个唯一的数字. 例如从 1996 年 1 月 1 日 12:00 开始的一天就是 JD2450084. 使用儒略日可以把不同立法的年表统一起来, 很方便在各种立法中追溯日期. 儒略日并不只关注天数, 它是一个浮点数, 可以精确到秒, 一秒钟对应的儒略日差值是 0.0000115740 个儒略日. 另外这里我们要注意: 它是从中午 12:00 开始的 24 个小时, 因此在计算日期时如果需要考虑 0 点, 需要增加或减少 0.5 个儒略日进行修正.

计算两个日期之间的天数, 利用儒略日计算也很方便, 先计算出两个日期的儒略日数, 然后直接相减就可以得到两个日期相隔的天数. 有格里历的日期计算出儒略日数是一个很简单的事情, 有多个公式可以计算, 下面是其中一种：

![](/img/funofAL/360截图18430705879599.png)

式 1 适用于格里历, 式 2 适用于正式启用格里历之前所使用的儒略历. 式子中的 y 和 m 可以使用以下公式计算:

![](/img/funofAL/360截图18430707706585.png)

这个公式计算出的结果是某日正午 12:00 对应的儒略日, 如果之求解整数精度的儒略日, 直接使用这个公式即可. 如果要求解精确到时分秒, 则需要参照下面的代码:

```js
//计算儒略日公式--来自维基百科
function CalculateJulianDay(year, month, day, hour, minute, second) {
    let a = (14 - month) / 12;
    let y = year + 4800 - a;
    let m = month + 12 * a - 3;
    let jdn = day + (153 * m + 2) / 5 + 365 * y + y / 4;
    if (IsGregorianDays(year, month, day)) {
        jdn = jdn - y / 100 + y / 400 - 32045.5;
    } else {
        jdn -= 32083.5;
    }

    return jdn + hour / 24.0 + minute / 1440.0 + second / 86400.0;
}
```

3. 利用蔡勒公式计算星期数

上述计算星期的方法虽然步骤简单, 但是每次都要计算两个日期的时间差, 不是非常方便, 如果能够有一个公式可以直接根据日期计算出对应的星期岂不美哉. 此类公式的推到原理仍然是通过两个日期的事件差来计算星期, 只是通过选择一个特殊的日期来简化公式的推到. 这个日期指的是某年的 12 月 31 号这天刚好是星期日的这种情况, 选择这样的日子有两个好处, 一是计算上省去计算标准日这一年的剩余天数, 二是计算出来的日期差余数是几就是星期几, 不需要再计算星期的差值. 现在我们来推导这样一个公式.

我们知道公元元年的 1 月 1 日是星期一, 那么公元前 1 年的 12 月 31 日就是星期日, 用这一天作为标准日期, 就可以只计算整数年的事件和日期所在的年积累的天数. 公式如下:

$$
w=(L\times366+N\times365+D)\%7
$$

公式中的 L 是从公元元年到 year 年 month 月 day 日所在的年之间发生闰年的次数, N 是平常年的次数, D 是 year 年内的积累天数. 将整年数 year-1=L+N 带入上式, 可得:

$$
w=((year-1)\times365+L+D)\%7
$$

根据闰年规律, 从公元元年到 y 年之间的闰年次数是可以计算出来的, 即:

![](/img/funofAL/360截图18141218538499.png)

带入到上式中, 得到最终的计算公式:

![](/img/funofAL/360截图18141217174224.png)

该公式的问题在于计算量大, 不利于口算星期结果, 于是在此式子的基础上继续推导更简单的公式. 德国数学家 Christian Zeller 在 1886 年推导出了著名的蔡勒公式:

![](/img/funofAL/360截图17981127255225.png)

最后计算出的余数就是星期数, 余数为 0, 则为星期日. 蔡勒公式中个符号的含义如下:

-   c: 世纪数-1 的值, 如 21 世纪, c=20;
-   m: 月数, 取值大于等于 3, 小于等于 14, 1 月和 2 月看做 13 月和 14 月
-   y: 年, 取公元纪年的后两位: 1998 年: y=98
-   d: 某月内的日数

如果得出的计算结果是负数, 需要对结果+7 进行修正. Zeller 公式的代码如下:

```js
//Zeller--蔡勒公式
function ZellerWeek(year, month, day) {
  let m = month;
  let d = day;
  if (month <= 2) {
    //对小于3的月份进行修正
    year--;
    m = month + 12;
  }
  let y = year % 100;
  let c = year / 100;

  let w = (y + y / 4 + c / 4 - 2 * c + (12 * (m + 1)) / 5 + d - 1) % 7;
  if (w < 0) {
    w += 7;
  }
  return w;
}
=
```

Zeller 公式和前面提到计算方法都只是用格里历法. 罗马教皇在 1582 年修改立法, 将 10 月 5 日指定为 10 月 15 日, 从而开始废废止儒略历法, 开始启用格里历法. 因此上述求星期几的公式适用于 1582 年 10 月 15 日之后的日期. 对于 1582 年 10 月 4 日之前的日期, 可以使用下面的公式:

![](/img/funofAL/360截图16850819101915.png)

#### 生成日历的算法

日历一般以月为单位组织, 生成日历需要知道每个月有多少天. 格里历历法简单, 除了二月外每月天数固定, 二月则根据是否闰年确定是 28 天还是 29 天, 比较适合使用查表法实现, 首先定义一个 daysOfMonth 表, 再次利用数组下表的技巧, 直接用其表示月份:

```js
const MONTHES_YEAR = 12;
let daysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function GetDaysOfMonth(year, month) {
    if (month < 1 || month > MONTHES_YEAR) return 0;
    let days = daysOfMonth[month - 1];
    if (month == 2 && IsLeapYear(year)) {
        days++;
    }
    return days;
}
```

确定每个月的天数以后, 就可以一次排列输出这个月的所有日期. 星期的位置是固定的, 每个月的第一天是星期几就从星期几对应的位置开始排列数字, 遇到星期六(星期的位置是从星期日到星期六排列)就折返下一行继续输出. 每个月第一天的星期数可以用 zeller 公式计算, 之后的每一天不必重复使用 zeller 公式, 使用 week=(week+1)%7 进行推算就可以了.

```js
function PrintMonthCalendar(year, month) {
    let days = GetDaysOfMonth(year, month); //确定这个月的天数
    let firstDayWeek = ZellerWeek(year, month, 1); //插入前置空格
    let src = InsertRowSpace(firstDayWeek);
    let week = firstDayWeek;
    let i = 1;
    while (i <= days) {
        src += `${i}\t`;
        if (week == 6) {
            src += '\n';
        }
        i++;
        week = (week + 1) % 7;
    }
    console.log(`周日\t周一\t周二\t周三\t周四\t周五\t周六\t`);
    console.log(src);
}
```

输入`2018,11`, 得到:

```
周日    周一    周二    周三    周四    周五    周六
                                1       2       3
4       5       6       7       8       9       10
11      12      13      14      15      16      17
18      19      20      21      22      23      24
25      26      27      28      29      30
```

#### 日历变更

1. 儒略历和格里历

在公元 1582 年 10 月 15 日之前, 人们使用的立法是源自古罗马的儒略历. 儒略历的置润规则非常简单, 就是四年一润, 这种置润规则使得理发时间每年比天文时间多出来 0.0078 天, 这样从公元前 46 年到公元 1582 年一共累计多出 10 天. 再这样下去, 立法和天气时节就要脱节了. 为此, 当时的教皇将 1582 年 10 月 5 日人为指定为 10 月 15 日, 并开始启用新的置润规则, 这就是后来沿用至今的格里历.

2. 1752 年 9 月

如果你在 Unix 或者 Linux 控制台输入:

```
$ cal 9 1752
```

你会得到一个奇怪的输出:

```
September 1752
Su Mo Ti We Th Fr Sa
       1 2  14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
```

是的, 缺了 11 天. 1582 年 10 月 5 日, 罗马教皇启用格里历, 但是并不是整个欧洲都立刻转换了. 英国知道 1752 年 9 月会议才批准使用格里历. 所以英国及其殖民地一直到这个时候才跳转日期. Linux 的 cal 指令起源于楚竹的 AT&T 的 Unix, 采用美国历法, 但是 1752 年 9 月事前只能采用英国历法.

3. 公历的闰年

格里历的置润规则是除了四年一闰, 百年不闰, 四百年在闰. 实际上还有一条规则, 如果能整除 3200, 还必须整除 864000 才是闰年.

### 二十四节气的天文学计算

古代历法都是以月亮运行规律为主, 严格按照朔望月长度定义月, 但是由于朔望月长度和地球回归年长度无法协调, 会导致农历几节和天气的实际冷暖无法对应, 因此聪明的古人讲月亮运行规律和太阳运行规律相结合指定了中国农历的立法规则. 这种特殊的阴阳结合的历法规定中, 二十四节气就扮演者非常重要的作用, 它是联系月亮运行规律和太阳运行规律的纽带. 正是由于二十四节气结合置闰规则, 使得农历的春夏秋冬和地球绕太阳运动引起的天气冷暖变化相一致, 成为中国几千年来生产的生活的依据.

#### 二十四节气的起源

二十四节气起源于黄河流域. 公元前 104 年, 汉武帝班服太初历. 每个公历月对应两个节气. 第一个节气为"节令", 即立春, 惊蛰, 清明, 立夏, 芒种, 小暑, 立秋, 白露, 寒露, 立冬, 大雪, 小寒; 每月的第二个节气为"中气", 即雨水, 春分, 谷雨, 小满, 夏至. 大暑, 处暑, 秋分, 霜降, 小雪, 冬至和大寒. 节令和中气交替出现, 各历时 15 天, 习惯上统称为"节气".

#### 二十四节气的天文学定义

为了理解二十四节气的天文位置, 需要引入几个天文学概念.

![](/img/funofAL/360截图170010208184103.png)

"天球"是人们为了研究天体的位置和运动规律而引入的一个假想的球体, 根据观察点(也就是球心)的位置不同, 可以分为"日心天球", "地心天球"等. 上图就是天球的一个简单示意.

天文学中常用的一个坐标体系就是"地心天球", 它与地球同心, 且有相同的自转轴, 理论上具有无限大的半径. 地球的迟到和南北极点延伸到天球上, 对应着天赤道和南北极点. 和地球上用经纬度定位位置一样, 天球也划分了经纬度, 分别命名为"赤经"和"赤纬", 地球上的经度以度(分秒)为单位, 赤经以时(分秒)为单位. 天空中所有天梯都可以投射到天球上, 用赤经和赤纬定位天体在天球上的位置. 地球沿着一个近似椭圆的轨道绕太阳公转, 这个公转轨道所在平面就是"黄道面".

黄道的严格定义是: 地月系质心绕太阳公转的瞬间平均轨道平面与天球相交的大圆. 黄道和天赤道所在的两个平面并不是重叠的, 它们之间存在一个 23 度 26 分的交角, 称为"黄赤交角". 由于黄赤交角的存在, 黄道和天赤道就在天球上有两个交点, 这两个交点就是春分点和秋分点. 在天球上以黄道为基圈可以形成黄道和天赤道就在天球上有两个交点, 这两个交点就是春分点和秋分点, 在天秋上以黄道为基圈可以形成黄道坐标系, 在黄道坐标系中也使用了经纬度的概念, 称为"黄经"和"黄维". 天梯的黄经以黄道测量平面为准, 向北记为 0 度到 90 度, 向南维为 0 到-90 度.

黄道平面可以近似理解为地球绕太阳公转的平面, 以黄道为基圈的黄道坐标系根据观测中心是地球还是太阳, 对应天气的黄道坐标分别为日心黄经黄纬, 地心黄经黄纬等.

![](/img/funofAL/360截图17070115114111135.png)

#### VSOP-82/87 行星理论

古代天文学家在对地球和月亮在内的行星运动轨道精确计算后发现, 天体的运行因为受相近天体的影响, 会在理论轨道附近波动, 这就是天文学中的摄动, 摄动很难精确计算, 近代科学家发现这种摄动有周期变化的趋势. 对一些周期计算按照某种计算式迭代求和计算代替积分计算来模拟行星运动轨迹. 这种计算式可以描述为:

$$
a+bt+ct2+...xcos(p+qt+rt2+...)
$$

其中 t 是时间参数, 这样的理论通常称为半解析(semi0analytic)理论.

1982 年, P.Bretagnon 发表了 VSOP, 描述了太阳系行星轨道在相当长时间范围内周期变化的半解析理论. VSOP82 数 VSOP 的一第一个版本. 1987 年创建了 VSOP87, 不仅能计算各种精密的轨道参数, 还可以计算出行星位置.

VSOP87 由 6 张周期项系数表组成, 其中 VSOP87D 可以直接计算行星日心黄经(L), 日心黄纬(B)和到太阳的距离(R), 此表计算出的结果适用于节气位置判断.

VSOP87D 表包含了三部分数据, 分别是 8 大行星的日心黄经周期项系数表(L 表), 日心黄纬周期项系数表(B 表)和行星与太阳距离周期项系数表(R 表). 以地球的数据为例,L 表有 L0~L5 六部分组成, 每一部分都包含若干个周期项系数条目, 每个周期项系数条目又包含若干个参数, 用于计算各种轨道参数和位置参数. 计算地球的日心黄经只需要用到其中三个系数. 计算所有的周期项系数并不是必须的, 有时候减少一些系数表较小的周期项可以减少计算所花费的时间, 当然, 这会牺牲一点精度. 假设计算地球日心黄经的三个系数 A,B 和 C, 则每个周期项的计算表达式:

$$
A\*cos(B+Ct)
$$

t 是儒略千年数, t 的计算公式如下:

$$
t=(JDE-2451545.0)/365250
$$

JDE 是计算轨道参数的时间, 单位是儒略日, 2451545.0 是公元 2000 年 1 月 1 日 12 时的儒略日数.

以 L-表的十二个周期项为例, 这个周期项数据中与日心黄经计算有关的三个系数分别为:

-   A: 3341656.456
-   B: 4.66925680417
-   C: 6283.07584999140

则计算方法为:

$$
3341656.456 \* cos(4.66925680417+6283.0758499914\*t)
$$

对 L0 表的各项分别计算后求和可得到 L0 表周期项综合 L0, 对 L 表的其他几部分使用相同的方法计算周期项和, 可以得到 L1,L2,L3,L4,L5, 然后利用计算式:

$$
L=(L0+L1\*t+L2\*t^2+L3\*t^3+L4\*t^4+L5\*t^5)/10^8
$$

这里我们需要多次计算 t 的乘方, 对于这样的多项式求和, 可以利用"霍纳法则"进行优化, 转化为下面这样的式子:

$$ L=(((((L5\*t+L4)\*t+L3)\*t+L2)\*t+L1)\*t+L1)/10^8 $$

使用 VSOP87D 周期项系数表计算得到的是 J2000.0 平黄道和平春分点为基准的日心黄经和日心黄纬, 其值与标准 FK5 略有差别, 如果对精度要求很高, 可以采用下面的方法将计算得到的日心黄经和日心黄纬转到 FK5 系统:

-   首先计算 L':

$$ L'=L-1.397\*T-0.00031\*T^2 $$

式子中的 T 是儒略世纪数, 它与儒略千年数 t 的计算关系是: $T=10\*t$. 计算出 L'之后, 就可以利用下面这两个式子计算 △L 和 △B:

$$
△L=-0.09033+0.03916\*(cos(L')+sin(L'))\*tan(B) \\\
△B=+0.03916\*(cos(L')+sin(L'))
$$

这里的 △L 和 △B 的单位都是度分秒角度单位体系, 需要转换为弧度单位后再对 L 和 B 进行修正.

`CalcSunEclipticLongitudeEC()`函数就是使用 VSOP87 计算行星日心黄经的代码实现: 首先根据表的数据计算出 L0-L5, 然后再计算地球的日心黄经.

```js
//使用公式对coff参数指定的周期项系数表进行计算求和计算
function CalcPeriodicTerm(coff, count, dt) {
    let val = 0.0;

    for (let i = 0; i < count; i++) val += coff[i].A * cos(coff[i].B + coff[i].C * dt);

    return val;
}

//计算行星日心黄经
function CalcSunEclipticLongitudeEC(dt) {
    let L0 = CalcPeriodicTerm(Earth_L0, COUNT_OF(Earth_L0), dt);
    let L1 = CalcPeriodicTerm(Earth_L1, COUNT_OF(Earth_L1), dt);
    let L2 = CalcPeriodicTerm(Earth_L2, COUNT_OF(Earth_L2), dt);
    let L3 = CalcPeriodicTerm(Earth_L3, COUNT_OF(Earth_L3), dt);
    let L4 = CalcPeriodicTerm(Earth_L4, COUNT_OF(Earth_L4), dt);
    let L5 = CalcPeriodicTerm(Earth_L5, COUNT_OF(Earth_L5), dt);

    let L = (((((L5 * dt + L4) * dt + L3) * dt + L2) * dt + L1) * dt + L0) / 100000000.0;

    /*地心黄经 = 日心黄经 + 180度*/
    return Mod360Degree(Mod360Degree(L / RADIAN_PER_ANGLE) + 180.0);
}

//计算行星日薪黄纬
function CalcSunEclipticLatitudeEC(dt) {
    let B0 = CalcPeriodicTerm(Earth_B0, COUNT_OF(Earth_B0), dt);
    let B1 = CalcPeriodicTerm(Earth_B1, COUNT_OF(Earth_B1), dt);
    let B2 = CalcPeriodicTerm(Earth_B2, COUNT_OF(Earth_B2), dt);
    let B3 = CalcPeriodicTerm(Earth_B3, COUNT_OF(Earth_B3), dt);
    let B4 = CalcPeriodicTerm(Earth_B4, COUNT_OF(Earth_B4), dt);

    let B = ((((B4 * dt + B3) * dt + B2) * dt + B1) * dt + B0) / 100000000.0;

    /*地心黄纬 = －日心黄纬*/
    return -(B / RADIAN_PER_ANGLE);
}
```

计算出地心黄经和地心黄纬之后, 就可以使用计算式修正计算, 将其转到 FK5 目视系统, 算法实现如下:

```js
/*修正太阳的地心黄经，longitude, latitude 是修正前的太阳地心黄经和地心黄纬(度)，dt是儒略千年数，返回值单位度*/
function AdjustSunEclipticLongitudeEC(dt, longitude, latitude) {
    let T = dt * 10; //T是儒略世纪数

    let dbLdash = longitude - 1.397 * T - 0.00031 * T * T;

    // 转换为弧度
    dbLdash *= RADIAN_PER_ANGLE;

    return (
        (-0.09033 + 0.03916 * (Math.cos(dbLdash) + Math.sin(dbLdash)) * Math.tan(latitude * RADIAN_PER_ANGLE)) / 3600.0
    );
}

/*修正太阳的地心黄纬，longitude是修正前的太阳地心黄经(度)，dt是儒略千年数，返回值单位度*/
function AdjustSunEclipticLatitudeEC(dt, longitude) {
    let T = dt * 10; //T是儒略世纪数
    let dLdash = longitude - 1.397 * T - 0.00031 * T * T;
    //转换为弧度
    dLdash *= RADIAN_PER_ANGLE;
    return (0.03916 * (Math.cos(dLdash) - Math.sin(dLdash))) / 3600.0;
}
```

longitude 和 latitude 参数分别是前面计算得到的地心黄经和地心黄纬, 返回的结果是地心黄经修正量 △L.

#### 误差修正--章动

经过上面计算转换得到的坐标值是理论值, 或者说是天体的几何位置. 但是 FK5 是一个目视系统, 体现的是人眼睛观察的效果(光学位置), 这就需要根据地球的物理环境大气环境等信息做进一步的修正, 使其与人类观察结果一致.

首先需要进行章动修正. *章动*是指地球沿自转轴的指向绕黄道极缓慢旋转过程中, 由于地球上物质分布不均匀性和月球及其他行星的摄动力造成的轻微抖动. 章动可以沿着黄道分解为水平分量和垂直分量, 黄道上的水平分量称为黄经章动, 影响了天球上所有天梯的精度, 垂直分量称为交角章动, 影响黄赤交角.

地球章动主要是月球运动引起的, 也具有一定的周期性, 可以描述为一些周期项的和, 主要项的周期是 6789.4 日(18.6)年, 但其他一些短周期项(小于 10 天). 本文采用的计算方法取自国际天文联合会的 IAU1980 章动理论, 周期项系数来源于<天文算法>一书第 21 张的表 21-A, 该表忽略了 LAU1980 章动理论中系数小于 0.0003 的周期项, 因此只有 63 项. 每个周期项包括计算黄经章动的正弦系数, 计算交角章动的余弦系数以及计算幅角的 5 个基本角距的线性组合系数, 5 个基本角距的计算公式如下:

-   平距角计算公式:

$$ D=297.85036+455267.111480\*T-0.0019142\*T^2+T^3/189474 $$

-   太阳平近点角计算公式:

$$ M= 357.52772+35999.050340\*T-0.0001603\*T^2-T^3/300000 $$

-   月球平近点角计算公式

$$ M'=137.96298+477198.867398\*T+0.0086972\*T^2+T^3/56250 $$

-   月球维度参数计算公式:

$$ F=93.27191+483202.017539\*T-0.0036825\*T^2+T^3/327270 $$

-   黄道与月球平轨道升交点黄经:

$$ \Omega=125.04452-1934.136261\*T-0.0020708\*T^2+T^3/450000 $$

计算每一个周期项的黄经章动过程如下: 首先用上面五个式子计算出 5 个基本角距, 然后计算出来的值与对应的 5 个基本角距系数组合, 计算出幅角. 然后使用下面的式子计算周期项的值:

$$ \theta=-2D+M+2F+2\Omega $$

然后:

$$ S=(S1+S2\*T)\*\sin(\theta) $$

交角章动的计算方法与黄经章动的计算类似, 只不过计算使用的是余弦值.

```js
/*计算某时刻的黄经章动干扰量，dt是儒略千年数，返回值单位是度*/
NUTATION.CalcEarthLongitudeNutation = function(dt) {
    let T = dt * 10;
    let D, M, Mp, F, Omega;

    NUTATION.GetEarthNutationParameter(dt, D, M, Mp, F, Omega);

    let resulte = 0.0;
    for (let i = 0; i < sizeof(nutation) / sizeof(nutation[0]); i++) {
        let sita =
            nutation[i].D * D + nutation[i].M * M + nutation[i].Mp * Mp + nutation[i].F * F + nutation[i].omega * Omega;
        sita = DegreeToRadian(sita);

        resulte += (nutation[i].sine1 + nutation[i].sine2 * T) * sin(sita);
    }

    /*先乘以章动表的系数 0.0001，然后换算成度的单位*/
    return (resulte * 0.0001) / 3600.0;
};
```

`CalcEarthLongitudeNutation`函数计算黄经章动, 计算交角章动的算法实现与之类似. `GetEarthNutationParameter`辅助函数用于计算 5 个基本角距,

#### 误差修正--光行差

除了章动修正, 对于目测系统来说, 还要进行光行差修正. 光行差是指在同一瞬间, 运动中的观察者所观测到的天体视方向与静止的观察者所观测到天体的真方向之差. 造成光行差的原因一个是光的有限速度, 另一个观察者的运动. 在地球上的天文观测者因与地球一起运动, 他所看到的星光方向与假设地球不动时看到的方向不一样. 比如太阳, 地球上看到的太阳实际上是 8 分钟之前的太阳.

下面是一个粗略计算太阳地心黄经光行差修正量的公式:

$$ AC=-20''.4898/R $$

分子 20.4898 并不是一个常数, 但是其值得变化非常缓慢, 在 0 年是 20''.4893, 在 4000 年是 20''.4904.

太阳到地球的距离 R 可以如下计算:

```js
SUN.CalcSunEarthRadius = function(dt) {
    let R0 = CalcPeriodicTerm(VSOP87.Earth_R0, DEFINE.COUNT_OF(VSOP87.Earth_R0), dt);
    let R1 = CalcPeriodicTerm(VSOP87.Earth_R1, DEFINE.COUNT_OF(VSOP87.Earth_R1), dt);
    let R2 = CalcPeriodicTerm(VSOP87.Earth_R2, DEFINE.COUNT_OF(VSOP87.Earth_R2), dt);
    let R3 = CalcPeriodicTerm(VSOP87.Earth_R3, DEFINE.COUNT_OF(VSOP87.Earth_R3), dt);
    let R4 = CalcPeriodicTerm(VSOP87.Earth_R4, DEFINE.COUNT_OF(VSOP87.Earth_R4), dt);

    let R = ((((R4 * dt + R3) * dt + R2) * dt + R1) * dt + R0) / 100000000.0;

    return R;
};
```

计算出太阳到地球的距离之后, 就可以使用上面的数学式子计算光行差修正量. 计算出的结果再转换成弧度范围

#### 用牛顿迭代法计算二十四节气

有 VSOP87 理论计算出来的集合位置黄经, 经过坐标计算, 章动修正和光行差修正后, 就可以得到比较准确的太阳地心视黄经, `GetSunEclipticlongitudeEC()`函数就是整个过程的体现, 参数 dt 就是儒略千年数. 计算方式已经在前面的章节中给出.

到目前为止, 我们知道如何使用 VSOP82/87 理论计算以儒略日为单位的任意是个的太阳地心视黄经. 但是实际的立法计算需要根据太阳地心视黄经反求此时的时间, 实际上, 就是求解方程的根.

范式我们面临的这个方程没有解析表达式, 更没有球根公式. 第十三章求解非线性方程的方法, 都适用于现在的问题. 牛顿迭代法具有收敛速度快, 稳定的特点.

使用牛顿迭代法首先要定义函数 `f(x)=GetSunEclipticLongitudeEC(x)-angle`, 然后就可以写出牛顿迭代关系:

$$ x\_{n+1}=x_n-f(x_n)/f'(x_n) $$

确定了方程, 然后求导函数, 求解.

...

## 第十二章高 实验数据与曲线拟合

### 曲线拟合

_曲线拟合_ 的数学定义是指用连续曲线近似地刻画或比拟平面上一组离散点所表示的坐标之间的函数关系, 是一种用解析表达式逼近离散数据的方法. 曲线拟合通俗的说法就是"拉曲线", 也就是将现有数据通过数学方法来带入一条数学方程式的表示方法. 以上定义中可以看出, 曲线拟合不仅仅是根据离散数据画出一条曲线, 曲线拟合更重要的意义是通过特定的曲线拟合算法, 推算出一个能逼近离散数据并能维持统计误差最小的输小解析表达式.

### 最小二乘法曲线拟合

#### 原理

最小二乘法, 又称最小平方法, 是一种通过最小化误差的平方和寻找数据的最佳匹配方法. 利用最小二乘法, 可以简单地求得位置的数据, 并使得这些求得的数据与实际数据之间误差的平方和为最小. 当然, 作为一种插值方法使用时, 最小二乘法也可以用于曲线拟合. 使用最小二乘法进行曲线拟合是曲线拟合中早期的一种常用方法. 不过, 最小二乘法理论简单, 计算量小, 既是在使用三次样条曲线或 RBF 进行曲线拟合大行其道的今天, 最小二乘法在多项式曲线或直线的拟合问题上, 仍然得到广泛的应用. 使用最小二乘法, 选取的匹配函数的模式非常重要: 如果离散数据呈现的指数变化规律, 则应该选择指数形式的匹配函数模式. 如果是多项式变化规律, 则应该选择多项式匹配模式. 如果选择的模式不对, 拟合的效果就会很差, 这也是最小二乘法进行曲线拟合时需要特别注意的一个地方.

以下面多项式模式为例, 介绍一下使用最小二乘法拟合的完整步骤. 假设选择的拟合多项式是:

$$ y=a_0+a_1x+a_2x^2+...+a_mx^m \tag{12.1}$$

离散的各点到这条曲线的平方和$ F(a_0,a_1,...,a_m) $则为:

$$ F(a*0,a_1,a_m)=\sum*{i=1}^n{[y_i-(a_0+a_1x_i+a_2x_i^2+...+a_mx_i^m)]^2} $$

最小二乘法的第一步处理就是对$ F(a_0,a_1,...,a_m) $分别求对 a_i 的偏导数, 得到 m 个等式:

$$
-2 \sum*{i=1}^n{[y_i-(a_0+a_1x_i+a_2x_i^2+...+a_mx_i^m)]} = 0 \\\
-2 \sum*{i=1}^n{[y_i-(a_0+a_1x_i+a_2x_i^2+...+a_mx_i^m)]x*i} = 0 \\\
-2 \sum*{i=1}^n{[y_i-(a_0+a_1x_i+a_2x_i^2+...+a_mx_i^m)]x_i^m} = 0
\tag{12.2}
$$

这 m 个等式相等于 m 个方程, a_0~a_m 有 m 个未知量, 因此这个方程组是可解的. 第三步处理的时候就是求解这个多元一次方程组, 得到多项式的系数就可以得到曲线的拟合多项式函数. 高斯消元法是最常用的一种方法.

#### 高斯消元法求解方程组

在数学上, 高斯消元法是线性代数的中的一个算法, 可用来求解多元一次线性方程组, 也可以用来求矩阵的秩, 以及求可逆矩阵的逆矩阵.

主要思想是通过对系数矩阵进行变换, 讲方程的系数矩阵由对称矩阵变为三角矩阵, 从而消元, 然后一一回代. 得到方程组的杰.

代码实现主要有两个步骤组成:

1. 选择主元, 逐行消元, 最终形成三角矩阵形式.
2. 逐步回代

下面是一个算法实现:

```js
/**
 * 带列主元的高斯消去法解方程组，最后的解在matrixA的对角线上
 * xValue: 系数矩阵
 */
Resolve(xValue) {
    this.asset(xValue.length == this.m_DIM, 'xValue lenght error');

    // 消元, 得到上三角阵
    for (let i = 0; i < this.m_DIM.length; i++) {
        // 按列选主元
        let pivotRow = this.SelectPivotalElement(i);
        if (pivotRow != i) {
            //如果有必要, 交换行
            this.SwapRow(i, pivotRow);
        }
        if (this.IsPrecisionZero(this.m_matrixA[i * this.m_DIM + i])) {
            return false;
        }
        /*对系数归一化处理，使行第一个系数是1.0*/
        this.SimplePivotalRow(i, i);
        for (let j = i + 1; j < this.m_DIM; j++) {
            this.RowElimination(i, j, i);
        }
    }
    //回代求解
    this.m_matrixA[(this.m_DIM - 1) * this.m_DIM + this.m_DIM - 1] =
        m_bVal[this.m_DIM - 1] / m_matrixA[(this.m_DIM - 1) * this.m_DIM + this.m_DIM - 1];
    for (let i = this.m_DIM - 2; i >= 0; i--) {
        let totalCof = 0;
        for (let j = i + 1; j < this.m_DIM; j++) {
            totalCof += this.m_matrixA[i * this.m_DIM + j] * this.m_matrixA[j * this.m_DIM + j];
        }
        this.m_matrixA[i * this.m_DIM + i] = (this.m_bVal[i] - this.totalCof) / this.m_matrixA[i * this.m_DIM + i];
    }
    /*将对角线元素的解逐个存入解向量*/
    for (let i = 0; i < this.m_DIM; i++) {
        xValue[i] = this.m_matrixA[i * this.m_DIM + i];
    }

    return true;
}
```

在`Resolve()`函数中, `m_matrixA`是以以为数组形式存放的系数矩阵, `m_DIM`是矩阵的维数, 通过除法操作将指定的行的对角线元素变换为1.0, 以便简化随后的消元操作;

#### 最小二乘法解决"速度与加速度"实验

用程序实现的最小二乘法曲线拟合的算法主要由两个步骤组成, 第一个步骤就是根据给出的测量值生成关于拟合多项式系数的方程组, 第二个步骤就是解这个方程组, 求出拟合多项式的各个系数. 根据对上文最终整理的正规方程组的分析, 可以看出其系数有一定的关系, 就是每一个方程都比前一个方程多乘了一个$ x_i $, 因此, 只需要完整计算出第一个方程式的系数, 其他方程式的系数只是将前一个方程式的系数依次左移一位, 然后独立计算出最后一个系数就可以了, 这个方法可以减少很多无谓的计算. 求解多元一次方程组的方法就用上面的高斯消元法, 其算法上一节已经给出.

这里给出一个最小二乘算法的完整实现, 拟合多项式选择为$v=v_0+at$, $v_0$和$a$就是要求解的拟合多项式系数: 

```js
function LeastSquare(x_value, y_value, M, a_value) {
  assert(x_value.length == y_value.length);
  assert(a_value.length == M);

  let matrix = new Array(M * M);
  let b = new Array(M);

  let x_m = new Array(x_value.length).fill(1);
  let y_i = new Array(y_value.length).fill(0);

  for (let i = 0; i < M; i++) {
    matrix[ARR_INDEX(0, i, M)] = x_m.reduce(getSum);
    for (let j = 0; j < y_value.length; j++) {
      y_i[j] = x_m[j] * y_value[j];
    }
    b[i] = y_i.reduce(getSum);
    for (let k = 0; k < x_m.length; k++) {
      x_m[k] *= x_value[k];
    }
  }
  for (let row = 1; row < M; row++) {
    for (let i = 0; i < M - 1; i++) {
      matrix[ARR_INDEX(row, i, M)] = matrix[ARR_INDEX(row - 1, i + 1, M)];
    }
    matrix[ARR_INDEX(row, M - 1, M)] = x_m.reduce(getSum);
    for (let k = 0; k < x_m.length; k++) {
      x_m[k] *= x_value[k];
    }
  }

  let equation = new GuassEquation(M, matrix, b);

  return equation.Resolve(a_value);
}
```

### 三次样条曲线拟合

曲线拟合基本上就是一个插值计算的过程, 除了最小二乘法, 其他插值方法也可用于曲线拟合. 常用的曲线拟合方法还有给予RBF的曲线拟合和三次样条曲线拟合. 最小二乘法简单, 便于实现, 但是如果拟合模式选择不当, 会产生较大的偏差, 特别是对于复杂曲线的拟合, 如果选错模式, 拟合的效果就很差. 基于RBF的曲线拟合方法需要高深的数学基础, 涉及多维空间理论, 将低维的模式输入数据转换到高维空间中, 使得低维空间内的线性不可分问题在高维空间内变得线性可分, 这种数学分析方法非常强大, 但不易得到拟合函数.

样条插值是一种工业设计中常用的, 得到平滑曲线的一种插值方法, 三次样条是其中较为广泛的一种, 可以得到非常高精度的拟合结构, 并且很容易得到拟合函数. 

#### 插值函数

曲线拟合的实质就是各种插值计算, 因此, 插值函数的选择决定了曲线拟合的效果. 

在[a,b]上给出n+1个点,f(x)是[a,b]上的实值函数, 要求一个具有n+1个参量的函数S(x;a0,...,an), 使其满足: 

$$ s(x_i;a_0,...,a_n)=f(x_i),i=0,1,...,n \tag{12-5} $$

则成$s(x)$为$f(x)$在[a,b]上的插值函数, 若$s(x)$关于参量$a_0,a_1,...,a_n$是线性关系,$s(x)$就是多项式插值函数, 如果$s_i(x)$是三角函数, 则$s(x)$就是三角插值函数. 

比较常用的多项式插值函数式牛顿插值多项式和拉格朗日插值多项式, 但是在多项式的次数比较高的情况下, 插值点数n过多会导致多项式插值在收敛性和稳定性上失去保证, 因此, 当插值点数n较大的情况下, 一般不适用多项式插值, 而采用样条插值或者次数较低的最小二乘法插值.


#### 样条函数定义

在所有能够保证收敛性和稳定性的插值函数中, 最常用的噎死最重要的插值函数就是样条插值函数. 数学定义如下: 

设区间$[a,b]$选取$n-1$个节点(包括区间端点a和b共n+1个节点), 将其划分为n个自取件$a=x_0<x_1<...Mx_n=b$, 如果存在函数$s(x)$, 使得$s(x)$满足一下两个条件: 

1. $s(x)$在整个区间$[a,b]$上具有$m-1$阶连续导数;
2. $s(x)$在每个子区间$[x_{i-1},x_i],i-1,2,...,n$上是m次代数多项式(最高次为m);

则称$s(x)$是区间$[a,b]$上的m次样条函数, 加入区间$[a,b]$上存在实值函数$f(x)$, 使得每个节点处的$f(x_i)$与$s(x_i)$相等, 即: 

$$ s(x_i)=f(x_i),i=0,1,...,n $$

当m=1时, 样条插值函数就是分段线性插值, 此时虽然$s(x)$是属于区间$[a,b]$上的函数, 但是它不光滑. 工程设计通常使用较多的是$m=3$时的三次样条插值函数, 此时样条函数具有二阶连续导数性质. 

根据三次样条函数的定义, $s(x)$在每个子区间上的样条函数, $s_i(x)$都是一个三次多项式, 也就是说, 三次样条函数$s(x)$由n个区间上的n个三次多项式组成, 每个三次多项式可以描述为:

$$ s_i(x)=a_ix^3+b_ix^2+c_ix+d_i i=1,2,...,n $$

确定完整的样条函数$s(x)$需要确定a_i,b_i,c_i和d_i公4n个系数, 根据样条函数的定义, $s(x)$在区间内的n-1个节点处都是连续的, 并且其一阶导数$s_i'(x)$和$s_i''(x)$都是连续的, 根据连续函数的性质($x_i$左右导数相等), 我们可以得到3(n-1)个条件: 

$$ 
s_i(x_i-0)=s_{i+1}(x_i+0) i=1,2,...,n-1\\\
s_i'(x_i-0)=s_{i+1}'(x_i+0) i=1,2,...,n-1\\\
s_i''(x_i-0)=s_{i+1}''(x_i+0) i=1,2,...,n-1\\\
$$

再加上插值函数在包括区间端点a,b在内的n+1个节点处满足$s(x_i)=f(x_i)$, 又可以得到n+1个条件, 这样就具备了4n-2个条件. 

#### 边界条件

解决4n个系数组成的方程组, 需要再补充两个边界条件. 通常有两类: 

- 第一类: 满足: $s'(x_0)=f'(x_0),s'(x_n)=f'(x_n)$两个条件, 其中$f(x)$是实值函数. 
- 第二类: 满足: $s''(x_0)=f''(x_0),s''(x_n)=f''(x_n)$两个条件, 其中$f(x)$是实值函数. 特别情况下, 当$f''(x_0)=f''(x_n)=0$的时候, 第二类边界条件又成为自然边界条件. 
- 当$f(x)$是周期函数时, 三次样条函数$s(x)$在两个端点处满足$s'(x_0-0)=s'(x_n+0)$和$s''(x_0-0)=s''(x_n+0)$, 这种又称为第三类边界条件

第一类边界条件和第二类边界条件常用于工程技术, 实值函数已知的情况下, 可以通过实值函数直接计算出边界条件的值, 否则就只能通过测量和计算得到边界条件的值, 有时候甚至只能给出经验估计值. 

#### 推导三次样条函数

方法很多, 基本原理都是求出待定系数组成的$s(x)$, 以及一阶导数和二阶导数, 带入条件中, 得到关于待定系数的方程组, 最后求解方程组得到待定系数, 并最终确定插值函数$s(x)$

常用的方法是"三转角法"和"三弯矩法". 根据三次样条函数的性质, 易知, $s(x)$一阶导数是二次多项式, 二阶导数是一次多项式(线性函数), 这两个方法的主要区别是利用这两个特性推导插值函数的方式不同. 

三转角法利用$s(x)$的一阶导数是二次多项式这个特点, 对子区间$[x_i,x_{i+1}]$, 利用抛物线插值公式获得一个$x_i$和$x_{x+1}$两个点的二次多项式作为$s'(x)$, 然后对$s'(x)$进行积分和微分运算, 得到$s(x)$和$s'(x)$, 然后带入求解. 

三弯矩法利用$s(x)$的二阶导数是一次多项式这个特点, 对于子区间$[x_i,x_{i+1}]$, 假设一个通过两个端点的线性函数作为二阶导数, 然后连续两次积分得到原函数, 再求导得到一阶导数, 最后在导入求解. 

三次样条函数的求解过程就是系数方程的推导过程, 使用"三弯矩法"推导系数方程组, 首先要确定插值函数的二阶导数$s''(x)$是个线性方程, 现在假设在两个端点的二阶导数值分别$M_i$和$M_{i+1}$, 则进过这两点的直线方程易求得: 

$$ \frac{y-M_i}{x-x_i}=\frac{M_{i+1}-M_i}{x_{i+1}-x_i} $$

随后变换为$s_i''(x)$, 对其进行两次积分: 

![](/img/funofAL/360截图16790521729586.png)

根据插值条件: $s_i(x_i)=y_i$和$s_i(x_{i+1})=y_{i+1}$, 带入到上式, 得到两个等式:

![](/img/funofAL/360截图18720123446279.png)

将$h_i=x_{i+1}-x_i$, 带入简化, 得到$A_i$和$B_i$:

![](/img/funofAL/360截图1732112494149132.png)

带入, 得到完整的$s_i(x)$:

![](/img/funofAL/360截图16800413679158.png)

求导: 

![](/img/funofAL/360截图1872012099153151.png)

根据特性, 左右导数连续, 联立方程: 

![](/img/funofAL/360截图18481115306838.png)

化简: 

![](/img/funofAL/360截图162610018910585.png)

如果使用第二类边界条件, 可以得到下面两个条件等式: 

![](/img/funofAL/360截图17571112365874.png)

令$d_0=2y_0'$, $d_n=2y_n'$, 可以得到两个方程: 

![](/img/funofAL/360截图16720330548574.png)

如果使用第一类边界条件, 即$s'(x_0)=f'(x_0)$, $s'(x_n)=f'(x_n)$两个条件, 则需要将这两个条件带入12-16, 通过计算得到等式:　

![](/img/funofAL/360截图17001012728664.png)

$s'(x_n)=y_n$带入12-16, 得: 

![](/img/funofAL/360截图18720120466368.png)

![](/img/funofAL/360截图16720401829476.png)

将第二类边界条件得到的式子(12-23)和(12-24)或第一类边界条件得到的式子与式(12-20)中n-1个等式组合在一起就得到一个关于$M_I$的方程组, 求解次方程组可以得到$M_i$, 带入到柿子种即可得到三次样条函数方程. 以第一类边界条件威力, 联立得到方程组: 

![](/img/funofAL/360截图177509198381121.png)

这就是三弯矩方程组, 其中$M_i,i=0,1,...,n$就是三次样条函数的$s(x)$. 根据式子(12-27)和式子(12-28), un=1, v0=1, 其余各系数可以通过式(12-29)中的系数计算出来. 这个方程组的系数矩阵是一个对角线矩阵, 并且是一个严格对角占优的对角阵, 可以使用追赶法求解. 下面我们介绍如何使用追赶法求解方程组. 并给出求解的算法实现. 


#### 追赶求解方程组

任意矩阵A都可以通过克罗特分解得到两个三角矩阵: 

![](/img/funofAL/360截图167204056712484.png)

如果A是对角矩阵, 则克洛特分解的结果为: 

![](/img/funofAL/360截图17001021185920.png)

在分解后的矩阵中, $l_1=a_1,u_1=c_1/l_1$, 其余各项的计算规则如下: 

![](/img/funofAL/360截图16360801366362.png)

得到各个系数后, 原方程组就可以分解为两个方程组: 

![](/img/funofAL/360截图1757111598121149.png)

对于第一个方程求解向量$y_i$:

![](/img/funofAL/360截图18780413241730.png)

对于第二个方程, 求解$x_i$:

![](/img/funofAL/360截图170010219583127.png)

其中$x_n=y_n$, 其余各项的地推求解关系如下: 

$$ x_i=y_i-u_ix_{i+1},i=n-1,n-2,...,1 $$

递推计算的过程被形象的描述为追和赶, 故得名追赶法, 实际上这种方法在国际上叫做托马斯法. 对三角矩阵的克罗托分解需要满足一下几个条件:

1. $a_i≠0,i2,3,..,n$
2. $|a_1|>|c_1|,|a_n|>|b_n|$
3. $|a_i|>|b_i|+|c_i|,i=2,3,...,n-1$

下面给出一个通用算法实现, 没有添加条件判断:

```js
/*追赶法求对三角矩阵方程组的解*/
Resolve(xValue) {
    this.asset(xValue.length == this.m_DIM);
    let L = new Array(this.m_DIM);
    let M = new Array(this.m_DIM);
    let U = new Array(this.m_DIM);
    let Y = new Array(this.m_DIM);

    /* 消元, 追的过程 */
    L[0] = this.m_matrixA[ARR_INDEX(0, 0, this.m_DIM)];
    U[0] = this.m_matrixA[ARR_INDEX(0, 1, this.m_DIM)] / L[0];
    Y[0] = this.m_bVal[0] / L[0];
    for (let i = 0; i < this.m_DIM; i++) {
        if (IsPrecisionZero(this.m_matrixA[ARR_INDEX(i, i, m_DIM)])) {
            return false;
        }
        M[i] = this.m_matrixA[ARR_INDEX(i, i - 1, this.m_DIM)];
        L[i] = this.m_matrixA[ARR_INDEX(i, i, this.m_DIM)] - M[i] * U[i - 1];
        Y[i] = (this.m_bVal[i] - M[i] * Y[i - 1]) / L[i];
        if (i + 1 < this.m_DIM) {
            U[i] = this.m_matrixA[ARR_INDEX(i, i + 1, this.m_DIM)] / L[i];
        }
    }
    // 回代求解，赶的过程
    this.xValue[this.m_DIM - 1] = Y[this.m_DIM - 1];
    for (let i = this.m_DIM - 2; i >= 0; i--) {
        xValue[i] = Y[i] - U[i] * xValue[i + 1];
    }

    return true;
}
```

#### 三次样条曲线拟合算法实现

根据前面对三次样条函数的推导分析, 三次样条曲线拟合算法的核心可分为三部分, 第一部分是根据推导结果计算关于三次样条函数的"矩"的方程组的系数矩阵, 第二部分就是用追赶法求解方程组, 得到各个区间的三次样条函数, 第三部分就是根据每个拟合点的输入的值$x_i$, 确定使用哪个区间的三次样条函数, 并使用该区间的三次样条函数计算出三次样条插值$y_i$, 最后得到一些列$(x_i,y_i)$组成的曲线就是三次样条函数拟合曲线. 拟合算法也是按照上面的分析, 分为以下三个步骤计算插值: 

1. 计算系数矩阵, $u_0, v_0, d_0, d_n$需要单独计算, 其余的值可以通过式(12-19)递推计算出来. 
2. 将系数矩阵带入追赶法, 求出$M_i$. 求解之前判断是否满足追赶法的条件.
3. 计算插值, 将上一步得到的$M_i$带入(12-15), 并选择合适的子区间样条函数计算出插值点的值. 

下面给出代码实现:

```js
CalcSpline(Xi, Yi, n, boundType, b1, b2) {
    assert(boundType == 1 || boundType == 2);

    let matrixA = new Array(n * n);
    let d = new Array(n);

    this.m_valN = n;
    this.m_valXi = Xi.clone();
    this.m_valYi = Yi.clone();
    this.m_valMi = new Array(this.m_valN);

    matrixA[ARR_INDEX(0, 0, this.m_valN)] = 2.0;
    matrixA[ARR_INDEX(this.m_valN - 1, this.m_valN - 1, this.m_valN)] = 2.0;
    if (boundType == 1) {
        /*第一类边界条件*/
        matrixA[ARR_INDEX(0, 1, this.m_valN)] = 1.0; //v0
        matrixA[ARR_INDEX(this.m_valN - 1, this.m_valN - 2, this.m_valN)] = 1.0; //un
        let h0 = Xi[1] - Xi[0];
        d[0] = (6 * ((Yi[1] - Yi[0]) / h0 - b1)) / h0; //d0
        let hn_1 = Xi[this.m_valN - 1] - Xi[this.m_valN - 2];
        d[this.m_valN - 1] = (6 * (b2 - (Yi[this.m_valN - 1] - Yi[this.m_valN - 2]) / hn_1)) / hn_1; //dn
    } else {
        /*第二类边界条件*/
        matrixA[ARR_INDEX(0, 1, this.m_valN)] = 0.0; //v0
        matrixA[ARR_INDEX(this.m_valN - 1, this.m_valN - 2, this.m_valN)] = 0.0; //un
        d[0] = 2 * b1; //d0
        d[this.m_valN - 1] = 2 * b2; //dn
    }

    /*计算ui,vi,di，i = 2,3,...,n-1*/
    for (let i = 1; i < this.m_valN - 1; i++) {
        let hi_1 = Xi[i] - Xi[i - 1];
        let hi = Xi[i + 1] - Xi[i];
        matrixA[ARR_INDEX(i, i - 1, this.m_valN)] = hi_1 / (hi_1 + hi); //ui
        matrixA[ARR_INDEX(i, i, this.m_valN)] = 2.0;
        matrixA[ARR_INDEX(i, i + 1, this.m_valN)] = 1 - matrixA[ARR_INDEX(i, i - 1, this.m_valN)]; //vi = 1 - ui
        d[i] = (6 * ((Yi[i + 1] - Yi[i]) / hi - (Yi[i] - Yi[i - 1]) / hi_1)) / (hi_1 + hi); //di
    }

    let equation = new ThomasEquation(this.m_valN, matrixA, d);
    equation.Resolve(this.m_valMi);
    this.m_b
}
```

## 第十三章 非线性方程与牛顿迭代法

目前人们普遍认为低阶一元非线性方程可以通过求根公式求解, 但是高于或等于5阶的一元非线性方程不存在求根公式, 要精确求解非常困难, 对高阶方程, 一般采用迭代法近似求解

### 非线性方程求解的常用方法

一元非线性方程的常用求解方法有很多, 能够精确求解的方法有开平方法, 配方法, 因式分解法, 公式法, 近似求解的方法有作图法以及各种迭代法. 开平方法, 配方法和因式分解法适用于一元非线性方程中的一些特殊情况, 适用范围有限. 公式法适用于低阶方程. 比如一元二次方程可以使用韦达公式, 一元三次方程可以使用卡尔丹公式或盛金公式, 公式法比较适合编写计算机算法求解,作图法简单但是精度不高, 可用于迭代法时估计迭代初始值. 

### 二分逼近法

对于实数域的函数$f(x)$, 如果存在实数k, 使得$f(k)=0$, 则x=k为函数的零点, 如果函数$f(x)$是连续函数, 在区间[a,b]上单调, 且f(a)与f(b)一号, 就说明该区间内函数有零点, 此时可以使用二分逼近法近似地找到这个零点. 

代码如下: 

```js
function DichotomyEquation(a, b, f) {
  let mid = a + b / 2;
  while (b - a > PRECISION) {
    if (f(a) * f(mid) < 0.0) {
      b = mid;
    } else {
      a = mid;
    }
    mid = (a + b) / 2.0;
  }
  return mid;
}
```

### 牛顿迭代法

牛顿迭代法又称为牛顿-拉夫森方法, 它是一种实数域和附属于上近似求解方程的方法. 方法使用函数f(x)的泰勒级数的前面几项来寻找f(x)=0的根.

首先, 选择一个接近函数f(x)零点的$x_0$作为迭代初始值, 计算相应的$f(x_0)$和切线斜率$f'(x_0)$. 然后经过点$(x_0,f(x_0))$做一条斜率为$f'(x_0)$的直线, 该直线与x轴有一个交点, 可通过一下方程的求解得到这个交点x坐标: 

$$ f(x_0)=(x_0-x)f'(x_0) $$

求解这个方程可以得到: 

$$ x=x_0-f(x_0)/f'(x_0) $$

我们将新求得的点的x坐标命名为x1, 通常x1会比$f(x)=0$的解, 因此我们现在利用$x_1$开始下一轮迭代. 根据上述方程中$x_1$和$x_0$的关系, 可以得到一个求解x的迭代公式: 

$$ x_{n+1}=x_n-f(x_n)f'(x_n) $$

这就是牛顿迭代公式. 目前已经证明, 如果$f(x)$的一阶导函数$f'(x)$是连续函数, 并且待求的零点x是孤立的, 则在零点x周围存在一个区间, 只要初始值$x_0$位于这个区间, 牛顿法迭代必定收敛. 并且, 只要$f'(x) ≠ 0$, 牛顿迭代法将具有平方收敛的性能. 这意味着每迭代一次, 结果的有效数组将增加一倍, 这比二分逼近法的线性收敛速度快了一个数量级. 

### 示例

牛顿迭代法原理简单, 求根收敛速度快, 编制算法简单, 因此在计算机上获得广泛的应用. 

#### 导函数的求解与近似公式

牛顿迭代公式中需要计算的导数, 直接根据原函数退出已接到函数, 然后计算导函数的值有点困难, 一般都是利用导数的数学原理, 使用近似公式直接求函数在某一点的导数. 导数的数学定义是: 当函数$y=f(x)$的自变量x在一点$x_0$上产生一个增量△x, 函数输出的值得增量△y与自变量增量△x的比值在△x趋于0时的极限值. 如果这个极限值存在, 则这个值就是$f'(x_0)$. 用公式定义即为:

![](/img/funofAL/360截图1757111910192130.png)

我们在计算机中计算导数值使用下面的近似公式: 

![](/img/funofAL/360截图17040514636564.png)

#### 算法实现

根据牛顿迭代公式:

```js
function NewtonRaphson(f, x0) {
  let x1 = x0 - f(x0) / CalcDerivative(f, x0);
  while (fabs(x1 - x0) > PRECISION) {
    x0 = x1;
    x1 = x0 - f(x0) / CalcDerivative(f, x0);
  }

  return x1;
}
```

## 第十四章 计算几何与计算机图形学

### 计算集合的基本算法

#### 点与矩形的关系

Windows的API提供了`PtInRect()`函数, 实现方法其实就是判断点的x坐标和y坐标是否同时落在矩形的x坐标范围和y坐标范围内, 算法实现也很简单: 

```js
function IsPointInRect(rc,p){
    let xr=(p.x-rc.p1.x)*(p.x-rc.p2.x);
    let yr=(p.y-rc.p1.y)*(p.y-rc.p2.y);

    return ((xr<=0.0)&&(yr<=0.0))
}
```

这里本文所有的算法都是基于平面直角坐标系设计的. 另外, 默认系统浮点数的最大精度.

#### 矢量的基础知识

现在再考虑复杂一点, 如果按钮是个不规则的多边形区域呢? Windows提供了一个名为`PtInRegion()`的API用于判断点是否在一个不规则区域中. 我们对问题进行简化, 就是判断一个点是否在多边形内. 这是计算几何中的一个非常基本的算法, 最常用的方法是射线法. 

以P点为端点, 向左方做射线L, 然后沿L从无穷远处开始向P点移动, 当遇到多边形的某一条边时, 记为与多边形的第一个交点, 表示进入多边形内部, 继续移动, 当遇到另一个交点时, 表示离开多边形内部. 由此可知, 当L与多边形的交点是偶数时, 表示P点在多边形外, 当L与多边形交点个数是奇数时, 表示P点在多边形内部. 

##### 矢量的加法与减法:

$$ 
P+Q=(x_1+x_2,y_1+y_2) \\\
P-Q=(x_1-x_2,y_1-y_2)
$$

满足以下性质: 

$$
P+Q=Q+P\\\
P-Q=-(Q-P) 
$$

几何意义: 

![](/img/funofAL/360截图16780630436448.png)

##### 叉积

$$ PxQ=x_1\*y_2-x_2\*y_1 $$

几何意义描述为由原点(0,0),P,Q,P+Q所组成的平行四边形的面积, 而且带符号. 

具有以下性质:　它的方向是垂直于P与Q所在的平面, 并且按照P,Q与PxQ的次序构成右手系, 所以叉积的另一个非常重要性质是可以通过符号判断两个矢量之间位置关系是顺时针关系还是逆时针关系. 具体说明如下: 

(1) 如果PxQ>0, 则Q在P的逆时针方向;  
(2) 如果PxQ<0, 则Q在P的顺指针方向;  
(3) 如果PxQ=0, 则Q与P共线(相同或相反方向)

叉积实现的算法为: 

```js
function CrossProduct(x1,y1,x2,y2){
    return x1*y2-x2*y1;
}
```

##### 矢量的点积

点积(内积)定义为: 

$$ P·Q=x_1\*x_2+y_1*y_2 $$

矢量点积的结果是一个标量, 代数表示如下: 

$$ P·Q=|P||Q|cos(P,Q) $$

(P,Q)表示向量P和Q的夹角, 如果P和Q不共线, 则根据上式可以得到向量点积的一个非常重要的性质, 具体说明如下: 

1. 如果P·Q>0, 则P和Q的夹角是钝角
2. 如果P·Q<0, 则P和Q的交角是锐角
3. 如果P·Q=0, 则P和Q的夹角是90度

给定向量$P=(x_1,y_1)$, $Q=(x_2,y_2)$, 计算点积的算法实现为: 

```js
function DotProduct(x1,y1,x2,y2){
    return x1*x2+y1*y2
}
```

了解矢量的运算以后,就可以解决计算几何的各种问题了.

#### 点与直线的关系

根据矢量叉积的几何意义, 如果线段所表示的矢量和点的矢量的叉积为0, 就说明点在线段所在的直线上.

相对于坐标原点O来说, 线段的矢量其实就是线段点$P_2=[x_2,y_2]$的矢量$OP_2$减线段起点起点$P_1=[x_1,y_1]$的矢量$OP_1$的结果. 因此线段的矢量可以表示为$P_1P_2=(x_2-x_1,y_2-y_1)$. 如果要判断点P1是否在线段P1P2上, 就要判断矢量P1P2是否与矢量OP的叉积是否为0. 如果为0, 则说明点P与线段P1P2所在的直线共线, 但是不能说明P在P1P2区间上. 检查点P是否在以是线段为对角线的矩阵空间内, 如果以上两个条件为真, 即可判断点在线段上.  算法实现如下: 

```js
function IsPointOnLineSegment(ls,pt){
    let rc=GetLineSegmentRect(ls);//获取直线的矩阵包围盒
    let cp=CrossProduct()
}
```

#### 直线与直线的关系

矢量叉积计算在计算几何中的另一个用途是直线段求交. 求教算法是计算机图形学的核心算法, 也是体现速度与稳定性的重要标志, 搞笑并且稳定的求教算法是任何一个CAD软件都必须要关注的. 求交包含两层概念, 一个是判断是否相交, 另一个是求出交点. 直线的求交算法相对来说比较简单, 首选看看如何判断两直线相交. 

常规的代数计算通常分三步, 首先根据线段还原出两条线段所在直线的方程, 然后联立方程组求出交点, 最后再判断交点是否的线段区间上. 常规的代数方法非常繁琐, 每次都要解方程组求交点, 特别是交点不在线段区间的情况. 计算交点是无用功, 计算几何方法判断直线段是否有交点通常分为两个步骤: 快速排斥试验和跨立试验. 下面有个例子:

1. 快速排斥试验

假设线段P1P2的对角线矩阵为R1, Q1Q2的对角线矩阵为R2, 如果R1和R2不相交, 则线段不相交.

2. 跨立试验

如果两线段相交, 则两线段必然互相跨立对方. 所谓跨立, 指的是一条线段的两端点分别位于另一线段所在直线的两边. 判断是否跨立, 还是要用到矢量叉积的几何意义. 如下图所示:

![](/img/funofAL/360截图17350801117109138.png)

若P1P2跨立Q1Q2, 则矢量(P1-Q1)和(P2-Q1)位于矢量(Q2-Q1)的两侧, 即: 

$$ (P_1-Q_1)\times(Q_2-Q_1)*(P_2-Q_1)\times(Q_2-Q_1)<0 $$

或者写成: 

$$ (P_1-Q_1)\times(Q_2-Q_1)*(Q_2-Q_1)\times(P_2-Q_1)>0 $$

当$(P_1-Q_1)\times(Q_2-Q_1)=0$时, 说明想跳线段共线, 但是不一定有交点. 同理判断Q1Q2跨立P1P2的依据是: 

$$ (Q_2-P_1)\times(P_2-P_1)*(Q_2-P_1)\times(P_2-P_1)<0 $$

根据矢量叉积的几何意义, 跨立试验只能证明线段的两端点位于另一个线段所在直线的两边, 但是不能保证是在另一直线段的两端, 因此, 跨立试验只能证明两端西那段有交点的必要条件, 必须和快速排斥实验仪器才能组成只想爱你段相交的充要条件. 

根据上面的分析, 两条线段有交点的完整判断依据就是: 以两条线段为对角线的两个矩阵有交集; 两线段相互跨立. 

判断直线跨立计算叉积算法的`CrossProduct()`函数即可, 还需要一个判断两个矩形是否有交的算法. 矩形求交也是最简单的求交算法之一, 原理就是根据两个矩形的最大, 最小坐标判断. 馊味最大最小坐标判断, 就是在x坐标方向和y坐标方向分别满足最大值最小值法则, 简单解释这个法则就是每个矩形在每个方向上的坐标最大值都要大于另一个矩形在这个坐标方向上的坐标最小值, 否则在这个方向上就不能保证一定有位置重叠. 由以上分析, 判断两个矩形是否相交的算法可以如下实现: 

```js
//判断两个矩形是否相交
function IsRectIntersect(rc1, rc2) {
  return (
    Math.max(rc1.p1.x, rc1.p2.x) >= Math.min(rc2.p1.x, rc2.p2.x) &&
    Math.max(rc2.p1.x, rc2.p2.x) >= Math.min(rc1.p1.x, rc1.p2.x) &&
    Math.max(rc1.p1.y, rc1.p2.y) >= Math.min(rc2.p1.y, rc2.p2.y) &&
    Math.max(rc2.p1.y, rc2.p2.y) >= Math.min(rc1.p1.y, rc1.p2.y)
  );
}
```

有了这个算法, 直线相交判断的算法也就水到渠成: 

```js
//快速排斥试验
function IsLineSegmentExclusive(ls1, ls2) {
  let rc1 = GetLineSegmentRect(ls1);
  let rc2 = GetLineSegmentRect(ls2);
  return !IsRectIntersect(rc1, rc2);
}
//判断两条线段是否相交
function IsLineSegmentIntersect(ls1, ls2) {
  if (IsLineSegmentExclusive(ls1, ls2)) {
    //排斥实验
    return false;
  }
  //( P1 - Q1 ) × ( Q2 - Q1 )
  let p1xq = CrossProduct(
    ls1.ps.x - ls2.ps.x,
    ls1.ps.y - ls2.ps.y,
    ls2.pe.x - ls2.ps.x,
    ls2.pe.y - ls2.ps.y
  );
  //( P2 - Q1 ) × ( Q2 - Q1 )
  let p2xq = CrossProduct(
    ls1.pe.x - ls2.ps.x,
    ls1.pe.y - ls2.ps.y,
    ls2.pe.x - ls2.ps.x,
    ls2.pe.y - ls2.ps.y
  );

  //( Q1 - P1 ) × ( P2 - P1 )
  let q1xp = CrossProduct(
    ls2.ps.x - ls1.ps.x,
    ls2.ps.y - ls1.ps.y,
    ls1.pe.x - ls1.ps.x,
    ls1.pe.y - ls1.ps.y
  );
  //( Q2 - P1 ) × ( P2 - P1 )
  let q2xp = CrossProduct(
    ls2.pe.x - ls1.ps.x,
    ls2.pe.y - ls1.ps.y,
    ls1.pe.x - ls1.ps.x,
    ls1.pe.y - ls1.ps.y
  );

  //跨立实验
  return p1xq * p2xq <= 0.0 && q1xp * q2xp <= 0.0;
}
```

#### 点与多边形的关系

如何判断一个点是否在多边形内部? 根据射线法的描述, 其核心是求解从P点发出的射线与多边形的边是否有交点. 注意, 这里说的是射线, 而我们前面讨论的都是线段. 这里引入一种计算机解决问题时常用的建模思想, 引用了这种思想, 我们前面的方法就适用于此了: 根据问题域的规模和性质抽象简化模型. 

计算机不能表示真正的无穷大和无穷小, 处理的每一个数都有确定的值. 那我们如何表示一个射线呢? 我们需要简化问题的规模. 假设多边形的每个点的坐标都不会超过(-10000.0,+10000.0), 我们就可以吧问题域简化为这个区域内的一块小区域, 对于这块区域, 10000以上就是无穷远.

射线法的基本原理是判断P点发出的射线与多边形的交点个数, 交点个数是奇数表示P点在多边形内(包含在多边形边上), 正常当然没有问题, 需要考虑一些特殊情况: 

![](/img/funofAL/360截图17811218487047.png)

需要对这些特殊情况进行处理:

1. 如果点P在边P1P2上, 则直接判定点P在多边形内
2. 如果从P发出的射线正好穿过P1或P2, 那么这个交点会被算作两次(因为在处理以P1或P2为端点的其他边时可能已经计算过这个点了), 对于这种情况的处理原则是: 如果P的y坐标与P1,P2中较小的y坐标相同, 则忽略这个交点;
3. 如果从P发出的射线与P1P2平行, 则忽略这条边

对于第三点, 判断平行的方法一般是判断两条直线的斜率, 因为这里只涉及直线段, 判断直线时候水平只要比较一下线段起始点的y坐标是否相等就可以了, 二判断直线是否垂直也只要比较一下线段起始位置的x坐标是否相等就可以了

然后我们来根据下面的流程图来写出算法: 

![](/img/funofAL/360截图16720327116112137.png)

算法代码如下:

```js
function IsPointInPolygon(py, pt) {
    assert(py.IsValid()); /*只考虑正常的多边形，边数>=3*/

    let count = 0;
    let ll = new LineSeg(pt, Point(-INFINITE, pt.y)); /*射线L*/
    for (let i = 0; i < py.GetPolyCount(); i++) {
        /*当前点和下一个点组成线段P1P2*/
        let pp =new LineSeg(py.pts[i], py.pts[(i + 1) % py.GetPolyCount()]);
        if (IsPointOnLineSegment(pp, pt)) {
            return true;
        }

        if (!pp.IsHorizontal()) {
            if (IsSameFloatValue(pp.ps.y, pt.y) && pp.ps.y > pp.pe.y) {
                count++;
            } else if (IsSameFloatValue(pp.pe.y, pt.y) && pp.pe.y > pp.ps.y) {
                count++;
            } else {
                if (IsLineSegmentIntersect(pp, ll)) {
                    count++;
                }
            }
        }
    }

    return count % 2 == 1;
}
```

在图形学领域真正工程代码, 通常还会增加一个多边形的外包矩形快速判断, 对点根本不在多边形周边的情况做快速排出, 提高算法效率. 求多边形外包矩形也很简单, 就是遍历多边形的所有节点, 找出各个坐标方向上的最大最小值.

除了扫描线法, 还可以用过多边形的法矢量方向, 多边形面积以及角度和等方法判断点与多边形的关系. 但是这些算法要么只能支持凸多边形, 要么需要复杂的三角函数运算, 使用范围都不如扫描线法广泛. 

### 直线生成算法

在欧式几何空间中, 平面几何就是一个三元一次方程, 直线就是两个非平行平面的交线, 所以直线方程就是两个三元一次方程组联立. 但是在平面解析集合中, 直线的方程就简单多了:

- 一般式: $Ax+By+C=0(A,B 不同时为0)$
- 点斜式: $Y-Y_0=K(X-X_0)$
- 两点式: $\frac{Y-Y_0}{Y_1-Y_0}=\frac{X-X_0}{X_1-X_0}$

此外还有截距式, 斜截式等多种形式. 在计算机中如何展示直线图形是计算机图形学的重要内容, 也是这里要介绍的直线生成算法. 要理解直线生成算法, 首先要理解光栅图形和矢量图形.

#### 光栅图形扫描转换

在数学中直线是由没有宽度的点组成的集合, 但是在计算机图形学的范畴中, 所有的图形都是输出或显示在点阵设备上的, 被称为点成图形或光栅图形. 以我们常见的显示器为例, 可以看成各种颜色和灰度值的像素点组成的像素矩阵, 这些矩阵有大小, 而且位置固定, 因此只能显示近似的图形.

计算机图形学中的直线生成算法, 包含了两层意思, 一层是在解析几何空间中根据坐标构造出平面直线, 另一层就是在光栅显示器之类的点阵设备上初出一个最逼近于图形的像素直线, 而这就是常说的光栅图形扫描转换, 本节就介绍计算几种光栅扫描转换算法: 

##### 数值微分法

(DDA) 根据斜率确定以X步进或者Y步进. 沿步进方向每进一个点, 就沿另一个方向步进K个点. K为斜率. K不为整数时需要对结果圆整. 此外需要考虑直线方向, 也就是起点和终点的关系. 

```js
// 数值微分法(DDA)
function DDA_Line(x1, y1, x2, y2) {
    let k, dx, dy, x, y, xend, yend;
    dx = x2 - x1;
    dy = y2 - y1;
    if (Math.abs(dx) >= Math.abs(dy)) {
        k = dy / dx;
        if (dx > 0) {
            x = x1;
            y = y1;
            xend = x2;
        } else {
            x = x2;
            y = y2;
            xend = x1;
        }
        while (x <= xend) {
            SeDevicePixel(x, y);
            y=y+length;
            x=x+1;
        }
    }else{
        k = dx / dy; 
        if(dy > 0)
        {
            x = x1;
            y = y1;
            yend = y2;
        }
        else
        {
            x = x2;
            y = y2;
            yend = y1;
        }
        while(y <= yend) 
        {     
            SetDevicePixel(ROUND_INT(x), (int)y); 
            x = x + k; 
            y = y + 1; 
        } 
    }
}
```
数值微分法产生的直线比较精确, 而且逻辑简单, 易于用硬件实现, 但是步进量x,y和k必须用浮点数表示, 每一步都要对x或y进行四舍五入后取整, 不利于光栅化或点阵输出. 

##### Bresenham算法

Bresenham算法是一种单步直线生成算法, 是计算机图形学领域使用最广泛的直线扫描转换算法. 基本原理就是将光栅设备的隔行和列像素中心点连接起来构造一组虚拟网格线. 按直线从起点到终点的顺序计算直线与个垂直方向网格线的焦点, 然后确定该列像素中与此交点最近的像素. 

如下图所示: 

![](/img/funofAL/360截图170010209393130.png)

每个交点就代表点阵设备上的一个像素点, 现在就以图为例, 介绍一下这种算法. 

当算法从一个点(Xi,Yi)沿着X方向向前步进到Xi+1时, Y方向的下一个位置只可能是Yi和Yi+1两种情况, 到底是Yi还是Yi+1取决于它们与精确值y的距离d1和d2哪个更小. 

当d1-d2>0时, Y方向的下一个位置将是Yi+1, 否则就是Yi. 可见, Bresenham算法其实和数值微积分算法原理是一样的, 差别在于Bresenham算法中确定Y方向下一个点的位置的判断条件的计算方式不一样. 现在来分析一下这个判断条件的计算方式, 已知直线的斜率k和在y轴的截距b, 可推导出Xi+1位置的精确值y如下: 

$$ y=kX_{i+1}+b $$

将(14-9),(14-10)和上式带入d1-d2, 可得到下面的式子: 

$$ d_1-d_2=2kX_{i+1}-Y_i-Y_{i+1}+2b $$

根据条件: k = dy/dx, $Y_{i+1}=Y_i+1$, $X_{i+1}=X_i+1$, 将这三个关系熟带入到上面的式子中, 我们可以得到: 

$$ dx(d_1-d_2)=2dyX_i+2dy+2dxY_i+dx(2b-1) \tag{14-13} $$

设$P_i=dx(d_1-d_2)$, 则: 

$$ P_i=2dyX_i+2dy-2dxY_i+dx(2b-1) \tag{14-14} $$

在途中的示例中dx是大于0的值, 因此$P_i$的符号与(d1-d2)一致, 现在将初始条件带入可得到最初的第一个判断条件P_i:

$$ P_1=2dy-dx $$

根据$X_{i+1}$, 以及$Y_{i+1}$与$Y_i$的关系, 可以退出Pi的递推关系: 

$$ P_{i+1}=P_i+2dy-2dx(y+{i+1-y_i}) \tag{14-15} $$

$y_{i+1}$可能是$y_i$也可能是$y_i+1$, 因此, $P_{i+1}$也有两种对应的可能: 

![](/img/funofAL/360截图17760809393985.png)

根据推导, 当x2>x1, y2>y1时. Bresenham直线生成算法的计算过程如下: 

1. 画点(x1,y1), 计算误差初值P1=2dy-dx;
2. 求直线的下一点位置: $X_{i+1}=X_i+1$, 如果P_i>0, 则$Y_{i+1}=Y_i+1$, 否则$Y_{i+1}=Y_i$, 画点$(X_{i+1},Y_{i+1})$
3. 求下一个误差$P_{i+1}$. 如果Pi>0, 则$P_{i+1}=P_i+2(dy-dx)$, 否则$P_{i+1}=P_i+2dy$;
4. 如果没有结束, 到步骤2, 否则结束算法. 

下面给出算法实现(x2>=x1,y2>=y1):

```js

```