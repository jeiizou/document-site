# 处理概括关系

有这样一些重构手法专门用来处理类的概括关系(generalization, 即继承关系), 其中主要是将函数上下移动与继承体系之中. `Pull Up Field`和`Pull Up Method`都用于特性向继承体系的上端移动. `Push Down Method`和`Push Down Field`则用于将特性翔集成体系的下端移动, 构造函数比较难以向上拉动, 因此专门`Pull Up Constructor body`来处理它. 我们不会讲构造函数往下移动. 因为`Replace Constructor with Factory Method`通常会更有用. 

如果有若干函数大体上相同, 只是在细节上有所差异, 你可以使用`Form Template Method`将它们的共同点和不同点分开.

除了即继承体系中移动特性之外, 你还可以建立新类, 改变整个继承体系. `Extract Subclass`, `Extract Superclass`和`Extract Interface`都是这样的重构手法, 他们记载继承体系的不同位置构造出新元素. 如果你现在类型系统中标识一小部分函数, `Extract Interface`是特别有用的一个手法. 如果你发现继承体系中的某些类灭有群在的必要, 可以使用`Collapse Hierachy`将它们移除.

有时候你会发现继承并非最佳选择, 你实际上需要的是委托, 那么`Repalce Interitance with Delegation`可以帮助你把继承改为委托. 有时候你又会想要做反向修改, 此时就可以使用`Replace Delegation with Inheritance`. 

## 11.1 Pull　Up Field (字段上移)

现状: 两个子类拥有相同的字段

做法: 将该字段移到超类

### 动机

如果各子类是分别开发的. 或者是在重构过程中组合起来的, 你常会发现他们拥有重复特性, 特别是字段更容易重复. 这样的字段优势拥有近似的名字, 但也并非绝对如此. 判断若干字段是否重复, 唯一的办法就是观察函数如果使用它们, 如果它们被使用的方式很相似, 你就可以将它们归纳到超类去.

本项重构从两方面减少重复: 首先它去除了重复的数据声明; 其次它使可以将使用该字段的行为从子类转移到超类, 从而去除重复的行为. 

### 做法

- 针对待提升的字段, 检查它们所以的使用点, 确认它们以同样的方式被使用
- 如果这些字段的名称不同, 先将它们改名, 使每一个名称都和你想为超类字段取的名称相同
- 编译, 测试
- 在超类中新建一个字段
  - 如果这些字段是`private`的, 你必须将超类的字段声明为`protected`, 这样子类才能引用它. 
- 移除子类中的字段
- 编译, 测试
- 考虑对超类的新建字段使用`Self Encapsulate Field`

## 11.2 Pull Up Method (函数上移)

现状: 有些函数, 在各个子类中产生完全相同的效果

做法: 将该函数移动到超类


### 动机

避免行为重复是很重要的. 虽然重复的两个函数可以各自工作的很好, 但重复自身只会造成错误的滋生地, 此外毫无意义. 无论何时, 只要系统之内出现重复, 你就会面临"修改了其中一个却未能修改另一个"的风险. 通常, 找出重复也有一定的代价. 

如果某个函数的各子类中的函数体都相同, 这就是最简单的`Pull Up Method`适用场景. 

`Pull Up Method`常常紧随着其他重构而被使用, 也许你能找出若干身处不同子类内的函数, 而他们又可以通过某种形式的参数调整成为相同的函数. 这时候, 最简单的办法就是首先分别调整这些函数的参数. 然后再将它们概括到超类中. 当然, 你足够自信的话, 可以一次完成这两个步骤.

有一种特殊情况也需要使用`Pull Method`: 子类的函数覆写了超类的函数, 但却仍然做相同的工作.

`Pull Up Method`过程中最麻烦的一点就是: 被提升的函数可能会引用只出现与子类而不出现与超类的特性. 如果被引用的是个函数, 你可以将该函数也一起提升到超类, 或者在赵雷中建立一个抽象函数. 再次过程中, 你可能需要修改某个函数的签名, 或者建立一个委托函数.

如果两个函数相似而不相同, 你获取可以先借助`Form Template Method`造出相同的函数, 然后再提升他们

### 做法

- 检查待提升函数, 确定他们是完全一致的
  - 如果这些函数看上去做了相同的事, 但并不完全一致, 可使用`Subsitute Algorithm`让他们变得完全一致
- 如果待提升函数的签名不同, 讲那些签名都修改为你想要在超类中使用的签名
- 在超类中新建一个函数, 将某一个待提升函数的代码赋值到其中, 做适当调整, 然后编译.
  - 如果你使用的是一种强类型语言, 而带提升函数又调用了一个只出现于子类而未出现于超类的函数, 你可以在超类中为被调用函数声明一个抽象函数.
  - 如果带提升函数使用了子类的一个字段, 你可以使用`Pull Up Field`将该字段也进行提升; 或者也可以先使用`Self Encapsulate Field`, 然后再超类中把取值函数声明为抽象函数
- 移除一个待提升的子类函数
- 编译, 测试
- 逐一移除待提升的子类函数, 直到只剩下超类中的函数为止, 每次移除之后都需要测试.
- 观察该函数的调用者, 看那看那是否可以改为使用超类类型的对象

## 11.3 Pull Up Constructor Body (构造函数本体上移)

现状：你在各个子类中拥有一些构造函数, 他们的本体几乎完全一致

做法: 在超类中新建一个构造函数, 并在子类构造函数中调用它

### 动机

构造函数不是普通函数, 使用它们比起用普通函数受到更多的限制.

如果你看见各个子类中的函数有共同行为, 第一个念头应该是将共同行为提炼到一个独立函数中, 然后将这个函数提升到超类. 对构造函数而言, 它们彼此的共同行为往往就是"对象的". 这个时候你需要在超类中提供一个构造函数, 然后让子类都来调用它. 很多时候, 子类构造函数的唯一动作就是调用超类构造函数. 这里不能运用`Pull Up Method`, 因为你无法在子类中继承超类构造函数

如果重构过程过于复杂, 你可以考虑转而使用`Replace Constructor with Factory Method`.

### 做法

- 在超类中定义一个构造函数
- 将子类构造函数中的共同代码搬移到超类构造函数中
  - 被搬移的可能是子类构造函数的全部内容
  - 首先设法将共同代码搬移到子类构造函数起始处, 然后复制到超类构造函数中
- 将子类构造函数中的共同代码删掉, 改而调用新建的超类构造函数
  - 如果子类构造函数中的所有代码都是一样的, 那么子类的构造函数就只需要调用超类构造函数
- 编译, 测试
  - 如果日后子类构造函数再出现共同代码, 你可以首先使用`Extract Method`将那一部分提炼到一个独立函数, 然后使用`Pull Up Method`将该函数上移到超类. 

## 11.4 Push Down Method (函数下移)

现状: 超类中的某个函数只与部分(而非全部)子类有关

做法: 将这个函数移到相关的那些子类去. 

### 动机

`Push Down Method`与`Pull Up Method`恰恰相反. 当我有必要吧某些行为从超类一直特定的子类时, 我就使用`Push Down Method`, 它通常也只在这种时候有用. 使用`Extract Subclass`之后你可能会需要它. 

### 做法

- 在所有子类中声明该函数, 将超类中的函数本体复制到每一个子类函数中.
  - 你可能需要将超类的某些字段声明为`protected`, 让子类函数也能访问它们. 如果日后想要把这些字段下移到子类, 通常就可以那样做. 否则应该使用超类提供的访问行数, 并且如果访问函数并非public, 就把它声明为`protected`.
- 删除超类中的函数
  - 你可能必须修改调用端的某些变量声明或者参数声明, 一边能够使用子类
  - 如果有必要通过一个超类对象访问该函数, 或你不行吧该属性从任何子类中移除, 再或者超类是抽象类, 那么你就可以在超类中吧该函数声明为抽象函数
- 编译, 测试
- 将该函数从所有不需要它的那些子类中删掉
- 编译, 测试

## 11.5 Push Down Field (字段下移)

现状: 超类中的某个字段只被部分(而非全部)子类应用

做法: 将这个字段移到需要它的那些子类去. 

### 动机

`Push Down Field`与`Pull Up Field`相反: 如果只有某些子类需要超类中的一个字段, 就可以使用这项重构

### 做法

- 在所有子类中声明该字段
- 将该字段从超类中移除
- 编译, 测试
- 将该字段从所有不需要它的那些子类中删掉
- 编译, 测试

## 11.6 Extarct Subclass (提炼子类)

现状: 类中某些特性只被某些(而非全部)实例使用

做法: 新建一个子类, 将上面所说那部分特性转移到子类中. 

### 动机 

使用Extract Subclass的主要动机是: 你发现类中的某些行为只被一部分实例用到, 其他实例不需要它们. 有时候这种行为上的差异是通过类型码区分的, 此时你可以使用`Replace Type Code with Subclass`或者`Replace Type Code with State/Strategy`. 但是, 并非一定要出现了类型码才表示需要考虑使用子类

`Extract Class`是`Exreact Subclass`之外的另一种选择, 两者之间的抉择其实就是委托和继承之间的抉择. `Extract Subclass`通常更容易进行, 但它也有限制: 一旦对象完成创建, 你无法该改变与类型相关的行为. 但如果使用`Extract Class`, 你只需要插入另一个组件就可以改变对象的行为. 此外, 子类只能用以表现一组变化. 如果你希望一个类以几种不同的方式变化, 就必须使用委托

### 做法

- 为源类定义一个新的子类
- 为这个新的子类提供构造函数
  - 简单的额做法是: 让子类构造函数接受与超类构造函数相同的参数, 并通过`super`调用超类构造函数
  - 如果你希望对用户隐藏子类的存在, 可使用`Replace Constructor with Factory Method`
- 找出调用超类构造函数的所有地点, 如果它们需要的是新建的子类, 令他们改而调用新构造函数
  - 如果子类构造函数需要的参数和超类不同, 可以使用`Rename Method`修改其参数列. 如果子类构造函数不需要超类构造函数的某些参数, 可以使用`Rename Method`将他们去除
  - 如果不需要直接创建超类的实例, 就将超类声明为抽象类
- 逐一使用`Push Down Method`和`Push Down Fields`将源类的特性移到子类去. 
  - 和`Extract Class`不同, 先处理函数在处理数据通常会见一些. 
  - 当一个`public`函数被下移到子类后, 你可能需要重新定义该函数的调用端的局部变量或参数类型, 让他们改而调用子类中的新函数. 
- 找到所有这样的字段: 他们所传达的信息如今可由继承体系自身传达(这一类字段通常是boolean变量或者类型码). 以`SelfEncapsulate Field`避免直接使用这些字段, 然后将它们的取值函数替换为多态常量函数, 所有使用这些西段的地方都应该以`Replace Conditional with Polymorphism`重构
  - 任何函数如果位于源类之外, 而又使用了上述字段的访问函数, 考虑以`Move Method`将它移到源类中, 然后再使用`Replace Conditional with Polymorphism`
- 每次下移之后, 编译并测试. 

## 11.7 Extract Superclass (提炼超类)

现状: 两个类有相似特性

做法: 为这两个类建立一个超类, 将相同特性移至超类

### 总计

重复代码是系统中最坏的东西. 

重复代码的某种形式: 两个类以相同的方式做相似的事情. 对象提供了继承来简化这类工作. 但是, 在建立这些具有共通性的类之前, 你往往无法发现这样的共同性,, 因此经常会在有共通性的类出现之后, 再开始建立集成结构.

另一种选择就是`Extract Class`. 这两种方案之间的选择其实就是继承和委托之间的关系. 如果两个类可以共享行为, 也可以共享接口, 那么继承是比较简单的做法. 

### 做法

- 为原本的类新建一个空白的抽象超类
- 运用`Pull Up Field`,`Pull Up Constructor Body`逐一将子类的共同元素上移到超类
  - 先搬移字段, 通常比较简单
  - 如果相应的子类函数有不同的签名, 可以先进行签名的修改, 然后再提取方法
  - 如果相应的子类函数有相同的签名, 却有不同的内容, 可以再超类中把他们的共同签名声明为抽象函数. 
  - 如果相应的子类函数有不同的函数本体, 但是用途相同, 可以试着使用`Substitute Algorithm`把其中一个函数的函数本体赋值到另一个函数中. 如果运转正常, 就可以使用`Pull Up Method`.
- 每次上移后, 编译并测试
- 检查留在子类中的函数, 看他们是否还有共通部分. 如果有, 可以使用`Extract Method`将共通部分再提炼出来, 然后使用`Pull Up Method`将提炼出来的函数上移到超类. 如果子类中某个函数的整体流程相似, 则可以使用`Form Template Method`.
- 将所有共通元素都上移之后, 检查子类的所有用户. 如果它们只使用共通接口,就可以把他们的请求的对象类型改为超类

## 11.8 Extract Interface (提炼接口)

现状: 若干客户使用类接口中的同一自己, 或者两个类的接口有部分相同

做法: 将相同的子集提炼到一个独立接口中


### 动机

类之间彼此互用的方式有若干种. "使用一个类"通常意味着用到该类的所有责任区. 另一种情况是,  某一组客户只使用类责任区中的一个特定自己. 再一中情况则是, 这个类需要与所有协助处理某些特定请求的类合作.

对于两种情况, 将真正用到这部分责任分类出来通常比较有意义: 这可以是系统的统发更清晰, 同时也更容易看清系统的责任划分. 如果新的类需要支持上述子集, 也比较能够看清子集内有些什么东西. 

在许多面向对象语言中, 这种责任划分是通过多继承来实现的. 你可以针对每组行为建立一个类, 再将它们组合与同一个实例. java只提供单继承, 但是可以运用接口来昭示并实现上述需求. 接口对于java程序的设计方式有着巨大的影响.

`Extract Superclass`和`Extract Interface`之间有些相似之处. `Extract Interface`只能提炼共通接口, 不能提炼共通代码, 使用`Extract Interface`可能造成重复. 幸运的是可以通过`Extract Class`吧共通行为放进一个组件中, 然后工作委托该组件, 从而解决这个问题. 

如果某个类在不同环境下判断不同的角色, 使用接口就是个好主意, 你可以针对每个角色以`Exytact Interface`提炼出相应接口. 另一种可以用上`Extract Interface`的情况是: 你想要描述一个类的外部依赖接口. 如果你打算将来加入其它种类的服务对象, 只需要求它们实现这个接口即可

### 做法

- 新建一个空接口
- 在接口中声明待提炼的共通操作
- 让相关的类实现上述接口
- 调整客户端的类型声明, 令其使用接口

## 11.9 Collapse Hierarchy (折叠继承体系)

现状: 超类和子类之间无太大区别

做法: 将他们合为一体

### 动机

继承体系很容易变得过分复杂. 重构继承体系, 往往会将函数和字段在体系中上下移动. 完成这些动作后, 你可以发现某个子类并未带来该有的价值, 因此需要把超类和子类合并起来. 

### 做法


- 选择你想一出的类: 超类或者子类
- 使用`Pull Up Field`, `Pull Up Method`, `Push Down Method`桌和`Push Down Field`, 把想要移除的类的行为和数据搬移到另一个类. 
- 每次调整后, 编译并测试
- 调整即将被移除的那个类的所有引用点, 令他们改而引用合并后留下的类. 这个动作将会影响变量的声明, 参数的类型以及构造函数
- 移除我们的目标; 此时它应该只是一个空类
- 编译, 测试

## 11.10 Form Template Method (塑造模板函数)

现状: 你有一些子类, 其中相应的某些函数以相同顺序执行类似的操作, 但各个操作的细节上有所不同.

做法: 将这些操作分别放进独立函数中, 并保持它们都有相同的签名, 于是源函数也就变得相同了, 然后将源函数上移到超类

### 动机

继承是避免重复行为的一个强大工具. 无论何时, 只要你看见两个子类之中有类似的函数, 就可以把他们提升到超类. 但是如果这些函数并不完全相同该如何做. 我们仍有必要尽量避免重复, 但又必须保持这些函数之间的实质差异.

常见的一种情况是: 两个函数以相同顺讯执行大致相近的操作, 但是个操作不完全相同. 这种情况下, 我们可以将执行操作的序列移动到超类, 并借助多态保证各操作仍然得以保持差异性. 这样的函数被称为`Template Method`(模板函数)

### 做法

- 在各个子类中分别目标函数, 使分解后的各个函数要不完全系统, 要不完全不同
- 运用`Pull Up Method`将各个子类内完全相同的函数上移至超类.
- 对于那些(剩余的, 存在于各自类内的)完全不同的函数, 实施`Rename Method`, 使所有这些函数的签名完全相同
  - 这将使得源函数变为完全相同, 应为他们都执行同样的一组函数调用;但各子类会议不同方式响应这些调用
- 修改上述所有签名后, 编译并测试
- 运用`Pull Up Method`将所有源函数注意上移至超类, 在超类中将那些代表各种不同操作的函数定义为抽象函数
- 编译, 测试
- 移除其他子类中的源函数, 每删除一个, 编译并测试

## 11.11 Replace Ingeritance with Delegation

现状: 某个子类只使用超类接口中的一部分, 或者根本不需要继承而来的数据

做法: 在子类中新建一个字段用以保存超类; 调整子类函数, 令它改而委托超类; 然后去掉两者之间的继承关系.

### 动机

继承是个好东西, 但是有时候它并不是你要的. 比如: 一开始继承了一个类, 最后发现超类中的许多操作并不真正适用于子类. 这种情况下, 你所拥有的接口并未真正反映出子类的功能. 或者, 你可能发现你从超类中继承了一堆不需要的数据, 抑或你可能发现超类中的某些`protected`函数对子类并没有什么意义. 

你可以选择接口: 子类只使用超类的一部分功能. 但是这样会造成代码意图的欢笑.

如果以委托取代继承, 你可以更清楚的表示: 你只需要受托类的一部分功能. 接口中的哪一部分应该被使用, 哪一部分应该被忽略, 完全逗你决定. 成本在于需要额外写出委托函数, 但这些函数都非常简单, 不容易出错. 

### 做法

- 在子类中新建一个字段, 使其引用超类的一个实例, 并将它初始化为`this`
- 修改子类内的所有函数, 让他们不再使用超类, 转而使用上述那个受托字段.
- 每次修改后, 编译并测试
  - 你不能这样修改子类中通过`super`调用超类函数的代码, 否则他们会陷入无线递归. 这种函数只有在继承关系被打破后才能修改/
- 去除两个类之间的继承关系, 新建一个受托类的对象赋给受托字段
- 针对客户端所用的每一个超类函数, 为它添加一个简单的委托函数.
- 编译, 测试


## 11.12 Replace Delegation with Inheritance (以继承取代委托)

现状: 你在两个类之间使用委托关系, 并经常为整个接口编写许多极简单的委托函数

做法: 让委托类继承受托类

### 动机

这次的重构与上节恰恰相反. 如果你发现自己需要使用受托类中的所有函数, 并且废了很大气力编写所有极简的委托函数, 本重构可以帮助你轻松回头使用继承.

两条告诫: 

1. 如果你并没有使用受托类的所有函数, 那么就不应该使用`Replace Delegation With Ingeritance`. 因为子类应该松狮遵循超类的接口. 如果过多的委托函数让你烦躁, 可以选择`Remove Middle Man`让客户自己调用受托函数, 也可以使用`Extract Superclass`将两个类接口相同的部分提炼到超类中, 然后让两个类都继承这个新的超类; 你还可以用类似的手法使用`Extract Interface`.
2. 另一种需要当心的情况是: 受托对象不止一个其他对象共享, 而且受托对象是可变的. 这种情况下, 你不能将委托关系替换为继承关系. 否则就无法共享数据了. 数据共享是必须由委托关系承担的一种责任, 你无法把它转给继承关系. 如果受托对象时不可变的. 数据共享就没有问题. 因为你大可放心的复制对象.

### 做法

- 让委托端成为受托端的一个子类
- 编译
  - 此时, 某些函数可能会发生冲突: 他们可能有相同的名称, 但在返回类型, 异常指定或可见程度方面有所差异, 你可以使用`Rename Method`解决此类问题. 
- 将受托字段设为该字段所处对象本省
- 去掉简单的委托函数
- 编译并测试
- 将所其他设计委托关系的代码, 改为对象自身
- 移除受托字段. 

