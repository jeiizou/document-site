# 重新组织数据

本章将介绍几个可以让我们轻松处理数据的重构手法. 很多人或许会认为`self Encapsilar Field`是多余的, 但是关于"对象应该直接访问其中的数据, 抑或应该通过访问函数来访问"这一问题的讨论却从未停止. 有时候我们确实需要访问函数, 此时就可以通过`SelfEncapsulate`得到他们. 通常我会选择"直接访问", 因为你可以在后续的任何时候来进行这项重构. 

面向对象语言除了允许使用传统语言提供的简单数据类型, 还允许我们定义新的数据类型. 假定在一开始的时候你会使用一个简单数据来表示某个概念, 但是随着系统的发展, 你会发现使用对象来表示这个概念可能是更合适的. `Replace Value with Object`让你可以将"哑"数据编程善于表达的对象. 如果你发现程序中有太多地方需要这样一类对象, `Change Value Reference`是个不错的手法. 

如果你看到一个数组的行为方式很像一个数据接口, 就可以用`Replace Array with Obeject`把数组变成对象. 从而使这个数据结构更清晰的显露. 当然后续使用`move method`等各种重构手法, 会使得这个优势越发强大. 

魔法数(一种带有特殊含义的数字), 从来一个令人头疼的问题. 我还清楚的记得, 一来是学习编程的时候, 就不要轻易的使用魔法数. 因此我们应该用`Replace Magic Number with Symbolic Constant`将它们除掉, 以绝后患. 

对象之间的关联可以是单向的, 也可以是双向的. 单向关联比较简单, 但有时为了支持一项新功能, 你需要使用`Change Unidirectional Assiciation to  Bidirectional`将它编程双向关联; `Change Bidirectional Assiciation to Unidirectional`则刚好相反: 如果你不再需要双向关联, 可以使用这项重构将它编程单向关联. 

我常常遇到这样的情况: GUI类竟然去处理不该他们处理的业务逻辑, 为了吧这些处理业务逻辑的行为移到合适的领域类中去, 我们需要在领域类中保存这些逻辑相关数据, 并运用`Duplicate Observed Data`提供对GUI的支持. 一般来说, 我不喜欢重复的数据, 但这是一个例外, 因此这里的重复数据通常是不可避免的. 

面向对象编程的关键原则之一就是封装. 如果一个类公开了任何public数据, 你就应该使用`Encapsulate Field`将它郑重的封装起来. 如果公开的数据是一个集合, 就应该使用`Encapsulate Collection`, 因为集合有其特殊协议. 如果一整条的记录都被裸露在外, 就应该使用`Replace Record with Data Class`.

需要热别对象的一种数据是类型吗, 这是一种特殊数值, 用来指出"与实力所属之类型相关的某些东西", 并且通常以`static final`整数实现. 如果这些类型码用来表现某种信息, 并且不会改变所属类型的行为, 你可以用`Replace Type Code with Class`将它们替换掉. 这项重构可以提供更好的类型检查, 以及一个更好的平台, 是你可以在未来更方便的将相关行为添加进去. 另外, 如果当前类型的行为受到类型吗的影响, 你就应该尽可能的使用`Replace Type Code with Subclasses`, 如果做不到, 只好使用更复杂和灵活的`Replace Type Code with State/Strategy`


## 8.1 Self Encapsilar Field (自封装字段)

你直接访问一个字段, 但与字段之间的耦合关系逐渐变得笨拙.

**为这个字段建立取值/设值函数, 并且只以这些函数来访问字段.**

```ts
private _low,_high;
public includes(arg){
    return arg >= this._low && arg <= this._high;
}

// => Self Encapsilar Field
private _low,_high;
public includes(arg){
    return arg >= this.getLow() && arg <= this.getHigh();
}
public getLow(){
    return this._low;
}
public getHigh(){
    return this._high;
}
```

### 动机

在"字段访问函数"这个问题上, 存在两种截然不同的观点: 其中一方认为, 在该变量定义所在的类中, 你可以自由访问他; 另一方认为, 即使在这个类中你也应该只通过访问函数去间接访问. 

归根结底, 间接访问变量的好处是子类可以通过覆盖一个函数而改变获取数据的方式, 它还支持更加灵活的数据管理方式, 例如初始延迟化. 

直接访问变量的好处是: 代码比较容易阅读. 阅读代码的时候, 你不需要停下来去寻找函数的访问位置. 

面临选择是, 我们可以做两手准备. 通常情况下, 我们可以按照其他人的方法来处理. 

当然也可以在后续的修改中通过重构手法去改变这些行为.

### 做法

- 为待封装字段建立取值/设置函数
- 找出该字段的所有引用点, 将它们全部改为调用取值/设值函数. 
  - 如果引用点要读取字段值, 就将它替换为调用取值函数; 如果引用点要给字段赋值, 就将它替换为调用设置函数.
  - 你可以暂时将该字段改名, 让编译器帮助你查找引用点.
- 将该字段声明为private
- 复查
- 编译, 测试

## 8.2 Replace Data with Object (以对象取代数据值)

你有一个数据项, 需要与其他数据和行为一起使用才有意义. 

将数据项变为对象. 

### 动机

开发初期, 你往往决定以简单的数据项表现简单的情况. 但是, 随着开发的进行, 你可能会发现, 这些简单数据项不再简单. 比如说一开始你可能用一个字符串来表示电话号码, 后续则可能需要格式化来表示抽取区号之类的特殊行为. 因此需要把这个简单数据优化为简单对象. 

### 做法

- 为待替换的数值建立一个新类, 在其中声明一个final字段, 其类型和源类中的待替换数值类型一致. 然后再新类中加入这个字段的取值函数, 再加上一个接受此字段为参数的构造函数
- 编译
- 将源类中的待替换数值字段的类型改为前面新建的类. 
- 修改源类中该字段的取值函数, 令它调用新类的取值函数
- 如果源类构造函数中用到这个待替换字段, 我们就修改构造函数, 令它该用新类的构造函数对字段进行赋值动作
- 修改源类中的待替换字段的设置函数, 令它为新类创建一个实例
- 编译, 测试
- 现在, 我们可能需要对新类只用`Change Value to Reference`.


## 8.3 Change Value to Reference (将值对象改为引用对象)

你从一个类衍生出许多彼此相等的实例, 希望将他们替换为同一个对象

**将这个值对象变成引用对象**

### 动机

在许多系统中, 你都可以对对象做一个有用的分类: 引用对象和值对象. 前者就像是"客户","账户"这样的东西, 每个对象都代表真实世界中的一个实例, 你可以直接以相等操作符来检查两个对象是否相等. 后者则是像"日期","钱"这样的东西, 他们完全由所含的数据值来定义, 你并不在意副本的存在, 系统中可能会存在上千个一样的值. 当然我们也会比较两个值对象是否相等, 所以我们需要使用`equals()`方法来进行判断. 

在引用对象和值之间进行判断并不容易, 有时候, 我们可能会从一个简单的值对象开始, 但是对着代码的发展, 比如你希望给这个对象加入一些可修改数据来确保对任何一个对象的修改都能影响到所有引用此一对象的地方, 这种时候, 你就需要把这个对象变成一个引用对象.

### 做法

- 使用`Replace Constructor with Factory method`
- 编译, 测试
- 决定由什么对象负责提供访问新对象的途径
  - 可能是一个静态字典或者一个注册表对象
  - 你也可以使用多个对象作为新对象的访问点
- 决定这些引用对象应该预先创建好, 或是应该动态的创建
  - 如果这些引用对象时预先创建好的, 而你必须从内存中将他们读取出来, 那么慢就要确保他们在被需要的时候能够及时的被加载.
- 修改工厂函数, 令它返回引用对象
  - 如果对象时预先创建好的, 你就需要考虑: 万一有人索求一个其实并不存在的对象, 如何处理错误
  - 你可能希望对工厂函数使用`Rename Method`, 使其传达这样的信息: 它返回的是一个既存对象.
- 编译, 测试

## 8.4 Change Reference to Value (将引用对象改为值对象)

你有一个引用对象, 很小且不可变, 而且不易管理.

**把它变成一个值对象**

### 动机

正如在`Change Value to Reference`中所说, 要在引用对象和值对象之间选择, 有时候并不容易. 因此作出选择后, 你常会需要一条回头路. 

如果引用对象开始变得难以使用, 也许就应该将它改为值对象. 引用对象必须被某种方式控制, 你总是必须向其控制者请求适当的引用对象. 他们可能造成内存区域之间错综复杂的关联. 在分布系统和并发系统中, 不可变的值对象特别有用. 因为你不需要考虑他们的同步问题. 

值对象有一个非常重要的特性: 它们应该是不可变的. 无论何时, 只要你调用同一对象的同一个查询函数, 都应该得到同样的结果. 如果保证了这一点, 就可以放心的以多个对象表示同一个事物. 如果值对象是可变的, 你就必须确保对某一对象的修改会自动更新其他"代表相同事物"的对象, 这太痛苦了, 与其如此还不如把它变成引用对象. 

这里必须要澄清一下"不可变"的意思, 如果你以`Money`类表示"钱"的概念, 其中有"币种"和"金额"两个信息, 那么Money对象通常是一个不可变的值对象. 这并非一味这你的薪资不能改变, 而是意味着如果要改变你的薪资, 就需要使用另一个Money对象来取代现有的Money对象, 而不是在现有Money对象上修改. 你和Money对象之间的关系可以改变, 但是Money对象自身不能改变. 

### 做法

- 检查重构目标是否为不可变对象, 或者是否可修改为不可变对象
  - 如果该对象目前还不是不可变的, 就使用`Remove Setting Method`, 直到他变成不可变的为止.
  - 如果无法将该对象修改为不可变的, 就放弃使用本项重构
- 建立`equals()`和`hashCode()`
- 编译, 测试
- 考虑是否可以删除工厂函数, 并将构造函数声明为`public`


## 8.5 Replace Array with Obejct (以对象取代数组)

你有一个数组, 其中的元素各自代表不同的东西

**以对象替换数组, 对于数组中的每个元素, 以一个字段来表示**

```ts
let row=new String(3);
row[0]="Liverpool";
row[1]="15"

// => Replace Array with Object
let row=new Performance();
row.setName('Liverpool');
row.setWins("15");
```

### 动机

数组是一种常见的用意组织数据的结构. 不过, 它们应该只用于"以某种顺序容纳一组相似对象". 有时候你会发现, 一个数组容纳了多种不同对象, 这会给用户来带麻烦. 对象就不一样了, 你可以借助字段和函数来简单的表示不同的讯息.

### 做法

- 新建一个类表示数组所拥有的信息, 并在其中以一个public字段保存原来的数组.
- 修改数组的所有用户, 让它们改变新类的实例
- 编译, 测试
- 注意为数组元素添加函数并且进行合理的命名, 修改客户代码, 让他们通过函数访问数组中的元素, 每次都进行编译和测试.
- 当所有对数组的直接访问都转而调用访问函数后, 将新类中保存数组的字段声明为private
- 编译
- 对于数组内的每一个元素, 在新类中创建一个类型相当的字段. 修改该元素的访问函数, 令它改用新的字段.
- 每修改一个元素, 编译并测试
- 数组的所有元素都有了相应的字段之后, 删除该数组.

## 8.6 Duplicate Observed Data (复制"被监视数据")

你有一些领域数据置身于GUI空间中, 而领域函数需要访问这些数据. 

**将改数据赋值到一个领域对象中, 建立一个Observer模式, 用以同步领域对象和GUI对象内的重复数据**

### 动机

一个分层良好的系统, 应该将处理用户界面和处理业务逻辑的代码分开. 理由如下:

1. 你可能会使用不同的用户界面来表现相同的业务逻辑, 如果同时承担两种责任, 用户界面会变得过分复杂
2. 与GUI隔离之后, 领域对象的维护和演化都会变得很容易, 你甚至可以让不同的开发者负责不同部分的开发

尽管可以轻松的将"行为"划分到不同部位, "数据"却往往不能如此. 同一项数据有可能急需要内嵌于GUI空间, 也需要保存于领域模型数据中. 自从MVC模式出现后, 用户界面框架都使用多层系统来提供某种机制, 使你不但可以提供这类数据, 并保持它们同步. 

如果你遇到的代码是以两层方式开发, 业务逻辑被内嵌于用户界面之中, 你就有必要将行为分离出来. 其中的主要工作就是函数的分解和搬移. 但是数据部分就不同了, 你不能仅仅只是移动数据, 必须将它复制到新的对象中, 并提供相应的同步机制. 

### 做法

- 修改展现类, 使其成为领域类的Observer[Gof]
  - 如果尚未有领域类, 就建立一个
  - 如果没有"从展现类到领域类"的关联, 就将领域类保存于展现类的一个字段中.
- 针对GUI类中的领域数据, 使用`Self Encapsilar Field`.
- 编译, 测试
- 在事件处理函数函数中, 直接更新GUI组件:
  - 在事件处理函数中放一个设置函数, 利用它将GUI组件更新为领域数据的当前值. 当然这其实没有必要, 你只不过拿它的值设定它自己, 但是这样使用设置函数, 便是允许其中的任何动作得以与日后被执行起来. 这是这一步的意义所在
  - 进行这个改变时, 对于组件, 不要使用取值函数, 应该直接取用, 因为稍后我们将修改取值函数, 使其从领域对象取值. 设置函数也将做类似修改
  - 确保测试代码能触发新添加的事件处理机制
- 编译, 测试
- 在领域类中定义数据及其相关访问函数
  - 确保领域类中的设置函数能够触发Observer模式的通报机制
  - 对于被观察的数据, 在领域类中使用与展现类所用的相同类型来保存, 后续重构中你可以自由改变这个数据类型
- 修改展现类中的访问函数, 将他们的操作对象改为领域对象
- 修改Oberver的update, 使其从相应的领域对象中所需数据复制给GUI组件. 
- 编译, 测试

## 8.7 Change Unidirectional Association to Bidirectional (将单向关联改为双向关联)

两个类都需要使用对象特性, 但其间只有一条单向连接

**添加一个反向指针, 并使修改函数能够同时更新两条连接**

### 动机

开发的初期, 你可能会在两个类之间建立一条单向连接, 使其中一个类可以引用另一个类, 随着时间推移, 你可能发现被引用的类需要得到其引用者来处理一些逻辑. 

通常我们可以在被引用类中建立一个函数专门负责此一行为. 但是, 有时候想绕过这个问题并不容易, 此时就需要建立双向引用关系, 或称为反向指针. 如果使用不当, 反向指正会造成混乱; 但是你要你习惯了这种手法, 他们其实并不是太复杂. 

"反向指针"的手法有点棘手, 所以在你能自如运用之前, 应该有相应的测试. 通常我不花心思去测试访问函数, 因为普通访问函数的风险没有高到需要测试的地步, 但本重构要求测试访问函数, 所以它是极少数需要添加测试的重构手法之一

本重构运用反向指针实现双向关联, 其他技术(例如连接对象)需要其他重构手法.

### 做法

- 在被应用类中增加一个字段, 用以保存反向指针
- 决定由哪个类--引用端还是被引用端--控制关联关系
- 在被控端建立一个辅助函数, 其命名应该清楚指出它的有限用途
- 如果既有的修改函数在控制端, 让它负责更新反向指针
- 如果基友的修改函数在被控端, 就在控制端建立一个控制函数, 并让既有的修改函数调用这个新建的控制函数


## 8.8 Change Bidirectional Association to Unidirectional (将双向关联改为单向关联)

两个类之间有双向关联, 但其中一个类如今不在需要另一个类的特性

**去除不必要的关联**

### 动机

双向关联很有用, 但你也必须为它付出代价, 那就是维护双向链接, 确保对象被正确创建和删除而增加的复杂度. 而且, 由于许多程序员并不习惯使用双向关联, 往往容易造成很多错误.

大量的双向连接也很容易造成"僵尸对象": 某个对象本来已经死亡了, 却任然保留在系统中, 因为对它的应用还没有完全清除.

此外, 双向关联也迫使两个类之间有了依赖: 对其中任一个类的任何修改都可能会引发另一个类的变化. 如果这两个类位于不同的包, 这种依赖就变成了包与包之间的依赖. 过多的挎包依赖就会造成紧耦合系统, 使得任何一点小小改动都可能造成许多无法预知的后果. 

只有在真正需要双向关联的时候, 才应该使用它. 如果发现双向关联不在有存在的价值, 就应该去掉其中不必要的关联

### 做法

- 找出保存"你想要去除的指针"的字段, 检查它的每一个用户, 判断是否可以去除该指针. 
  - 不但要检查直接访问点, 也要检查调用这些直接访问点的函数
  - 考虑有误可能不通过指针取得被引用对象, 如果有可能, 你就可以对取值函数使用`Substitute Algorithm`, 从而让客户在没有指针的情况下也可以使用该取值函数
  - 对于使用该字段的所有函数, 考虑将被引用对象作为参数传递进去
- 考虑客户使用了取值函数, 先运用`Self Encapsulate Field`将待删除字段自我疯转, 然后使用`Substitute Algorithm`对付取值函, 令他不再使用该字段, 然后编译, 测试. 
- 如果客户并未使用取值函数, 那就直接修改待删除字段的所有被引用点, 然后移除该字段
  - 如果有许多地方对此字段赋值, 先运用`Self Encapsulate Field`使这些地点改用同一个设置函数, 编译, 测试, 而后将这个设置函数的本体清空, 在编译, 在测试. 如果这些都可信, 就可以将此字段和其设置函数, 联通对设值函数的所有调用, 全部移除
- 编译, 测试

## 8.9 Replace Magic Number with Symbolic Constant (以字面常量取代魔法数)

你有一个字面数值, 带有特别含义

**创造一个常量, 根据其意义为它命名, 并将上述的字面数值替换为这个常量**

```ts
function potentialEnergy(mass:number,hieght:number){
  return mass * 9.81 * hieght;
}

// => 重构
function potentialEnergy(mass:number,hieght:number){
  return mass * GRAVITATIONAL_CONSTANT * height;
}

const GRAVITATIONAL_CONSTANT=9.81;
```

### 动机

在计算科学中, 魔法数是历史最悠久的不良现象之一. 所谓魔法数是指拥有特殊意义, 但是有不能明确表示出这种意义的数字, 如果你需要在不同的地点引用同一个逻辑数, 魔法数会让你感到困惑. 

常量是一个很好的办法. 

在进行常量话重构之前, 应该先探寻其他方案. 观察魔法数是如何被使用的, 往往能发现一种更好的重构手法, 比如使用对象代替数值. 

### 做法

- 声明一个常量, 令其值为原本的魔法数
- 找出这个魔法数的引用点
- 检查是否可以使用这个新声明的常量来替换该魔法数. 如果可以, 替换之.
- 编译
- 所有魔法数被替换, 编译, 测试.


## 8.10 Encapsulate Field (封装字段)

你的类中存在一个public字段

**将它声明为private, 并提供相应的访问函数**

```ts
public _name:string;

//=>重构
private _name:string;
public getName():string{
  return this._name;
}
public setName(arg:string){
  this._name=arg;
}
```

### 动机

面向对象的首要原则之一就是封装, 或者叫"数据隐藏". 按此原则, 你不能将数据声明为`public`, 否则其他对象就有可能访问甚至修改这项数据, 而拥有该数据的对象却毫无察觉. 于是, 数据和行为就被分开了. 

数据声明为`public`被看做是一种不好的做法, 因为这样会降低程序的模块化程度. 数据和使用改数据的行为如果集中在一起, 一旦发生变化, 修改起来会比较简单. 

`Encapsulate Field`是封装过程的第一步. 通过这项重构手法, 可以吧数据隐藏起来, 并提供相应的访问函数. 其后可以使用其他重构手法继续对类对象进行合理的重构.

### 做法

- 为`public`字段提供取值/设置函数
- 找到这个类以外使用该字段的所有地点. 并且替换为相应的取值/设置函数.
  - 如果这个字段是个对象, 而客户仅仅是调用该对象的某个函数, 那么无论该函数是否改变对象状态. 都只能读取该字段. 只有当客户为该字段赋值的时候, 才能将其替换为设置函数. 
- 每次修改之后. 编译并测试
- 将字段的所有用户修改完毕后, 把字段声明为`private`
- 编译, 测试

## 8.11 封装集合

有个函数返回一个集合

**让这个函数返回该集合的一个只读副本, 并在这个类中提供添加/移除集合元素的函数.**

### 动机

我们常常会在一个类中使用集合来保存一组实例. 这样的类通常也会提供针对该集合的取值/设值函数.

但是, 集合的处理方式应该和其他种类的数据略有不同. 取值函数不该返回集合自身, 因为这会让用户得以修改集合内容而集合的拥有者一无所知. 这也会对用户暴露过多对象内部数据接口的信息. 如果一个取值函数确实需要返回多个值. 它应该避免用户直接操作对象内所保存的集合, 并隐藏对象内与用户无关的数据结构. 至于如何做到这一点, 看使用的语言. 

另外, 不应该为这个整个集合提供一个设置函数, 但应该提供用以为集合添加/移除元素的函数. 这样, 集合拥有者就可以控制集合元素的添加和移除. 

### 做法

- 加入为集合添加/移除元素的函数
- 将保存集合的字段初始化为一个空集
- 编译
- 找出集合设值函数的所有调用者. 你可以修改那个设值函数, 让它使用上述建立的"添加/移除元素"函数, 也可以直接修改调用端, 该让他们调用这些函数
  - 两种情况下, 需要用到集合设置函数: 1. 集合为空时; 2. 准备将原有集合替换为另一个集合时
  - 你或许会想用`Rename Method`为集合设置函数改名: 从`setXXX()`改为`initializeXXX()`或者`replaceXxx()`
- 编译, 测试
- 找出所有"通过取值函数获得集合并修改其内容"的函数. 逐一修改这些函数, 让他们改用添加/移除函数. 每次修改之后, 编译并测试
- 修改完上述所有的"通过取值函数获得集合并修改其内容"的函数后, 修改取值函数自身, 使他返回集合的一个只读副本.
- 编译, 测试
- 找出取值函数的所有用户, 从中找出应该存在于集合所属对象内的代码, 运用`Extract Method`和`Move Method`将这些代码移到宿主对象去
- 修改现有取值函数的名字, 然后添加一个新的取值函数, 使其返回一个枚举. 找出旧取值函数的所有被使用点. 将他们都改为使用新取值函数
- 如果这一步的跨度太大, 可以先使用`Rename Method`修改原取值函数的名称; 再建立一个新取值函数用以返回枚举; 最后再修改所有调用者, 使其调用新取值函数.
- 编译并测试

## 8.12 Replace Record with Data Class (以数据类取代记录)

你需要面对传统编程环境中的记录结构

为该记录创建一个"哑"数据对象. 

### 动机

记录性接口是许多编程环境的共同性质. 有一些理由使他们被带进面向对象程序之中: 你可能面对是一个遗留程序, 也可能需要通过一个传统API来记录结构交流, 或是处理从数据库读出的记录. 这些时候, 你就有必要创建一个传统API来记录结构以处理这些外来数据. 最简单的额做法就是先建立一个看起来类似外部记录的类, 以便日后将某些字段和函数搬移到这个类之中. 一个不太常见但非常令人瞩目的情况是: 数组中的每个位置上的元素都有特定含义, 这种情况下应该使用`Replace Array with Object`.

### 做法

- 新建一个类, 表示这个记录
- 对于记录中的每一项数据, 在新建的类中建立对应的一个`private`字段, 并提供相应的取值/设置函数.

现在. 你拥有了一个"哑"数据对象. 这个对象现在还没有任何有用的行为, 但是更进一步的重构可以解决这个问题.

## 8.13 Repalce Type Code with Class (以类取代类型码)

类之中有一个数值类型吗, 但是它并不影响类的行为.

**以一个新的类替换该数值类型码**

### 动机

类型码或者枚举值都是很常见的. 如果带着一个有意义的符号名, 类型码的可读性还是不错的. 问题在符号名终究只是个别名. 编译器看见的, 进行类型校验的, 还是背后那个数值. 任何接受类型吗作为参数的函数, 实际接受的还是一个数值.

如果把这样的数值换成一个类, 编译器就可以对这个类进行类型检验. 只要为这个类提供工厂函数, 就可以始终保证只有合法的实例才会被创建出来, 而且他们都会被传递给正确的宿主对象. 

但是在使用该重构手法之前, 应该先考虑类型吗的其他替换方式. 只有当类型吗是纯粹数据时, 你才能以类来取代它. 

即使一个类型码不会因其数值的不同而引起行为上的差异, 宿主类中的某些行为还是有可能更合适置放在类型码中, 因此你还应该留意是否有必要使用`Move Method`将一两个函数搬移过去.


### 做法

- 为类型码建立一个类
  - 这个类需要一个用来记录类型码的字段, 其类型应该和类型吗相同. 并应该有对应的取值函数, 此外还应该用一组静态变量保存允许被创建的实例. 并以一个静态函数根据原本的类型吗返回合适的实例.
- 修改源码类实现, 让它使用上述新建的类
  - 维持原先以类型码为基础的函数接口, 但改变静态字段, 以新建的类产生代码. 然后, 修改类型码相关函数, 让他们也从新建的类中获取类型码. 
- 编译, 测试
  - 此时, 新建的类可以对类型码进行运行期间检查
- 对于源类中每一个使用类型吗的函数, 相应建立一个函数, 让性函数使用新建的类
  - 你需要建立"以新类实例为自变量"的函数, 用以替换原先"直接以类型为参数"的函数. 你还需要建立一个"返回新类实例"的函数, 用以替换原先"直接返回类型码"的函数, 建立性函数前, 你可以使用`Rename Method`修改源函数名称, 明确指出哪些函数任然使用旧式的类型码
- 逐一修改源类用户, 让他们使用新街口
- 每修改一个用户, 编译并且测试
  - 你可能需要一次性修改多个彼此相关的函数, 才能保持这些函数之间的一致性, 才能顺利的编译
- 删除使用类型码的旧接口, 并删除保存旧类型吗的静态变量
- 编译并且测试

## 8.14 Replace Type Code with Subclasses (以子类取代类型码)

你有一个不可变的类型码, 它会影响类的行为

**以子类取代这个这个类型码.**

### 动机

如果你面对的类型码不会影响宿主类的行为, 可以使用`Replace Type Code with Class`来处理它们. 如果类型码会影响宿主类的行为, 那么最好的办法就是借助多态来处理变化的行为.

一般来说, 这种情况的标志就是向`switch`这样的条件表达式. 这种条件表达式可能有两种表现形式: switch语句或者`if-else`这样的忌口. 不论哪种形式, 他们都是检查类型码值, 并根据不同的值执行不同的动作. 这种情况下应该使用`Replace Conditional with Polymorphism`进行重构. 但是为了能够顺利进行那样的重构, 首先应该将类型码替换为可拥有多态行为的继承体系. 这样的一个继承体系应该以类型码的宿主类为基类, 并针对每一种类型码各建立一个子类.

为建立这样的继承体系, 最简单的方法就是`Replace Type Code with Subclasses`: 以类型码的宿主类为基类, 针对每种类型码建立对应的子类. 

但是有两种情况下这么做是不合适的: 

1. 类型码值在对象创建之后发生了变化
2. 由于某些原因, 类型码宿主类已经有了子类. 

对于这两种情况, 更好的办法是`Replace Type Code with State/Strategy`来处理他们.

`Replace Type Code with Subclasses`的主要作用是搭建一个舞台, 让`Replace Conditional with Polymorphism`得以一展身手, 如果宿主类中并没有出现条件表达式, 那么`Replace Type Code with Class`更加合适, 风险更低. 

使用`Replace Type Code with Subclasses`的另一个原因就是, 宿主类中出现了"只与具备特定类型码之对象相关"的特性. 完成本项重构之后, 你可以使用`Push Down Method`和`Push Down File`将这些特性推导合适的子类去, 以展现他们只与特定情况相关这一事实. 

`Replace Type Code with Subclasses`的好处在于: 它把"对不同行为的了解"从类用户那里转移到了类自身. 如果需要再加入新的行为变化, 只需要添加一个子类就可以了. 如果没有多态机制, 就必须找到所有条件表达式, 并注意修改他们. 因此, 如果未来还有可能加入新的行为. 这项重构将特别有价值.

### 做法

- 使用`Self Encapsulate Field`将类型码自我分咋混个
  - 如果类型码被传给构造函数, 就需要将构造函数换成工厂函数
- 为类型码的每一个数值建立一个相应的子类, 在每个子类中复写类型码的取值函数, 使其返回相应的类型码值
  - 这个值被硬编码与`return`中,这看起来比较脏, 但是当所有的case子句都被替换后, 问题就能解决了.
- 每建立一个新的子类, 编译并测试
- 从超类中删除保存类型码的字段, 将类型码访问函数声明为抽象函数
- 编译, 测试

## 8.15 Replace Type Code with State/Strategy (以State/Strategy取代类型码)

你有一个类型码, 它会影响类的行为, 但是你无法通过继承手法消除它.

**以状态对象取代类型码**

### 动机

本项重构和`Replace Type Code width Subclasses`很相似, 但如果"类型码的值在对象生命周期中发生变化"或者"其他原因使得宿主类不能被继承", 你也可以使用本重构. 本重构使用`State`或`Strategy`模式[Gang of Four].

`State`模式和`Strategy`并非问题关键所在, 你只需要选择更适合特定情境的模式就可以了. 如果你打算在完成本项重构之后再以`Replace Condition with Polymorphism`简化一个算法, 把么选择`Stategy`模式比较合适, 如果打算搬移与状态相关的数据, 并且你把新建对象视为一种变迁状态, 就应该选择使用State模式

### 做法

- 使用`Self Encapsilar Field`将类型码自我封装.
- 新建一个类, 根据类型码的用途为它命名, 这就是一个状态对象
- 为这个新类添加子类, 每个子类对应一种类型码
  - 比起逐一添加, 一次性加入所有必要的子类可能更简单些
- 在超类中建立一个抽象的查询函数, 用以返回类型码, 在每个子类中覆写该函数, 返回确切的类型码
- 编译
- 在源类中建立一个字段, 用以保存新建的状态对象
- 调整源类中负责查询类型码的函数, 将查询动作转发给状态独享
- 调整源类中为类型码设值的函数, 将一个恰当的状态对象子类赋值给"保存状态对象"的那个字段
- 编译, 测试

## 8.16 Replace Subclass with Fields (以字段取代子类)

你的各个子类的唯一差别只在"返回常量数据"的函数上.

修改这些函数, 使他们返回超类中的某个(新增)字段, 然后销毁子类.

### 动机

建立子类的目的, 是为了增加新特性或变化其行为. 有一种变化行为被称为"常量函数", 它们会返回一个硬编码的值, 这东西尤其用途, 你可以让不同的子类中的同一个访问函数返回不同的值. 你可以在超类中将访问函数声明为抽象函数, 并在不同的子类中让它返回不同的值.

尽管常量函数有其用途, 但若子类中只有常量函数, 是在没有足够的存在价值. 你可以在超类中设计一个与常量函数返回值相应的字段, 从而完全去除这样的子类. 如此一来就可以避免因继承而带来的额外的复杂性.

### 做法

- 对所有子类使用`Replace Constructor withFactory Method`
- 如果有任何代码直接引用子类, 令它改而引用超类
- 针对每个常量函数, 在超类中声明一个常量字段
- 为超类声明一个`protected`构造函数, 用以初始化这些新增字段
- 新建或修改子类构造函数, 使它调用超类的新增构造函数
- 编译, 测试
- 在超类中实现所有常量函数, 令它们返回相应的字段值. 然后将该函数从子类中删除
- 每删除一个常量函数, 编译并测试
- 子类中所有的常量函数都被删除后, 使用`Inline Method`将子类构造函数内联到超类的工厂函数中
- 编译, 测试
- 将子类删掉
- 编译, 测试
- 重复"内联构造函数, 删除子类"过程, 直到所有子类都被删除

