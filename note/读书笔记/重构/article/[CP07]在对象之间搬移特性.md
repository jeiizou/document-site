# 在对象之间搬移特性

在对象的设计过程中, "决定吧责任放在哪儿"既是不是最重要的事, 也是最重要的事之一. 

常常使用`Move Method`和`Move Field`简单的移动对象行为就可以解决这些问题. 其中后者的优先级比前者稍高.

类往往会因为承担过多责任而变得臃肿不堪, 这种情况下, 可以使用`Extract Class`将一部分责任分离出来. 如果一个类变得太"不负责任", 就可以使用`Inline Class`将它融入到另一个类中. 如果一个类使用了另一个类, 运用`Hide Delegate`将这种关系隐藏起来通常是有帮助的. 有时候隐藏委托类会导致拥有者的接口经常变化, 此时需要使用`Remove Middle Man`.

本章的最后两项重构`Introduce Foreign Method`和`Introduce Local Extension`比较特殊. 只有当我不能访问某个类的源码, 却又像那其他责任移入这个不可修改的类时, 就可以使用这两个重构手法, 如果想要加入的仅仅是一个或者两个函数, 则`Introduce Foreign Method`比较合适, 如果有很多. 则`Introduce Local Extension`更好. 

## 7.1 Move Method (搬移函数)

如果在程序中, 有个函数与其所驻类之外的另一个类进行更多交流: 调用后者, 或者被后者调用. 

在该函数最常引用的类中建立一个有着类似行为的新函数. 将就函数变成一个单纯的委托函数, 或者是将旧函数完全移除. 

```js
class A{
    methodA();
}

class B{

}

// => Move Method
class A{

}

class B{
    methodA();
}
```

### 动机

"搬移函数"是重构理论的支柱. 如果一个类有太多行为, 或如果一个类与另一个类有太多合作而形成高度耦合, 就要进行函数的迁移. 通过这种手段可以保持系统中的类的合理简洁.

观察那些函数可以进行搬移不是一个简单的事.

如果不能肯定是否应该移动一个函数, 我就会继续观察其他函数, 移动其他函数往往会让这项决定变得更加容易. 但是本质上是否需要移动某个函数并没有那么重要, 所以可以按照你的感觉去做, 即便是不合适, 也可以修改回来. 

### 做法

- 检查源类中被源函数所使用的一切特性(包括字段和函数), 考虑他们是否也要被搬移
  - 如果某个特性只被你打算搬移的那个函数引用, 就可以考虑一起搬移, 否则, 就需要考虑使用该特性的所有函数全都一起迁移. 有时候, 迁移一组函数会比迁移一个更加简单. 
- 检查源类的子类和超类, 看看是否有该函数的其他声明. 
  - 如果出现其他声明, 你可能就无法进行迁移, 除非目标也表现出同样的多态性.
- 在目标类中声明这个函数
  - 你可以为此函数选择一个新名称--对目标更有意义的名称
- 将源函数的代码赋值到目标函数中, 调整后者, 使其正常的运行. 
  - 如果目标函数使用了源类的特性, 你得决定如何从目标函数引用源对象, 如果目标类中没有对应的引用机制, 就要把源对象的引用当做参数, 传递给新建立的目标函数.
  - 如果源函数包含异常处理, 你得判断逻辑上应该由哪个类来处理这一异常. 如果应该由源类来负责, 就把异常处理留在原地
- 编译目标类
- 决定如何从源函数正确引用目标对象
  - 可能会有一个现成的字段或函数来帮助你取得目标对象, 如果没有, 就看是否可以简单的建议这样一个函数, 如果还是不行, 就在源类中建立一个新的字段来保存目标对象.  这可能是一个永久性修改. 当然你也可以使用重构手段来取出这个参数
- 修改源函数, 使之成为一个纯委托函数
- 编译, 测试
- 决定是否删除源函数, 或者把它当做一个委托函数保存下来
  - 如果需要经常的源对象中引用目标函数, 那么保留是一个好主意
- 如果要移除源函数, 请将源类中对源对象的所有调用, 替换为对目标函数的调用
  - 你可以每修改一个引用点就编译并测试一次, 也可以通过一次查找/替换, 改掉所有引用点. 
- 编译, 测试

## 7.2 Move Field (搬移字段)

在程序中, 某个字段被其所驻类之外的另一个类更多的用到.

在目标类新建一个字段, 修改源字段的所有用户, 令他们改用新字段:

```js
class A{
    aField
}

class B{
}

// => Move Field
class A{
}

class B{
    aField
}
```

### 动机

在类之间移动状态和行为, 是重构过程中必不可少的措施. 随着系统的发展, 你会发现自己需要新的类, 并需要将现有的工作责任拖到新的类中. 在此时看似合理而正确的设计决策, 到了明天就可能不在正确.

对于一个字段, 在其所驻类之外的另一个类中有更多函数使用了它, 我就会考虑迁移这个子弹. 上述所谓的使用, 可能是设值/取值. 也可以移动该字段的用户(某个函数), 这取决是否需要保持接口不受变化.

使用`Extract Class`时, 我也可能需要迁移字段, 此时可以先迁移字段, 然后在迁移函数.

### 做法

- 如果字段的访问级是public, 使用`Encapsulate Field`将它封装起来:
  - 如果你有可能移动那些频繁访问该字段的函数, 或如果有许多函数访问某个字段, 先使用`Self Encapsulate Field`也许会有帮助
- 编译, 测试
- 在目标类中建立与源字段相同的字段, 并同时建立响应的设置/取值函数
- 编译目标类
- 决定如何在源对象中引用目标对象
  - 首先看是否有一个现成的字段或函数可以帮助我们获取到目标对象, 如果没有, 就看能够轻易建立这样一个函数, 如果还不行, 就得在源类中新建一个字段来存放目标对象, 这可能是个永久性的修改, 但你也可以让他是暂时的, 因为后续重构可能会把这个新建字段移除. 
- 删除源字段
- 将所有对源字段的引用替换为对某个目标函数的调用
  - 如果需要读取该变量, 就把对源字段的引用替换为对目标取值; 如果需要对目标变量赋值, 就把对源字段的引用替换为对设置函数的调用
  - 如果源字段不是`private`的, 就必须在源类的所有子类中查找源字段的引用点, 并进行相应替换
- 编译, 测试

## 7.3 Extract Class (提炼类)

某个类做了应该由两个类做的事

**建立一个新类, 将相关的字段和函数从旧类搬移到新类**

```js
class Person{
    name;
    officeAreaCode;
    officeNumber;

    getTelephoneNumber(){}
}

// Extract Class
class Person{
    name;

    getTelephoneNumber(){}
}

class Telephone Number{
    areaCode;
    number;

    getTelephoneNumber()
}
```

### 动机

你也许听过这样的建议: 一个类应该是一个清楚的抽象, 处理一些明确的责任. 但是在实际工作中, 类会不断成长扩展. 你会在这里加入一些功能, 在那儿加入一些数据. 给某个类添一项新责任是, 你会觉得不值得为这项责任分离出一个单独的类. 于是, 随着责任的不断增加, 这个类会变得过分的复杂.

这样的类往往含有大量的函数和数据. 这样的类往往太大而不易理解. 此时你需要考虑哪些部分可以分离出去, 并将它们分离到一个单独的类中. 如果某些数据和某些函数总是一起出现, 某些数据经常同时变化甚至彼此相依, 这就表示你应该它们分离出去. 一个有用的测试就是问题你自己, 如果你迁移了某些字段和函数, 会发生什么事? 其他字段和函数是否会因此变得毫无意义.

另一个往往在开发后期出现的型号是类的子类化方法. 如果你发现子类化只影响类的部分特性, 或如果你发现某些特性需要一种方式来子类化, 某些特性则需要以另一种方式子类化, 这就意味着你需要分解原来的类.

### 做法

- 决定如何分解类所负的责任
- 建立一个新类, 用以表现从旧类中分离出来的责任
  - 如果旧类剩下的责任与旧类名称不符, 为旧类更名
- 建立"从旧类访问新类"的连接关系
  - 有可能需要一个双向连接, 但是在真正需要它之前, 不要建立"从新类通往旧类"的链接
- 对于你想要迁移的每个字段, 运用`Move Field`迁移之
- 每次迁移以后, 编译, 测试
- 使用`Move Method`将必要函数迁移到新类. 先迁移较低层函数(也就是"被其他函数代用"多于"调用其他函数"者), 在迁移较高层函数
- 每次迁移之后, 编译, 测试
- 检查, 精简每个类的接口
  - 如果你建立双向链接, 检查时候可以将它改为单向连接
- 决定是否空开新类, 如果你的确需要公开它, 就要决定让他成为引用对象还是不可变的值对象. 

## 7.4 Inline Class (将类内联化)

某个类没有做太多的事情

**将这个类的所有特性搬移到另一个类中, 然后移除原类**


### 动机

`Inline Class`正好与`Extract Class`是两种相反的行为, 如果一个类不在承担足够责任, 不再有单独存在的理由(这通常是因为此前的重构动作移走了这个类的责任), 我就会挑选这一"萎缩类"的最频繁用户(也是个类), 以`Inline Class`手法将"萎缩类"塞到另一个类中. 

### 做法

- 在目标类身上声明源类的`public`协议, 并将其中所有函数委托至源类
  - 如果"以一个独立接口表示源类函数"更合适的话, 就应该在内联之前先使用`Extract interface`之类的.
- 修改所有源类引用点, 改而引用目标类
  - 将源类声明为`private`, 以斩断包以外的所有引用可能. 同时修改源类的名称, 这便可使编译器帮助你捕捉到所有对于源类的隐藏引用点
- 编译, 测试
- 运用`Move Method`和`Move Field`, 将源类的特性全部搬移到目标类.
- 删除源类


## 7.5 Hide Delegate (隐藏"委托关系")

客户通过一个委托类来调用另一个对象

**在服务类上建立客户所需的所有函数, 用来隐藏委托关系**


```ts
class Person{
  private _department:Departement;

  public getDepartment(){
    return this._department;
  }

  public setDepartemnt(){
    this._department=arg;
  }
}

class Department {
  private _chargeCode:string;
  private _manager:Person;

  constructor()(){
    this.manager=manager;
  }

  public getManager():Person{
    return this._manager;
  }
}

// => Hide Delegate
class Person{
  private _department:Departement;

  public getDepartment(){
    return this._department;
  }

  public setDepartemnt(){
    this._department=arg;
  }

  public getManager():Person{
    return _department.getManager();
  }
}

class Department {
  private _chargeCode:string;
  private _manager:Person;

  constructor()(){
    this.manager=manager;
  }

  public getManager():Person{
    return this._manager;
  }
}
```

### 动机

"封装"即使不是对象的最关键特征, 也是最关键特征之一. "封装"意味着每个对象都应该尽可能减少了解系统的其他部分. 如此一来, 一旦发生变化, 需要了解这一变化的对象就会比较少

任何学习过对象技术的人都知道, 减少public是应该的.

如果某个客户先通过服务对象的字段得到另一个对象, 然后调用后者的函数, 那么客户就必须知晓这一层委托关系. 万一委托关系发生了变化, 那么客户也要发生相应的变化.你可以在服务对象上放置一个简单的委托函数. 将委托关系隐藏起来, 从而去除这种依赖. 这么一来, 即便发生委托关系上的变化, 变化也将被限制在服务对象中, 不会波及客户. 

对于某些或者全部客户, 你可能会发现, 有必要先使用`Extract Class`, 一旦你对所有客户都隐藏了委托关系, 就不在需要在服务对象的接口中公开被委托对象了.

### 做法

- 对于每一个委托关系中的函数, 在服务对象端建立一个简单的委托函数
- 调整客户, 令它只调用服务对象函数的函数
  - 如果使用者和服务提供者不在同一个包, 考虑修改委托函数的访问权限, 让客户得以在包之外调用它
- 每次调整后, 编译并测试
- 如果没有将来不再有任何客户需要去用委托类, 便可以移除服务对象中的相关访问函数
- 编译, 测试

## 7.6 Remove Middle Man (移除中间人)

某个类做了过多的简单委托动作

**让客户直接调用受托类**

### 动机

在`Hide Delegate`一节的"动机"中, 就谈到了"封装受托对象"的好处, 但是这层封装也是要付出代价的: 每当客户要使用受托类的新特性时, 你就必须在服务端添加一个简单委托函数. 随着受托类的特性(功能)越来越多, 这个过程就越来越痛苦. 服务类完全变成了一个"中间人", 此时就应该让客户直接调用受托类.

很难说什么程度的隐藏才是合适的. 还好, 有了`Hide Delegate`和`Remove Middle Man`, 我们可以适当的解决这个问题. 随着系统的变化, "合适的隐藏程度"这个尺度也会随之而改变. 重构的意义就在于此.

### 做法

- 建立一个函数, 用来获得受托对象
- 对于每个委托函数, 在服务类中删除该函数, 并让需要调用该函数的客户转为调用受托对象
- 处理每个委托函数后, 编译, 测试. 

```ts
class Person{
  _department:Departement;

  public getManager(){
    return this._department.getManager();
  }
}

class Departement {
  private _manager:Person;

  public constructor(manager:Person){
    this._manager=manager;
  }
}

// => Remove Middle Man
class Person{
  _department:Departement;

  public getDepartment(){
    return this._department;
  }
}

class Departement {
  private _manager:Person;

  public constructor(manager:Person){
    this._manager=manager;
  }
}
```

## 7.7 Introduce Foreign Method (引入外加函数)

你需要为提供服务的类增加一个函数, 但是你无法修改这个类.

在客户类中建立一个函数, 并以第一参数形式传入一个服务类示例.

```ts
Date newStart = new Date(previousEnd.getYear(), previousEnd.getMonth(), previous.getDate() +1);

// => Introduce Foreign Method
Date newStart=nextDay(previous);

private static Date nextDay(Date arg){
  return new Date(previousEnd.getYear(), previousEnd.getMonth(), previous.getDate() +1)
}
```

### 动机

你正在使用某个类, 但是又需要一项新的服务, 这个类却无法提供. 并且在以后的过程中还会调用很多次. 此时你就要为这个类添加一些外加函数.

如果你发现自己为一个服务类建立了大量外加函数, 或者发现有许多类都需要同样的外加函数, 就不应该再使用本项服务, 而应该使用`Introduce Local Extension`.

但是使用不要忘记, 外加函数终归是权宜之计, 如果有可能, 你仍然应该把这些函数搬移到他们理想家园. 如果由于代码所有权的原因无法进行这样的搬移, 就把外加函数交给服务类的拥有者, 请他帮你在服务类中实现这个函数. 

### 做法

- 在客户类中建立一个函数, 来提供你需要的功能
  - 这个函数不应该调用客户类的任何特性. 如果它需要一个值, 把该值当做参数传递给它
- 以服务类实例作为该函数的第一个参数
- 将函数注释为: "外加函数, 应在服务类实现"
  - 这么一来, 如果将来有机会将外加函数搬移到服务类中时, 可以简单的通过注释来完成这些动作


## 7.8 Introduce Local Extension (引入本地扩展)

你需要为服务类提供一些额外函数, 但是你无法修改这个类.

**建立一个新类, 使它包含这些额外函数, 让这个扩展品成为源类的子类或者包装类**

### 动机

类的作者无法预知未来, 因此常常无法预先准备一些有用的函数, 如果我们可以修改源码, 最好的办法就是直接加入自己需要的函数. 但是我们经常无法修改源码. 如果只需要一两个函数, 可以使用上小节的内容进行外置函数的添加能力. 但是一旦这样的需求变得更多, 外置函数就无法很好的控制他们了. 因此把这些函数组织到一起, 放在合适位置是一种更好的做法, 比如进行子类化和包装. 

在这种情况下, 我们把封装类或者子类称为本地扩展. 

所谓的本地扩展是一个独立的类, 但也是被扩展类的子类型: 它提供源类的一切特性, 同时额外添加新类. 载客在任何使用源类的地方使用这个本地扩展. 

使用本地扩展使得我们可以坚持"函数和数据应该被统一封装"的原则. 如果我们一直把本该放在扩展类中的代码零散的放在其他类中, 最终只会让这些类变得越来越复杂. 并且使得期内的函数难以被复用. 

在子类和包装类之间进行选择的话, 通常我会选择子类, 因此这样来说工作量比较少, 制作子类最大的障碍在于它必须在对象创建期实时. 如果我接管对象的创建过程, 那当然没有问题. 但是如果你在对象创建之后再使用本地扩展, 就会产生问题. 此外, 子类化方案还必须产生一个子类对象, 在这种情况下, 如果有其他对象引用了旧对象, 我们就同时又两个对象保存了原始数据. 如果原始数据会被改动的, 此时一个修改动作必须同时修改两个副本, 这种时候包装类就是更好的选择. 

### 做法

- 建立一个扩展类, 将它作为原始类的子类或者包装类
- 在扩展类中加入转型构造函数
  - 所谓"转型构造函数"是指"接受原对象作为参数"的构造函数, 如果采用子类化方案, 那么转型构造函数应该适当调用超类构造函数; 如果采用包装类方案, 那么转型构造函数应该将它得到的传入参数以实例变量形式保存起来, 用作接受委托的原对象
- 在扩展类中加入新也行
- 根据需要, 将原对象替换为扩展对象
- 将针对原始类的定义的所有外加函数都迁移到扩展类中. 

