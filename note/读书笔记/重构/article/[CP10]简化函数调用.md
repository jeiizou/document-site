# 简化函数调用

接口(interface)是开发良好面向对象软件的关键. 

最简单也最终的意见事就是修改函数名称. 名称是代码作者和阅读者的交流关键. 只要你能理解一段程序的功能, 就应该大胆的使用`Rename Method`, 另外, 你也可以在适当的时机去修改变量和类的名称. 不过, 总体来说, 修改名称只是简单地文本替换, 不需要单独的重构手法.

函数参数在接口之中扮演十分重要的角色. `Add Parameter`和`Remove Parameter`都是很常见的重构手法. 刚接触面向对象技术的程序员往往使用很长的参数列表. 这是在其他开发环境中很典型的技术. 但是在面向对象的写法中, 我们可以将参数列保持的很短. 以下有一些相关的重构来帮助你羧酸参数列. 如果来自同一对象的多个值被当做参数传递, 你可以运用`Preserve Whole Object`将他们替换为单一对象, 从而缩短参数列. 如果此前不存在这样一个对象, 你可以运用`Introduce Parameter Object`将它创建出来. 如果函数参数来自该函数可获取的一个对象, 则可以使用`Replace Parameter with Method`避免传递参数. 如果某些参数被用来在条件表达式中做选择依据, 可以试试`Replace Parameter with Explicit Method`. 另外, 还可以使用`Parameterize Method`为数个相似函数添加参数, 将它们合并到一起.

关于缩减参数, 在并发编程中往往需要使用较长的参数列, 因为这样你可以保证传递给函数的参数都是不可被修改的. 例如内置型对象和值对象一定是不可变的. 通常, 你可以使用不可变对象取代这样的长参数列, 当然也必须对此类重构首保持谨慎. 

一个有价值的习惯是: 明确的把"修改对象状态"的函数(修改函数)和"查询对象状态"的函数(查询函数)分开设计. 如果看到这两种函数混合在一起, 可以使用`Seqarate Query from Modifier`将它们分开.

良好的接口只向用户展现必须展现的东西. 如果一个接口暴露了过多的细节, 可以把不必要暴露的东西隐藏起来, 从而改进接口的质量. 把所有的数据都隐藏起来, 同时, 所有可以隐藏的函数都应该被隐藏起来. 

进行重构时, 你望望需要暂时暴露某些东西, 最后可以`Hide Method`和`Remove Setting Method`将它们隐藏起来. 

构造函数是一个比较麻烦的东西, 因为它强迫你必须知道要创建的对象属于哪一个类, 而你往往并不需要知道这一点. 你可以使用`Replace Constructor with Factory Method`避免了解这些不必要的信息.

此外, 对于转型, 应该尽量使用`Encapsulate Downcast`向下转型封装隐藏起来, 避免让用户做那种动作.

对于一场助力, 可以使用`Repalce Error Code with Exception`来运行新的异常特性, 但是有时候异常也并不是最合适的选择, 你应该`Replace Exception with test`先进行测试. 

## 10.1 Rename Method (函数改名)

函数的名称不能反映函数的用途. 

**修改函数名称**

### 动机

一种良好的编程风格是: 将复杂的过程分解成小函数. 如果没有做的比较合理, 就容易搞不清清除这些小函数的各自用途. 要避免这种麻烦, 关键就在于给函数起一个号的名称. 

### 做法

- 检查函数签名是否被超类或子类实现过, 如果是, 则需要针对每份实现分别进行下面的步骤:
- 声明一个新函数, 将它命名为你想要的新名称, 将旧函数的代码赋值到性函数中, 并进行适当调整
- 编译
- 修改秀函数, 令它将调用转发给新函数
  - 如果只有少数几个地方引用旧函数, 你可以大胆的跳过这一步
- 编译, 测试
- 找出旧函数的所有被引用点, 修改他们. 令他们改而引用新函数, 每次修改后, 编译并测试
- 删除就函数
  - 如果就函数是该类public接口的一部分, 你可能无法安全的删除它. 这种情况下, 将它保留在原处, 并将它标记为`deprecated`.
- 编译, 测试

## 10.2 Add Parameter (添加参数)

某个函数需要从调用端得到更多信息

**为此函数添加一个对象参数, 让该对象带进函数所需信息**

### 动机

`Add Parameter`是一个很常见的重构手法. 动机也非常简单: 你必须修改一个函数, 而修改后的函数需要一些过去没有的信息. 因此你需要给该函数添加一个参数. 

实际上, 这里主要想要说明不需要使用本重构的时候. 除了添加参数, 你往往还有其他选择. 只要可能, 其他的选择都比添加参数要好, 因为他们不会增加参数列的长度. 

### 做法

`Add Parameter`的做法和`Rename Method`非常的相似

- 检查函数签名是否被超类或子类实现过. 如果是, 则需要针对每份实现分别进行下列步骤. 
- 声明一个新函数, 名称与原函数下你沟通. 只是加上新添参数, 将就函数的代码复制到新函数中.
  - 如果需要添加的参数不止一个, 将他们一次性添加进入比较容易.
- 编译
- 修改旧函数, 让它调用新函数
  - 如果只有少数几个地方引用旧函数, 可以跳过这步
  - 此时, 你可以在参数提供任意值. 但一般来说, 我们会给对象参数提供`null`, 给内置型参数提供一个明显非正常值. 对于数值型参数, 建议使用0以外的值, 这样比较容易识别
- 编译, 测试
- 找出旧函数的所有被引用点, 将他们全部修改为对新函数的应用. 每次修改后, 编译并测试/
- 删除旧函数
  - 如果就函数是该类public接口的一部分, 你可能无法安全的删除它. 这种情况下, 将它保留在原处, 并将它标记为`deprecated`.
- 编译, 测试

## 10.3 Remove Parameter (移除参数)

函数本体不再需要某个参数

**将该参数去除**

### 动机

多余的参数应该及时的去掉, 而不是因为出于稳妥或者对于外来的预期进行保留.

但是对于多态函数, 情况有所不同, 在这种情况下, 可能多态函数的另一份实现会使用这个参数. 此时你就不能去掉它. 你可以添加一个独立函数, 在这些情况下使用, 不过你应该先检查调用者如何使用这个函数, 已决定是否值得这么做. 

### 做法

- 检查函数签名是否被超类或子类实现过, 如果是, 则需要针对每份实现分别进行下列步骤
- 声明一个新函数, 名称与原函数下相同, 只是去除不必要的参数. 将就函数的代码复制到新函数中.
  - 如果需要去除的参数不止一个, 一次性去除是个不错的选择
- 编译
- 修改旧函数, 令它将调用新函数
  - 如果只有少数几个地方引用旧函数, 可以跳过这步
- 编译, 测试
- 找出旧函数的所有被引用点, 将他们全部修改为对新函数的应用.
- 删除旧函数
  - 如果就函数是该类public接口的一部分, 你可能无法安全的删除它. 这种情况下, 将它保留在原处, 并将它标记为`deprecated`.
- 编译, 测试

## 10.4 Seprarte Query from Modifier (将查询函数和修改函数范例)

某个函数即返回对象状态值, 又修改对象状态

**建立两个不同的函数, 其中一个负责查询, 另一个负责修改**

### 动机

如果某个函数只是想你提供一个值, 没有任何看得到的副作用. 那么这是个很有价值的东西. 你可以任意调用这个函数, 也可以吧调用动作搬到函数的其他地方. 简而言之, 需要操心的事情变少了.

明确表现出"有副作用"和"无副作用"两种函数之间的差异, 是个不错的习惯.

比如: 任何有返回值的函数, 都不应该有看得到的副作用. 

如果有一个既有返回值又有副作用的函数, 就应该试着将查询动作从修改动作中分割出来.

你也许已经注意到: "看得到的副作用"这个说法. 有一种常见的优化办法是: 将查询所得结果缓存于某个字段中, 这么依赖后续的重复查询就可以大大加快速度. 虽然这种做法改变了对象的状态. 但是这一修改是察觉不到的. 

### 做法

- 新建一个查询函数, 令他返回的值与原函数相同
  - 观察云函数, 看他返回什么东西, 如果返回的是一个临时变量. 找出临时变量的位置
- 修改原函数, 令它调用查询函数, 并返回获得的结果.
  - 原函数中每个return句都应该这样: `return newQuery()`, 而不应该返回其他东西
  - 如果调用者将返回值赋给了一个临时变量, 你应该能够去除这个临时变量. 
- 编译, 测试
- 将调用原函数的代码改为调用查询函数. 然后, 再调用查询函数的那行之前, 加上对原函数的调用. 每次修改后, 编译并且测试
- 将原函数的返回值改为void, 并删掉其中所有的return语句

## 10.5 Parameterize Method (令函数携带参数)

若干函数做了类似的工作, 但在函数本体中却包含了不同的值

**建立单一函数, 以参数表达那些不同的值**

### 动机

你可能会有这样两个函数: 它做着类似的工作, 但因少数几个值致使行为略有不同. 在这种情况下, 你可以把这些各自分离的函数统一起来, 并通过参数来处理那些变化情况, 应以简化问题. 这样的修改可以去除重复的代码, 并提高灵活性, 因为你可以用这个参数处理更多的变化情况. 

### 做法

- 新建一个带有参数的函数, 使他可以替换先前所有的重复性函数
- 编译
- 将调用旧函数的代码改为调用新函数
- 测试
- 对所有旧函数重复上述步骤, 每次替换后, 修改并测试

也有可能, 你无法用这种办法处理整个函数, 但是可以处理函数中的一部分代码. 这种情况下, 你应该首先将这部分代码提炼到一个独立函数中, 然后再对那些提炼所得的函数使用该重构. 



## 10.6 Replace Parameter with Explicit Methods (以明确函数取代参数)

现象: 你有一个函数, 其中完全取决于参数值而采取不同行为. 

做法: **针对该参数的每一个可能值, 建立一个独立函数**

```ts
setValue(name, value){
  if(name.equals("height")){
    this.height = value;
    return;
  }

  if(name.equals("width")){
    this.width=value;
    return;
  }

  Assert.shouldNerverReachHere();
}

// => 重构
setHeight(arg){
  this.height=arg;
}
setWidth(arg){
  this.width=arg;
}
```

### 动机 

`Replace Parameter with Explicit Methods`恰恰相反与`Parameterize Method`. 如果某个参数有多种可能的值, 函数内又以条件表达式检查这些参数值. 并根据不同参数值做出不同的行为, 那么就应该使用本项重构. 调用者原本必须赋予参数适当的值, 以决定该函数做出何种响应. 现在, 既然你提供了不同的函数给调用者使用, 就可以避免出现条件表达式. 此外你还可以获得编译器检查的好处, 而且接口也更清楚. 如果以参数值决定函数行为, 那么函数用户不但需要观察该函数, 而且还要判断参数值是否合法, 而"合法的参数值"是个很少能够被文档写清楚的概念. 

就算不考虑编译器检查的好处, 只是为了获得一个清晰的接口, 也值得执行这项重构. 哪怕只给一个内部的布尔变量赋值. 

但是如果参数值不会对函数行为有太多影响, 就不需要使用本项重构. 

### 做法

- 针对参数的每一种可能值, 新建一个明确函数
- 修改条件表达式的每个分支, 使其调用合适的新函数
- 修改每个分之后, 编译并且测试
- 修改原函数的每一个调用点, 改而调用上述的某个合适的新函数
- 编译, 测试
- 所有调用方修改完毕后, 删除原函数

## 10.7 Preserve Whole Object (保持对象完整)

现状：你从对象中取出若干值, 将他们作为某一次函数调用时的参数
做法: **改为传递整个对象**


### 动机

把对象的若干数据作为参数的问题在于: 如果将来被调用的函数需要新的数据项, 你就必须查找并修改对此函数的所有调用. 如果你把这些数据所属的整个对象传给函数, 可以避免这种问题.

除了可以是参数列表更加稳固之外, 该重构手法也可以提高代码的可读性. 

不过事情总有两面. 如果你传的是数值, 被调用函数就只依赖于这些数值, 反之, 你就要依赖参数对象. 这回事你的依赖结构恶化. 那么就不应该使用`Preserve Whole object`.

另一种不适用`Preserve Whole Object`的理由是: 如果调用函数只需要参数对象中的其中一项数值, 那么只传递那个数值会更好. 不过实际上传递一个数值和传递一个对象, 在代码的表述上是等价的. (当然性能上会有差异). 更重要的考量应该是放在对象间的依赖关系上. 

如果被调用函数使用了来自另一个对象的很多数据, 这可能意味着该函数实际上应该被定义在那些数据所属的对象中. 所以, 考虑`Preserve Whole Obejct`, 也应该同时考虑`Move Method`.

运用本项重构之前, 如果还没有定义一个完整对象, 可以先使用`Introduce Parameter Object`

还有一种常见情况: 调用者将自己的若干数据作为参数, 传递给被调用函数, 在这种情况下, 如果该对象有合适的取值函数, 你可以使用this取代这些参数值, 并且无需操心对象依赖. 

### 做法

- 对你的目标函数新添加一个参数项, 用以代表元数据所在的完整对象
- 编译, 测试
- 判断哪些参数可被包含在新添的完整对象中.
- 选择上述参数之一, 将被调用函数中原来引用该桉树的地方, 改为调用新添参数对象的相应取值函数
- 删除该项参数
- 编译, 测试
- 针对所有可从完整对象中获得的参数, 重复上述过程
- 删除调用端中那些带有被删除参数的代码
  - 如果调用端还在其他地方使用这些参数就不要删除
- 编译, 测试

## 10.8 Replace Parameter with Methods (以函数取代参数)

现状: 对象调用某个参数, 并将所得结果作为参数, 传递给另一个函数, 而接受该参数的函数本身也能够调用前一个函数

做法: 让参数接受者去除该项参数, 并直接调用前一个函数

```ts
let basePrice=_quantity * _itemPrice;
let discountLevel;
if(_quantity > 100 ) discountLevel =2;
else discountLevel = 1;
let finalPrice = discountedPrice(basePrice,discountedPrice);

// => 重构
let basePrice=_quantity * _itemPrice;
let finalPrice = discountedPrice(basePrice);
```

### 动机

如果函数可以通过其他途径获得参数值, 那么它就不应该通过参数取得该值. 过长的参数列会降低代码的可读性. 

缩减参数列的办法之一就是: 看看参数接收端是否可以通过与调用端相同的计算来取得参数值. 如果调用端通过其所属对象内部的另一个函数来计算参数， 并在计算过程中未曾引用调用端的其他参数， 那么你就可以将这个计算过程转移到被调用端内，从而去除该项参数。如果你所调用的函数隶属于另一对象， 而该对象拥有调用端所所属对象的引用，前面所说的这些也是同样适用的。

但是, 如果参数值的计算过程依赖于调用端的某个参数, 那么你就无法去掉被调用端的参数, 应为每一次调用动作中, 该参数值都可能不同(当然, 如果可以使用`Replace Parameter with Exception Methods`将该参数替换为一个函数, 又另当别论). 另外, 如果参数接收端并没有参数发送端对象的引用, 而你也不想加上这样一个引用, 那么也无法去除参数. 

预先添加的参数是不好的习惯. 不要去考虑针对未来的代码. 

### 做法

- 如果有必要, 将参数的计算过程提炼到一个独立函数中. 
- 将函数本体内引用该参数的地方改为调用新建的函数
- 每次替换后, 修改并测试
- 全部替换完成后, 使用`Remove Parameter`将参数去掉.

## 10.9 Introduce Parameter Object (引入参数对象)

现状: 某些参数总是很自然的同时出现

做法: 以一个对象取代这些参数

### 动机

有时候我们会看到特定的一组参数总是被一起传递. 可能有好几个函数都是用这一个参数, 这些函数可能隶属于同一个类, 也可能隶属于不同的类. 这样一组参数就是所谓的"Data Clumps"(数据泥团), 我们可以运用一个对象包装所有这些数据, 在以该对象取代他们. 哪怕是为了把这些数据组织在一起也是值得的. 本重构的意义在于缩短参数列. 另外新对象所定义的访问函数可以是代码更具一致性. 

### 做法

- 新建一个类, 用以表现你想替换的一组参数, 将这个类设置为不可变的
- 编译
- 针对使用该组参数的所有函数, 实时`Add Parameter`, 传入上述新建类的实例对象, 并将此参数值设为null
  - 如果你所修改的函数被其他很多函数调用, 那么可以保留修改前的就函数, 并令调用修改后的新函数, 你可以先对就函数进行重构, 然后逐一修改调用端使其调用新函数, 最后在将就函数删除.
- 对于`Data Clumps`中的每一项, 从函数签名中移除, 并修改调用端和函数本体, 令他们都改而通过新的参数对象取值
- 去除每一个参数, 编译并测试
- 将原先的参数去除之后, 观察有误适当函数可以运用`Move Method`搬移到参数对象之中.
  - 被搬移的可能是整个函数, 也可能是函数中的一个段落. 如果是后者, 首先使用`Exteact Method`将该段落提炼为一个独立函数, 在搬移这一新建函数. 


## 10.10 Remove Setting Method (移除设置函数)

现状: 类中的某个字段应该在对象创建时被设置, 然后就不在改变. 

做法: 去掉该字段中的所有设值函数

### 动机

如果你为某个字段提供了设置函数, 这就暗示这个字段值可以被改变. 如果你不希望在对象创建之后此字段还有机会改变, 那就不要为他提供设值函数(同时将该字段设为final). 

如果你保留了间接访问变量的方法, 就会让你的同伴感到困惑.

### 做法

- 检查设值函数被使用的情况, 看它是否只被构造函数调用, 或者被构造函数所调用的另一个函数调用
- 修改构造函数, 使其直接访问设值函数所针对的那个变量
  - 如果某个子类通过设置函数给超类的某个`private`字段设了值, 那么你就不能这样修改. 这种情况下你应该试着在超类中提供一个`protected`函数(最好是构造函数)来给这些字段设值. 不论你怎么做, 都不要给超类中的函数起一个域设值函数混淆的名字
- 编译, 测试
- 移除这个设值函数, 将它所针对的字段设为`final`.
- 编译, 测试

## 10.11 Hide Method (隐藏函数)

现状: 有个函数, 从来没有被其他任何类用到

做法: 将这个函数修改为`private`

### 动机

重构往往促使你修改函数的可见度, 提高函数可见度的情况是比较容易遇到的: 另一个类需要用到某个函数. 另外一方面, 则是如果没有被引用的函数, 则需要吧函数进行隐藏.

另一种比较常见的情况是: 当你面对一个过于丰富, 提供了过多行为的接口是, 就值得将非必要的取值函数和设值函数隐藏起来. 油漆当你面对的是一个只有简单封装的数据同期是. 随着越来越多的行为加入到这个类中, 你会发现有许多取值/设值函数都不要公开, 因此可以把他们隐藏起来. 知道所有地方不在引用, 就可以移除该函数了. 

### 做法

- 经常检查有没有可能降低某个函数的可见度
  - 使用lint之类的工具
  - 也别对设值函数进行这种检查
- 尽可能降低所有函数的可见度
- 每完成一组函数的隐藏之后, 编译, 测试.
  - 如果有不恰当的隐藏, 编译器会自然的报错.

## 10.12 Replace Constructor with Factory Method (以工厂函数取代构造函数)

现状: 你希望在创建对象时不仅仅是做简单的构建动作

做法: 将构造函数替换为工厂函数


### 动机

使用`Replace Constructor with Factory Method`的最显而易见的动机, 就是在派生子类的过程中以工厂函数取代类型码. 你可能常常需要根据类型码创建相应的对象, 现在, 创建名单中还得加上子类, 那些子类也是根据类型码来创建, 然而由于构造函数只能返回单一类型的对象, 因此你需要将构造函数替换为工厂函数. 

此外, 如果构造函数的功能不能满足你的需要, 也可以使用工厂函数来代替它. 工厂函数也是`Change Value to Reference`的基础. 你也可以令你的工厂函数根据参数的个数和类型, 选择不同的创建行为. 

### 做法

- 新建一个工厂函数, 让它调用现有的构造函数
- 将调用构造函数的代码改为调用工厂函数.
- 每次替换, 编译并测试
- 将构造函数声明为`private`
- 编译

## 10.13 Encapsulate Downcast (封装向下转型-java特性)

现状: 你某个函数返回的对象, 需要由函数调用者执行向下转型(downcast)

做法: 将向下转型动作移到函数中

```
lastReading(){
  return reading.lastElement();
}

//=> 重构
lastReading(){
  return (Reading)reading.lastElement();
}
```

## 10.14 Replace Error Code with Exception (以异常取代错误码)

现状: 某个函数返回一个特性的代码, 用以表示某种错误情况.

做法: 改用异常

### 动机

当代码出现异常, 可以抛出一个错误码. 

不过异常比错误码更合适

### 做法

- 决定应该抛出受控异常还是非受控异常
  - 如果调用者有责任在调用前检查必要状态, 则抛出非受控异常
  - 如果想跑出受控异常, 可以新建一个异常类, 也可以使用现有的异常类
- 找到该函数的所有调用者, 对他们进行相应调整
- 修改函数的签名

如果函数有许多调用者, 上述修改过程过大, 可以分为下列数个步骤:

- 决定应该抛出受控异常还是非受控异常
- 新建一个函数, 使用异常来表示错误状况, 将旧函数的代码复制到新函数中并适当调整
- 修改旧函数本体, 使其调用新建函数
- 编译并且测试
- 逐一修改
- 移除旧函数

## 10.15 Replace Exception with Test (以测试取代异常)

现状: 面对一个调用者可以预先检查的条件, 抛出了一个异常

做法: 修改调用者. 使他在调用函数之前先做检查

### 动机

异常的出现是程序语言的一大进步, 运用`Replace Error Code with Exception`, 异常就可以协助我们避免很多复杂的错误处理逻辑. 但是, 就想去多好东西一样, 异常也会被滥用. 

异常应该只用于异常, 而不是条件检查的替代平. 如果你可以合理期望调用者在调用函数之前先检查某个条件, 那么就应该提供一个测试, 而不是用异常区捕获它. 

### 做法

- 在函数调用之前, 放置一个测试语句, 将函数内catch区段中的代码赋值到测试句的适当if分支中.
- 在catch区段起始处加入一个断言, 确保catch区段绝对不会被执行. 
- 编译, 测试
- 移除所有`catch`区段, 然后将`try`区段内的代码复制到`try`之外, 然后移除`try`区段.
- 编译, 测试