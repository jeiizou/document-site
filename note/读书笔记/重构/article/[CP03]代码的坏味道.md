# 代码的坏味道

## 3.1 Duplicated Code (重复代码)

### 有关联的类中的重复代码

最单纯的`Dupliceted Code`就是 "同一个类的两个函数含有相同的表达式" . 要避免这种情况, 只需要分别做`Extract Method`(提取方法), 提炼出重复的代码, 然后让这两个地点都调用被提炼出来的那段代码即可. 

另一种常见情况是"两个互为兄弟的子类内含相同表达式", 要避免这种情况, 只需要对两个类都使用`Extracr Method`, 然后再对提炼出来的代码使用`Pull Up Method`, 将它推入超类. 如果代码之间只是相似, 而不是完全相同, 那么就要运用`Extract Method`将相似的部分和差异部分分割, 然后继续提取, 构成单独函数, 如果能运用`Form template Method`则可以获得一个`Template Method`模式. 如果有些函数使用不同的算法做相同的是, 则选择其中比较清晰的一个, 替换其他算法. 

### 无关联的类中的重复代码

两个不相关的类出现`Duplication Code`, 就应该对其中一个使用`Extract Method`, 将重复代码提炼到一个独立类中, 然后再另一个类内使用这个新类. 不过重复代码所在的函数也可能的确只应该属于某个类, 另一个类只能调用它, 或者这个函数可能属于第三个类, 另外两个函数只能引用这第三个类. 所以要决定这个函数放在哪里是最合适的, 并确定除此之外不会又重复出现. 

## 3.2 Long Method (长函数)

拥有短函数的对象往往生命力更强. 短小的函数非常有价值, "间接层"能够来带的所有利益(解释能力, 共享能力, 选择能力)都是有段函数构成的. 

函数越长越难理解. 现在OO语言几乎免去了函数调用开销. 除了保持短小的函数, 使用一个好的函数名称也是非常有用的. 

最终来说, 积极分解函数并且保持好的命名习惯. 可以遵循这样一条原则: 每当感觉要用注释来说明点什么的时候, 就把需要说明的东西写进一个独立函数中, 并以其用途(而非实现手法)命名. 

我们可以对一组甚至短短一行代码做这件事, 哪怕奇幻后的函数调用动作比函数自身还长, 只要函数名称能够解释用途, 就应当这样做. 关键不在于函数的长度, 而在于函数"做什么"和"如何做'之间的语义距离. 

---

大部分场合中, `Extract Method`是足够使用的, 如果函数内有大量的参数和临时变量, 他们会对你的函数提炼形成阻碍, 导致在提取函数的时候需要传入大量的参数和临时变量. 导致被提炼出的新函数的可读性降低. 因此可以运用`Replace Temp With Query`来消除这些临时元素, `introduce Paramerter Object`和`Preserve While Object`则可以将过长的参数列变得更简洁一些. 

如果这样做了还是有太多的临时变量和参数, 可以使用`Replace Method with Method Object`.

如何确定该提炼那一段代码, 一个比较好的方法是寻找注释. 通常他们可以直出代码用途和视线手法之间的语义距离. 如果代码前方有一行注释, 就是在提醒你, 可以将这段代码体替换成一个函数, 并且可以再注释的基础上给这个函数命名. 就算只有一行代码, 如果他需要以注释来说明, 也值得进行提炼. 

除此之外, 条件表达式和循环也常常是提炼的型号, 可以使用`Decompose Conditional`处理条件表达式. 至于循环, 应该吧循环和其内的代码提炼到一个独立函数中. 

## 3.3 Large Class (大 类)

如果想利用单个类做太多事情, 其内往往就会吹安太多实例变量. 一旦如此`Duplicated Code`也就接踵而至了. 

可以使用`Extract Class`将几个变量一起提炼到新类中. 提炼时应该选择类内彼此相关的变量, 将他们放在一起. 

通常来说, 如果类内的数个变量有相同的前缀或字尾, 就可能可以提取到一个子类中. 这个使用`Extract SubClass`往往比较简单. 

有时候, 并非在所有时刻都是用所有实例变量. 

和"太多实例变量"一样, 如果类内有太多代码, 也是代码重复, 混乱并最终走向死亡的源头. 最简单的解决方案, 就是把多于的东西消弭于类的内部. 比如有5个100行的函数, 可以尝试把他们变成5个10行的函数加10个提炼出来的双行函数. 


## 3.4 Long Parameter List (过长参数列)

在函数中, 往往吧需要的数据通过参数传递近来而不是依赖全局数据是比较优的选择. 面向对象则改变这一点, 选择性的依赖于对象中的数据, 而不是全部依赖于参数. 所以OOB代码中的函数参数往往比函数代码中的参数少. 

如果想已有的对象发出一条请求就可以取代一个参数, 那么应该使用`Replace Parameter with Method`. 

例外: 如果不想造成被调用对象和对象之间的耦合, 这个使用需要将对象拆解出来作为单独作为参数, 也是合理的. 不过需要注意代价. 

## 3.5 Divergent Change (发散式变化)

某个类经常因为不同的原因在不同的方向上发生变化. 就是`Divergent Change`. 比如: 如果加入一个数据库, 需要修改某三个函数. 如果出现一种新的工具, 需要修改这四个函数, 此时把这个类分成两个会更好. 

针对外部某一边发生的修改应该都只发生在单一类中, 而这个新类中的所有内容都可以反应此变化.

## 3.6 Shotgun Surgery (霰弹式修改)

类似3.5,不过恰恰相反, 如果遇到某种变化, 必须在许多不同的类中做出许多小的修改, 这就是`Shotgun Surgery`, 如果需要修改的代码散布在各处, 修改起来会非常麻烦. 

这种情况下, 应该吧需要修改的代码放到同一个类中, 如果眼下没有合适的类安置这些代码, 就新建一个. 通常可以使用`Inline Class`把一系列的行为放入到同一个类中, 这可能会造成少量的重复代码, 但是可以再后续处理它.

`Divergent Change`是指一个类受多种变化影响, 而`Shotgun Surgery`则是指"一种变化引发多个类相应修改"

## 3.7 Feature Envy (依恋情节)

面向对象的基础在于"将数据和对数据的操作行为包装在一起"的技术. 有一种经典行为是, 函数对某个类的兴趣高过对自己所处类的兴趣. 这种情况的焦点就是数据. 解决方法就是把这个函数移到另一个地点. 当然, 并非所有情况都这么简单. 一个函数往往都会用到几个类的功能, 那么它应该放在什么位置. 原则是, 判断哪个类拥有最多被此类函数使用的数据, 然后加吧这个函数和那些数据摆在一起. 如果现已`Extract Method`将这个函数分解为数个较小函数并分别未放在不同的低档, 上述步骤也就比较容易完成了. 

最根本的原则是: 把一起变化的东西放在一块, 如果有例外, 就迁移例外行为, 保持变化只在一个地方发生. 

## 3.8 Data Clumps (数据泥团)

许多地方可能存在相同的三四项数据, 两个类中相同的字段, 许多函数签名中相同的参数. 这些总是绑在一起出现的数据应该拥有属于他们自己的对象. 首先找出这些数据以字段形式出现的地方, 然后通过`Extract Method`提炼到独立对象中. 然后将注意力转移到函数签名上, 然后优化参数列, 简化函数调用. 


判断有一个依据方法: 删掉众多数据中的一项. 这么做, 其他数据有没有因此而失去意义. 如果不再有意义, 你应该为他们产生有一个新的对象.

本质上应该是**互相依赖的变量声明应该被提取为一个独立对象**. 来减少字段和参数的个数. 

## 3.9 Primitive Obsession (基本类型偏执)

大所述编程环境都有两种数据: 结构类型允许你将数据组织成有意义的形式; 基本类型则是构成结构类型的积木块. 

对象的价值在于: 模糊了基本数据和结构数据之间的界限, 可以编写出一些与基本类型无异的一些小型的类. 比如Java可以用类表示字符串和日期, 这两个可能在其他环境中是基本类型. 

善用这种思想, 比如结合数字和币种形成`money`类, 由一个起始值和一个结束之组成的`range`类, 电话号码或者邮政编码. 

## 3.10 Switch Statements (Switch 惊悚现身)

面向对象的一个基本特征是少用`switch`. `switch`的本质在于重复. 同样的逻辑会散布在各个地方, 导致修改一个case就要找到所有的`switch`语句修改它们. 用多态可以很好的解决这个问题. 

但是也不是绝对的, 如果只是在单一函数中想要选择实例, 且并不想改动它们, 那么多态就有点得不偿失了. 

## 3.11 Parallel Inheritance Hierarchies (平行继承体系)

这其实是霰弹式修改的一种特殊情况, 在这种情况下, 每当你为某个类增加一个子类, 也必须为另一个类相应的增加一个子类, 如果你发现某个继承体系的类名前缀和另一个继承体系的类名称前缀完全相同, 那可能就是出现了这种情况. 

一般策略是: 让一个体系的实例引用另一个继承体系的实例.

## 3.12 Lazy Class (冗余类)

你所创建的每一个类都得有人去理解和维护. 这些工作都是要花钱的. 如果一个类的所得不值其身价, 它就应该消失. 项目中经常会出现这样的情况. 

## 3.13 Speculative Generality (夸夸其谈未来性)

过度的考虑未来特性而企图以各种各样的钩子和特殊情况来处理一些非必要的事情, 这就不是很好了. 如果所有装置都被用到, 那就值得做, 如果用不到, 就不值得. 

比如你的某个抽象类其实没有太大作用, 请运用`Collapse Hierarchy`. 如果函数或类的唯一用户是测试用例, 这就是Bad Code的味道, 请连同测试用例一起删除它.

## 3.14 Temporary Field (令人迷惑的临时字段)

如果某个实例变量仅为某种特定情况而设. 这样的代码让人不容易理解. 因为你通常认为对象在的所有时候都需要它的所有变量. 

请使用`Extract Class`为这个可怜的故而创造一个家, 然后把所有和这个变量相关的代码都放进这个新家. 

如果类中有一个复杂算法, 需要好几个变量, 往往就可能导致坏味道`Temproary Field`. 由于实现者不希望传递一长串参数, 所以把参数都放入字段中. 但是这些字段只在使用该算法是才有效, 其他情况下只会让人迷惑. 这个时候就应该把这些数据和相关的函数提炼到一个独立类中. 提炼后的新的对象将是一个函数对象. 

## 3.15 Message Chains (过渡耦合的消息链)

如果你看到用户向一个对象请求另一个对象, 然后再向后者请求另一个对象, 然后在请求另一个对象.... 这就是消息链. 

实际代码中看到的可能是一长串的`getThis`或一长串临时变量. 

这种方式的问题是业务代码将和这个查询链表过渡耦合. 

这时候, 应该使用`Hide Delegate`, 在消息链的不同位置进行这种重构手法. 理论上可以重构消息链上的任何一个对象. 但这么做往往会阿布一些列对象都变成Middle Man. 通常更好的选择是: 先观察消息链最终得到的对象时用来干什么的, 看看能否提取出使用该对象的代码提炼到一个独立函数中. 

函数链不一定是坏事. 

## 3.16 Middle Man (中间人)

对象的基本特征之一就是封装: 对于外部世界隐藏内部细节. 封装往往伴随着委托. 过渡运用委托, 并不是一个好事. 这个时候不如直接删除这个中间人. 可以运动`Inline Method`把他们放进调用端. 如果这些`Middle Man`还有其他行为, 可以把他们放进实责对象的子类.

## 3.17 Inappropriate Intimacy (狎昵关系)

两个类过于亲密. 

这时候必须拆散. 你可采用`Move Method`和`Move Field`帮他们划清界限, 从而减少狎昵行为. 

继承往往会造成过渡亲密, 因为子类对超类的了解总是超过后者的主观愿望. 如果你觉得该让这个孩子独自生活了, 请让他离开继承体系

## 3.18 Alternative Classes with Different InterFaces (异曲同工的类)

两个函数做同一件事, 却有着不同的签名. 请运用`Rename Method`根据他们的用途重新命名. 但是这是往往不够的, 请反复运用`Move Method`不断的抽取逻辑知道两者的协议一致为止. 

## 3.19 Incomplete Library Class (不完美的库类)

库类有时候也会出现问题. 

如果出现这种行为, 有两种方法: 
- `Introduce Foreign Method`: 只修改库类的一两个函数
- `Introduce Local Extension`: 想要添加一大堆额外行为

### 3.20 Data Class (纯稚的数据类)

指的是拥有一些单用, 用于访问和读写这些字段的函数. 这些类只是一些不会说话的数据容器. 

尝试吧public的所有方法和属性移除, 并且移除所有类之外的get/set方法. 

## 3.21 Refused Bequest (被拒绝的遗赠)

子类应该继承超类的函数和数据, 如果不想或者不需要继承. 传统的来说, 那就意味着继承体系设计的错误. 不过也不是每次都需要去修改这种行为的. 

即便不愿意继承接口, 也不要胡乱的修改继承体系. 

## 3.22 Comments (过多的注释)

Comments本身并不是一件坏事. 但是不要用注释来掩盖`Bad Code`的坏味道. 

如果一段代码有长长的注释, 往往意味着, 这些代码可能很糟糕. 重构完整的代码往往注释会变得多余. 




