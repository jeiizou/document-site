# 大型重构

前面的章节都是单项重构的步骤, 本章主要来看对整体层面的重构手法. 

本章主要介绍四个大型重构示例.

- `Tease Apart Inheritance`, 用于处理混乱的继承体系.
- `Convert Procedural Design to Object`可以帮助你解决: 如何处理过程式代码?
- `Separate Domain from Presentation`可以帮助你将业务逻辑与用户界面隔离.
- `Extract Hierarchy`则可以讲过于复杂的类转变为一群子类, 从而简化系统.


## 12.1 Tease Apart Inheritance (梳理并分解继承体系)

现状: 某个继承体系同时承担两项责任

做法: 建立两个继承体系, 并通过委托关系让其中一个可以调用另一个

### 动机

继承是个好东西, 它可以明显减少子类中的代码量. 函数的虫咬性可能并不和它的大小成比例, 在继承体系之中尤其如此. 

但是继承体系也很容易被滥用: 年复一年的加入各种子类, 从而使得继承关系无比庞大而且复杂. 

混乱的继承习题会导致重复代码, 而且会使得修改变得困难. 

要指出继承习题是否承担了两项不同的责任并不困难; 如果习题中的某一特定层级上的所有类, 其子类名称都已相同的形容词开始, 那么这个体系就很可能就是承担着两项不同的责任.

### 做法

- 首先识别出继承体系所承担的不同责任, 然后建立一个二维表格(或者三维表格,四维表格), 并以坐标轴标示出不同的任务. 我们将重复运用本重构, 处理两个或者两个以上维度. 
- 判断那一项责任更重要些, 并准备将它留在当前的继承体系中. 准备将另一项责任移到另一个继承体系中. 
- 使用`Extract Class`从当前的超类提炼出一个新类, 用以表示重要性稍低的责任, 并在原超类中添加一个实例变量, 用以保存新类的实例
- 对应于元继承体系中的每个子类, 使用`Move Method`将其中的行为搬移到与之对应的新建子类中
- 当原继承体系中的某个子类不再有任何代码是, 就将它去除
- 重复, 直到原继承体系中的所有子类都被处理过位置. 观察新继承体系, 看看是否有可能对他实施其他重构手法. 例如`Pull Up Method`或者`Pull Up Field`.

## 12.2 Convert Procedural Design to Object (将过程化设计转化为对象设计)

现状: 你手上有一些传统过程化风格的代码

做法: 将数据记录变成对象, 将大块的行为分成小块, 并将行为移入相关对象之中

### 动机

典型的情况是: 类中有着常常的过程化函数和极少的数据, 旁边则是一堆哑数据. 如果你要转换的是一个纯粹的过程化程序, 可能连这些东西都没有.

我们并不是说绝对不应该出现只有行为而几乎没有数据的对象. 在`Strategy`模式中, 我们常常使用一些小型的策略对象来改变宿主对象的行为, 这些小型的策略对象就只有行为而没有数据. 但是这样的对象通常比较小, 而且只有在我们也别需要灵活性的时候, 才会使用它们. 

### 做法

- 针对每一个记录类型, 将其转变为只含访问函数的哑数据对象
  - 如果你的数据来自关系式数据库, 就把数据库中的每个表编程一个哑数据对象
- 针对每一处过程化风格, 将该处的代码提炼到一个独立类中
  - 你可以吧提炼所得的类做成一个`Singleton`(为了方便重新初始化), 或是把提炼所得的函数声明为`static`. 
- 针对每一个长长的程序, 实施`Extract Method`及其他先关重构将它分解, 再以`Move Method`将凤姐后的函数分别移到它所相关的哑数据类中
- 重复上述步骤, 知道原始类中的所有函数都被移除. 如果原始类时一个完全过程化的类, 将它拿掉是很不错的选择. 

## 12.3 Separate Domain from Presentation (将领域和表述/显示分离)

现状: 某些GUI类之中包含了领域逻辑

做法: 将领域逻辑分离出来, 为他们建立独立的领域类

### 动机

MVC是面向对象的一种典型模式. 常常用这个模式来维护GUI和领域对象之间的关系.

MVC模式最核心的价值在于: 它将用户界面代码和领域逻辑分离了. 展现类只含用以处理用户界面的逻辑; 领域类不含任何与程序外观相关的代码, 只含业务逻辑相关代码. 将程序中这两块复杂的部分加以分离, 程序未来的修改将变得更加容易, 同时也使统一业务逻辑的多种展现方式编程可能. 

但是大所述客户端/服务器接口的GUI应用都采用双层逻辑设计: 数据保存在数据库中, 业务逻辑放在展现类中. 这样的环境往往迫使你也倾向这种风格的设计, 是你很难把业务逻辑放在其他地方.

java可以创建内含业务逻辑的, 与展现逻辑无关的领域对象. 当然还是会经常遇到双层风格写的程序.

### 做法

- 为每个窗口建立一个领域类
- 如果窗口内有一张表格, 新建一个类来表示其中的行, 再以窗口所对应之领域中的一个集合来容纳所有的行领域对象
- 检查窗口中的数据. 如果数据只被用于UI, 就把它留着; 如果数据被领域逻辑使用, 而且不显示于窗口上, 我们就用`Move Fielf`将它搬移到领域类中; 如果数据同时被UI和领域逻辑使用, 就对他实施`Dupla=icate Observer Data`, 使它同时存在于两处, 并保持两处之间的同步.
- 检查展现类中的逻辑, 实施`Extract Method`将展现逻辑从领域逻辑中分开, 一旦隔离了领域逻辑,在运用`Move Method`将它移到领域类.
- 以上, 你就拥有了两组彼此分离的类: 展现类用以处理GUI, 领域类包含所有的业务逻辑.

## 12.4 Extract Hierachy (提炼继承体系)

现状: 你有某个类做了太多工作, 其中一部分工作是以大量条件表达式完成的.

做法: 建立继承体系的, 以一个子类表示一种特殊情况. 

### 动机

在渐进式设计过程中, 常常会有这样的情况: 一开始设计者只想以一个类实现一个概念; 但随着设计方案的演化, 最后却可能一个类实现了两个, 三个乃至更多个不同的概念. 诸如此类随着时间的变化导致代码变得复杂的情况. 你需要一个策略, 将它的各个功能梳理并分开. 

但是, 只有当条件逻辑在对象的整个生命周期保持不变, 本项重构所导入的策略才适用. 否则你可能必须在分离各种情况之前先使用`Extract Class`.

`Extract Hierachy`是一项大型重构. 你需要一步一步的完成它, 并坚持将设计方案梳理出来.

### 做法

这里有两种重构做法, 第一种是: 你无法确定哪些地方会发生变化, 这时候你会希望每次一小步的前进.

- 鉴别出一种变化情况
  - 如果这种变化可能在对象生命周期的不同阶段而又不同提箱, 就运用`Extract Method`将它提炼为一个独立的类
- 针对这种变化, 新建一个子类, 并对原始类实时`Replace Constructor with Factory Method`. 再修改工厂函数, 令他返回适当的子类实例.
- 将含有条件逻辑的函数, 一次一个, 逐一赋值到子类, 然后在明确的情况下, 简化这些函数
- 重复上述过程, 将所有变化情况都分离出来, 知道可以将超类声明为抽象类位置
- 删除超类中那些被所有子类覆写的函数本体, 并将他们声明为抽象类.

如果你非常清楚原始类会有哪些变化, 可以使用另一种做法.

- 针对原始类的每一种变化, 建立一个子类
- 使用`Replace Constructor with Factory Method`将原始类的构造函数转变成工厂函数, 并令它针对每一种变化情况返回适当的子类实例
  - 如果原始类中的各种变化情况是以类型码表示, 先使用`Replace Type Code with Subclasses`; 如果那些变化情况在对象生命周期的不同阶段会有不同体现, 就适用`Replace Type Code with State/Strategy`.
- 针对带有条件逻辑的函数, 实时`Replace Conditional with Polymorphism`, 如果并非整个函数的行为都有所变化, 而只是函数一部分有所变化, 请先运用`Extract Method`将变化的部分和不变的部分隔开. 


