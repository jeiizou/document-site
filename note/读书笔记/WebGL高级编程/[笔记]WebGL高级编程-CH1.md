---
title: '[笔记]WebgGL高级编程-CH1'
date: 2019-01-24 15:14:31
mathjax: true
category:
    - 笔记
    - WebGL高级编程
tags:
    - webgl
---

> WebGL高级编程- 第一章: 基础知识

<!-- more -->

## 第一章 基础知识

### 即时 API 和保留 API

即时 API(immediate-mode API), 对于每一帧的场景, 都会重新绘制. 提供 API 的图形库没有保存需要绘制场景的内部模型, 但是应用程序需要在内存中用自己的方法表示场景. 牺牲了性能的同时提升了应用程序的灵活性和控制能力.

保留 API(retained-mode API)的图形库包含内部模型或场景图形, 当应用程序调用 API 时, 由图形库决定是否需要更新.

两者在执行中的区别在于"模型"存在的位置不同.

WebGL 属于即时 API.

### 图形硬件

WebGL 是一个低级 API, 建立在 OpenGL ES2.0 之上. 计算机系统的简单结构如下所示:

![](/img/WebGL2/360截图1786053097151115.png)

GPU(即是显卡)是专门设计的图形绘制设备. 通常是高度并行的, 可以快速处理图形数据. 最早由 NVIDIA 于 1999 年提出并推广.

通常采用流水线结构,这种结构数据从流水线的一个阶段(stage)传送到下一个阶段. 从理论上将 WebGL 也是由多个阶段组成, 与 GPU 物理流水线的各个阶段对应.

#### 帧缓存

图形数据通过流水线传送以后, 写入到帧缓存(framebuffer).

帧缓存是一个存储器, 保存了最终显示的全部信息. 用作帧缓存的物理内存有几种不同的位置. 对于简单的图形系统, 帧缓存实际上通常就是主存的一部分. 但是新的图形系统, 帧缓存属于 GPU 中专用的快速图形存储器, 或者是靠近 GPU 一侧的单独存储芯片. 通常帧缓存有三个不同的子缓存: 颜色缓存, Z-缓存, 模板缓存.

1. 颜色缓存

    颜色缓存是一个矩阵阵列的存储器, 以 RGB 或者 RGBA 格式保存每个像素的颜色值. 一个像素可以使用的全部位数称为帧缓存的颜色深度,有 16 位,24 位,32 位等.

2. Z-缓存

    颜色缓存通常保存了在某个时刻 3D 场景中对观察者可见对象的颜色. 但是在 3D 场景中,一个对象可能被其他对象遮挡, 当整个场景绘制完成时, 颜色缓存中不会有属于被隐藏对象的像素信息.

    Z-缓存通常也被称为深度缓存. Z-缓存的单元数量与颜色缓存中的像素数量相同. Z-缓存的每个单元, 存储了离观察者最近的图元(primitive)的距离.

3. 模板缓存

    模板缓存可以用来控制在颜色缓存的某个位置写入操作, 一个实际示例是用它来处理阴影.

### WebGL 图形流水线

一个使用 WebGL 技术的 Web 应用程序除了 JS 代码意外,还包含了 Shader 的代码以及 3D(2D)对象数据.

WebGL 流水线有若干个阶段组成, 对于 WebGL 程序员来说, 最重要的是顶点着色器和片元着色器.

![](/img/WebGL2/360截图17571116251825.png)

#### 顶点着色器

为了得到一个真实感的 3D 场景, 仅仅绘制某些位置的对象是不够的, 还需要考虑灯光照射的阿斗这些对象时的效果. 我们用一个通用的数据表示确定灯光对不同材质效果的整个过程, 即着色(shdaing).

在 WebGL 中, 着色过程分为以下两个阶段:

-   顶点着色器
-   片段(片元)着色器

顶点着色器是 3D 数据经过 js 的代码后首先到达的地方, 它是可以编程的. 并且可以用 jsAPI 传入源代码, 因此实际上顶点的处理有很多不同的方法.

在着色实际开始之前, 着色器通常先对顶点进行转变, 把一个对象的全部顶点都乘以一个变换矩阵, 其实际作用相当于吧每个对象放置在场景中的某个位置.

顶点着色的输入包括:

-   顶点着色器的实际源代码. 这些代码使用 GLSL 语言编写的.
-   attribute(属性变量): 用户自定义的变量, 同行用来包含特定于每个顶点的数据. 顶点位置和顶点颜色就是顶点属性(attribute 变量)的示例.
-   uniform(恒值变量): 用来表示所有顶点都相同的数据. 变换矩阵和光源位置都属于 uniform. 在两次 WebGL 绘制调用之间, 可以改变 uniform 变量的值. 因此, 它们只是在一次绘制调用期间保持不变.

![](/img/WebGL2/360截图170010139297123.png)

varying 变量(易变变量)是顶点着色器向片元着色器发送信息的一个手段.

内置变量`gl_Position`是最重要的一个变量, 保存了顶点的位置信息(即使在顶点着色器完成处理之后).

#### 图元装配

在顶点着色器之后是图元装配(primitive assembly). 在这一步操作中, WebGL 把已经着色的顶点装配成三角形, 线段或点精灵(point sprites)等几何图元. 然后, 对每个三角形, 线段或者点精灵, WebGL 需要判断是否在屏幕上可见(视锥体内). 然后删除不可见的所有图元.

#### 光栅化

流水线的下一个阶段就是吧图元转换为片段, 然后把片段转送给片段着色器. 我们把片段看成最终绘制在屏幕的一个像素. 这个转换过程书现在光栅化操作.

#### 片元着色器

来自光栅化的片段需要发送到流水线的第二个可编程阶段, 即片元着色器. 一个片元实际上对应于屏幕上的一个像素, 但是并不是所有的片段都会绘制. 因为在后面的几步中会丢弃某些片段. 因此 WebGL 需要区分片段和像素, 把最终能够写入到绘制缓存中的片段称之为像素.

因此,WebGL 需要区分片元和像素, 把最终能写入到绘制缓存中的片元成为像素.

在其他的 3D 绘制 API 中, 比如微软的 Direct3D, 片源着色器实际上也称为像素着色器. 我们用下图来表示片元着色器的输入和输出

![](/img/WebGL2/360截图18050227759261.png)

片源着色器的输入数据包括:

-   用 OpenGL ES 写的片元着色器的源代码
-   一些内置的特殊变量(gl_PointCoord);
-   用户自定义的 varying 变量, 它们的值由顶点着色器写入;
-   uniform 变量, 一些特殊变量, 其值对有所片段都是恒量.
-   采样器(Sampler), 这是一类特殊的 uniform 变量, 用于纹理映射

正如前文所言, 通过 varying 变量吧顶点着色器中的信息传递给片元着色器. 然而, 正如下图所示, 通常片元数多于顶点数, 写入到顶点着色器的 varying 变量的值是对片源进行线性插值得到的. 片元着色器当需要读取的 varying 变量值是由线性插值得到的, 它们不同于写入到顶点着色器中的值.

![](/img/WebGL2/360截图167204049391100.png)

偏远说色漆通过特殊的内置 gl_FragColor 变量输出结果, 片元着色器把片元的颜色写入这些变量.

```glsl
precision medium float

varyomg vec4 vColor;
void main(){
    gl_FragColor=vColor
}
```

首先定义一个精度限定符(第一行代码). 这里通过这个精度限定符, 着色器编译器就可以知道着色器的变量或数据类型的最小精度. WebGL 要求所有片元着色器中都必须定义浮点类型数据的精度.

在精度限定符之后, 片元着色器声明了 vColor varying 变量. 在 main()函数中把 varying 变量 vColor 的值写入到特殊的内置比那里那个 gl_FragColor 中. 同样的, vColor 变量的值是由顶点着色器中写入的 varying 变量的值线性插值得到的.

#### 逐片元操作

在片元着色器之后, 都要把每个片段传送到流水线的下一个阶段, 此阶段包含逐片元操作(上图中虚线包含的部分). 这步操作实际上包含几个子操作. 来自片元着色器的每个片元都可以以不同方式影响绘制缓存中的一个像素, 具体取决于逐片元操作的条件和结果. 为了控制其行为, 可以启动或禁用这些处理.

![](/img/WebGL2/360截图187201161018799.png)

1. 裁剪测试: 裁剪测试决定片元是否位于裁剪矩形中. 此裁剪矩形是由一个左下角的坐标, 一个宽度和一个高度决定的. 通过测试则把片元传递下去. 否则丢弃.
2. 多重采样片元操作: 修改片段的 alpha 值和覆盖值, 组委抗锯齿的一个措施. 抗锯齿: 用于改线多边形的外观使得它们看起来没有锯齿(在屏幕上得到光滑的结果).
3. 深度缓存: 根据 Z-缓存的值丢弃输入的部分偏远.
4. 融合(blending):利用融合把传入片元的颜色与已经在颜色缓存中相应位置的片元的颜色进行组合(比如创建透明对象的时候)
5. 抖动(dithering):颜色缓存用有限的二进制位数表示每个颜色. 抖动用来以某种方式排列颜色, 得到比实际颜色数更多的颜色. 当颜色缓存可用的颜色数有限时, 抖动就很有用.

### 其他图形技术

1. OpenGl: 台式机 3D 图形的一个开放标准, 即时模式 API
2. Direct3D: 微软专用的 3D 图形标准, 只适用于 Windows 操作系统, 使用 HLSL 语言编写.
3. HTML-Canvas: 定义在 Web 页面上绘制 2D 图形的即时模式 API
4. 可缩放矢量图形(SVG): 使用 XML 格式描述 2D 图形的语言. 是一个矢量图形格式.
5. VRML/X3D, 虚拟现实标志语言和后继者 X3D 都是基于 XML 技术描述 3D 图形, 都没有在任何主要浏览器中实现.参考网站(www.web3d.org/www.x3dom.org)

### 线性代数

#### 坐标系

WebGL 使用三维正交右手坐标系.

![](/img/WebGL2/360截图18050222829895.png)

#### 点与定点

在 3D 坐标系中的一个点是一个位置, 它可以用一个有序三元组表示(Vx,Vy,Vz)表示. 点的位置是相对于原点的.

当点用来定义 3D 图形中的其他几何图形时, 它们通常被称为定点(vertices,单数 vertex).

#### 矢量

**矢量的基础运算:**

-   加减法: v±u=\*(Vx±Ux,Vy±Uy,Vz±Uz)
-   乘一个标量: ku=(kUx,kUy,kUz)

**点积:**

-   代数运算: u·v=u1v1+u2v2+u3v3
-   几何意义: u·v=|u||v|cosθ => 结果为标量, 点积为 0, 则两个矢量正交, 大于 0, 夹角小于 90 度, 小于 0, 夹角大于 90 度.

**叉积:**

-   定义为: w=u×v
-   代数定义: w=u×v=(UyVz-UzVy,UzVx-UxVz,UxVy-UyVx)
-   叉乘的结果是一个新的矢量, 具有以下属性:
    -   |w|=|u||v|sinθ
    -   w 正交与 u,v
    -   w 与 u,v 符合右手定则
    -   叉积是 3D 图形中的一个重要应用是计算三角形等表面的法矢量.

**齐次坐标:**

-   用四元组表示一个坐标(x,y,z,w),转换成三维(x/w,y/w,z/w);
-   引入齐次坐标是为了方便 4x4 矩阵运算

**矩阵:**

-   矩阵相加相减: 对应项相加减
-   矩阵相乘: 行列依次点积运算, 注意不符合交换律
-   单位矩阵: 反斜线上都是 1, 其余为 0
-   逆矩阵: MM<sup>-1</sup>=M<sup>-1</sup>M=I(单位阵)
-   转置矩阵: M<sup>T</sup>, 对角交换

**仿射变换:**

在屏幕上显示 3D 模型时,需要把他们变换到不同的坐标系或空间中. 变换是这样一个运算: 它以顶点或矢量为运算对象, 用某种方法对它进行转换. 一个特殊的变换是线性变换, 保持矢量相加运算和标量相乘运算不变性. 加入用 f 表示一个变换, 且有矢量 u 和 v, 则只有当以下两个条件都满足时, 此变换是线性的:

$$ f(u)+f(v)=f(u+v) $$

$$ kf(u)=f(ku) $$

线性变换的实例有缩放, 旋转和剪切.

仿射变换是这样一个变换: 它限制性一个线性变换, 再执行一个平移变换, 可以用一个 4x4 的矩阵表示一个仿射变换. 下面介绍四种类型的放射变换:

1. 平移矩阵如下:

    ![](/img/WebGL2/360截图17860530348467.png)

    应用于点 P 就是两个矩阵相乘, 计算如下:

    ![](/img/WebGL2/360截图16571221395154.png)

2. 旋转矩阵: 表示以经过坐标原点的直线为旋转轴旋转一个点或矢量. 旋转矩阵可以表示如下:

    ![](/img/WebGL2/360截图17321128314332.png)
    ![](/img/WebGL2/360截图16571224313729.png)

    三个矩阵分别表示绕 X 轴,Y 轴和 Z 轴旋转.

3. 缩放矩阵: 用来放大或或笑一个对象, 矩阵如下:

    ![](/img/WebGL2/360截图187201228714098.png)

    分别表示 x 方向,y 方向,z 方向缩放的倍数.

4. 剪切变换: 剪切变化在实际中使用很少. 一个实例是在设计一个游戏程序时需要扭曲场景. 剪切矩阵是吧单位矩阵左上角 3x3 子阵中的某个零值改为非零值. 就可以得到剪切矩阵.

    ![](/img/WebGL2/360截图17610614275314.png)

    这个剪切矩阵用 y 坐标去改变 x 坐标. 如果用于点 p,效果如下图所示:

    ![](/img/WebGL2/360截图1789122493143108.png)

    示例如下:

    ![](/img/WebGL2/360截图1843070679123130.png)
