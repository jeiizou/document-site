# 单例模式:有效进行程序初始化

## 设计模式

设计模式的真正关键就在于: 找到变化, 封装变化

一个简单的设计模式学习框架:

- 这个模式中封装了什么实现
- 这个模式有什么共性的规律
- 这个模式的对象职责是什么
- 这个模式对象之间的关系是什么
- 这个模式常用在那些场景
- 这个模式基于常用场景的通用代码是什么
- 这个模式如何基于上下文环境来进行设计和使用

## 单例模式分析

单例模式(Singleton)允许存在一个和仅存在一个给定类的机制, 它提供一种机制让任何实体都可以访问该实例. 

```java
public class Singleton {
	//用于存储单一实例的静态对象
    private static Singleton _instance; 
	//私有的空构造函数
    private Singleton(){
    };

	//通过判断静态对象是否被初始化来选择是否创建对象
    public static Singleton getInstance(){
        if (null == _instance){
            _instance = new Singleton();
        }
        return _instance;
    }
}
```

单例模式包含三个要点:

1. 一个单例类只能有一个实例
2. 单例类必须自行创建这个示例
3. 单例类必须保证全局其他对象都能访问到它

这三个要点就是单例模式所要应对的变化:

- 对象实例数量收到限制的事实
- 对象实例的构造和销毁
- 需要保证对象实例称为"线程安全"的某种机制

从这段代码还可以看出, 单例模式的对象职责有两个:

1. 保证类只有一个实例
2. 为该实例提供一个全局访问节点

**单例模式就类似于全局变量或全局函数的角色，可以使用它来代替全局变量。**

## 常用场景和解决方案

单例模式更多是在程序一开始进行初始化时使用的.

常见的单例模式应用和使用的解决方案有：饿汉式初始化、懒汉式初始化、同步信号、双重锁定和使用 ThreadLocal

## 为什么要使用单例模式

1. 系统的某些资源有限, 比如文件的访问全向等等
2. 需要表示为全局唯一的对象. 比如序列号生成器等

## 收获什么, 损失什么

收获:

- 对有限资源的合理利用, 保护有限的资源, 防止资源重复竞争
- 更高内聚的代码组件, 提升代码复用性
- 具备全局唯一访问点的权限控制, 方便按照统一规则管控权限
- 从负载均衡的角度考虑, 我们可以轻松的将Singleton扩展为多个实例, 可以在适当的时候自由更改实例的数量

损失:

- 作为全局变量使用时, 引用的对象越多, 代码修改影响的范围也越大
- 作为全局变量是, 在全局变量中使用状态变量时, 会造成加/解锁的性能损耗
- 即便能扩展多实例, 但耦合性依然很高, 因为隐蔽了不同对象之间的调用关系
- 不支持有参数的构造函数

