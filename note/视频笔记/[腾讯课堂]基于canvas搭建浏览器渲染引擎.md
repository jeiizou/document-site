# 腾讯课堂: 基于canvas搭建浏览器渲染引擎

浏览器会将js+css+html处理为可以被渲染的数据, 传递给skia进行页面渲染.

我们可以使用: quickjs(js引擎) + libuv + skia 搭建一套基于浏览器之外的js渲染引擎.

## skia

[skia](https://skia.org/): 一个2d的基于C++的图形界面渲染引擎.

在浏览器中, 会将`js+css+html`的数据处理为可以被渲染的数据.

webkit就是一种将前端代码处理为可渲染数据的工具.

## CPU与GPU, canvas和webgl

- CPU 是串行计算的, 单个核只能在同一时间处理一个任务, 我们平时运行的程序代码大部分都是运行的CPU上的
- GPU 是并行计算的, 我们需要专门面向GPU编程, 来处理多个任务的调度.

从这点上说: canvas本质上是面向CPU编程的, 而在写webgl的时候, 是在面向GPU编程(需要自己写顶点着色器和片元着色器).

在不同显卡上, 有不同的显示协议. opengl就是一套应用比较广泛的协议. webgl就是基于opengl协议之上的.

> webgpu 则于此不同, 它不是任何现有的本地API的直接端口, 而是基于Vulkan, Metal和Direct 3D 12中的概念. 引擎较新，设计上更好的反映了GPU硬件技术这些年新的发展，能提供更好的性能，支持多线程，采用了偏面向对象的编程风格

## canvas的绘图逻辑

canvas的绘图是基于状态绘图和基于路径绘图的.

### path, 基于路径的绘图

比如说, canvas有一些常见的api

- beginPath: 开始路径
- lineTo: 移动路径
- closePath: 闭合路径, 数据集合进行存储

canvas内部会维护一个点(或者说路径)的集合, 开始路径就是重置一个集合, 闭合路径就是将这个集合进行绘制.

> 所谓的路径就是很多不同形状,样式的点的集合

所以, canvas是一种**笔式绘图仪模型**, 类似于人类使用笔去绘画的逻辑. 

canvas2D的绘图本质上也就是基于路径和像素点的计算, 也就是说, 它是基于CPU计算的.

### context, 基于状态的绘图

**context**是绘制上下文, 也是绘制的对象. 绘制对象有一些`scale`, `translate`方法, 在调用这些方法的时候, 这些方法不会改变现有的绘制状态, 但是会影响下一次绘制的状态. 这就是所谓的**基于状态的绘图**.

换句话说: 在每一次绘制的时候, 都会根据当前的状态来进行绘制.

我们可以使用`save`来`restore`来存储和重置状态.

## 基于canvas的浏览器渲染引擎

本质上, 我们的目标就是一个`canvasRender`函数:

```js
canvasRender(htmlDomString) // 渲染出一个html的界面
```

在考虑canvas的渲染引擎, 我们有几个问题需要处理:

1. 如何交互, 或者说鼠标点击的拾取.
2. 如何进行局部绘制
3. 如何进行分层
4. 如何实现事件的封装

### 拾取的实现(影子颜色映射方法)

比如我们构建了一个图形, 

1. 用一个唯一的id标识它(这个ID来自下面的步骤)
2. 在这个图形的下层绘制一个形状一致的图形, 我们可以称之为**影子图形**
3. 影子图形的颜色是唯一的, 我们把这个颜色作为上层图形的id
4. 当我们鼠标点击到这个像素点的时候, 能够获取到这个坐标点的颜色值
5. 通过该颜色值作为唯一id, 我们就能知道当前鼠标点击的图形是哪个, 然后对其坐标进行处理, 就实现了拾取的交互了

#### 关于`isPointInStroke`

利用`isPointInStroke`也可以实现点的选取. 但这不是一个好的选择.

之前我们知道canvas的绘制是基于路径的. 一旦绘制到画布上, 路径的信息就从内存中删除了.

当需要调用`isPointInStroke`的时候, 就需要重建`path`信息, 然后遍历路径中所有的坐标点, 然后进行判断.

这是非常消耗性能资源的.

### 局部绘制

与局部绘制对应的是全量绘图. 

所谓的局部绘图, 也是根据分层来实现的.

1. 在第一层绘制全量的图形
2. 在第二层绘制需要频繁重绘的图形, 覆盖在第一层的全量图像上
3. 达到只进行局部的重绘的效果

#### geojson

[geojson](https://geojson.org/)是一种基于地理信息位置的矢量图形数据描述格式, 属于json的一种特殊化格式.

具体的文件格式说明参照[wiki: geojson](https://en.wikipedia.org/wiki/GeoJSON)

#### 坐标的映射

geojson给出我们的一般是经纬度坐标, 如果我们需要把geojson数据绘制到canvas画布上, 还是需要进行坐标转换的. 

通过一定的算法, 我们可以将坐标进行转换. 不过这种转换是基于CPU计算的. 如果我们使用webgl, 就可以对每个点进行单独计算, 并且是并行计算的.

> webworker 也可以进行离线计算, 但是图形数据一般比较庞大, 线程之间通信通过**结构化克隆算法**传递数据, 这期间的消耗性能会比较大. 如何解决这种问题?  
> 我们通过`sharedArrayBuffer`来共享大量数据, 来解决数据传输的问题

> 对于wasm, 不同的机器平台有自己的硬件接口, wasm就是生成中间字节码, 然后转译到机器码到各个平台上去执行

### 事件封装(坐标值的转换)

...

## 浏览器的渲染原理

浏览器中包含了许多的进程, 主要包含3个主要进程: 浏览器进程(ui, 网络, IO, 定时器), GPU进程(栅格化), 渲染进程(合成线程, 主线程, tile work)

浏览器会给每个页面分配一个渲染线程.

> js 并不存在单独的一个执行线程

1. 首先页面会从合成线程开始启动
2. 判断事件数据是否还需要传递给主线程
3. 调用main主线程
4. 调用 requestAnimationFrame
5. parseHTML: 解析
   1. 执行webkit, 解析html
   2. 当遇到`script`标签的时候, 会调用v8执行`script`中的js代码. v8会开始编译js代码, 分配内存, 堆栈等操作, 如果其中涉及到内存的操作, 就调用内存管理相关的方法.
   3. 构建dom-tree, css-tree, 组合出layout-tree
   4. tile work
5. Composite: 合成

## canvasRender

绘制流程:

1. 第一步渲染当前元素的border和background
2. 第二步渲染有负数的z-index的堆栈上下文
3. 处理流式布局, 没有position定位和inline-block的子元素
4. 处理没有position定位的float元素
5. 正常流式布局, inline-block元素, 无position定位的元素
6. z-index为0或者transform, opacity属性元素的上下文
7. 绘制拥有正z-index的元素以及子元素的层叠上下文

> z-index 就是计算那些元素绘制到那个层中去






