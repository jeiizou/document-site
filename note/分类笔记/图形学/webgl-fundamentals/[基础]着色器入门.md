# [基础]着色器入门

webgl是面向GPU编程的. 因此我们需要能够在CPU上运行的代码. 每一个这样的代码需要提供一对方法: 

- 顶点着色器: 计算顶点的位置
- 片元着色器: 计算绘制的每个像素的颜色

每一对方法组合起来称作: program (着色程序)

整个webgl的api就是关于如何设置这些成对的方法的状态值, 以及运行它们. 

对于想要绘制的每一个对象, 都需要先设置一系列的状态值, 然后通过调用`gl.drawArrays`或者`gl.DrawElemnets`运行一个着色器方法对, 使得你的着色器对能够在GPU上运行.

## 获取数据

这些方法对所需要的任何数据都需要发送到GPU, 着色器获取数据有4种方法:

### 1. 属性(Attributes)和缓冲

所谓的缓冲是发送到GPU的一些二进制数据序列, 通常会包含: 位置, 法向量, 纹理坐标, 顶点颜色等. 

属性是用来指明 **如何从缓冲中获取所需要的数据并将它提供给顶点着色器**.

比如, 我们可能在缓冲中使用三个32位的浮点类型数据存储一个位置的值, 对于一个确切的属性你就需要告诉他:

1. 从哪个缓冲中获取数据
2. 获取什么类型的数据
3. 起始偏移量是多少
4. 到下一个位置的字节数是多少

缓冲的读取不是随意的. 事实上顶点着色器运行的次数是一个指定的确切数字, 每一次运行属性会从指定的缓冲中按照指定规则依次的获取下一个值.

### 2. 全局变量(Uniforms)

全局变量在着色器程序运行之前赋值, 在运行过程中全局生效

### 3. 纹理(Textures)

纹理是一个数据序列, 可以在着色器程序的运行时随意的读取其中的数据. 大部分情况下存放的是图像数据, 但是纹理本质上只是一种数据序列, 也可以存放除了颜色以外的其他数据.

### 4. 可变量(Varyings)

可变量是一种顶点着色器给片元着色器传值的方式, 依照渲染的图元是点, 线还是三角形, 顶点着色器中设置的可变量可以在片元着色器中获得不同的差值


## 基础流程

### 准备环境

1. 创建webgl上下文: `getWebGLContext`
2. 设置视口位置宽高信息: `viewport`
3. 创建着色器程序: `createProgram`

### 准备数据

1. 获取变量的位置信息: `getAttribLocation`, `getUniformLocation`
2. 创建数据缓冲区: `createBuffer`
3. 把数据写入缓冲区: `bufferData`

### 绑定和使用

1. 绑定着色器程序: `useProgram`
2. 绑定数据缓冲区: `bindBuffer`
3. 启用对应的属性: `enableVertexAttribArray`
4. 使用缓冲区的数据: `vertexAttribPointer`
5. 运行着色器: `drawArrays`

## 顶点着色器和片元着色器

### 顶点着色器

一个顶点着色器的工作是生成裁剪空间坐标值, 通常是以下的形式:

```c++
void main() {
   gl_Position = doMathToMakeClipspaceCoordinates
}
```

每个顶点都会调用一次顶点着色器, 每次调用都需要设置一个特殊的全局变量`gl_Position`, 该变量的值就是裁减空间的坐标值.

顶点着色器的数据可以通过三种方式获取:

1. Attributes 属性(从缓冲中获取的数据)
2. Uniforms 全局变量(在一次绘制中对所有顶点都保持一致)
3. Textures 纹理(从像素或者纹理元素中获取的数据)


### 片元着色器

一个片元着色器的工作是为当前光栅化的像素提供颜色. 通常是以下的值:

```c++
precision mediump float;
 
void main() {
   gl_FragColor = doMathToMakeAColor;
}
```

每个像素都会调用一次片元着色器, 每次调用需要从设置的全局变量`gl_FragColor`中获取颜色信息.

片元着色器所需要的数据, 可以通过三种方式获取:

1. Uniforms 全局变量
2. Textures 纹理
3. Varying  可变量

