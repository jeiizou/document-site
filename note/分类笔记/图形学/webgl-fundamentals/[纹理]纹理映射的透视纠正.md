# [纹理]纹理映射的透视纠正

顶点着色器可以声明可变量并给它赋值, 一旦顶点着色器被引用3次就会画一个一个三角形, 绘制这个三角形的每个像素都会调用片元着色器获得像素颜色, 在三个顶点之间的点会得到差值之后的**可变量**.

我们回到基础, 在裁剪空间中绘制一个三角形, 没有数学运算, 只是传入裁剪空间坐标到一个简单的顶点着色器, 像这样:

```c++
// 属性从缓冲中获取数据
attribute vec4 a_position;
 
// 所有的着色器都有一个 main 函数
void main() {

  // gl_Position 是着色器需要设置的一个特殊的变量
  gl_Position = a_position;
}
```

还有一个简单的片元着色器提供固定的颜色:

```c++
// 片断着色器没有默认的精度，
// 中等精度是个不错的默认值
precision mediump float;

void main() {
  // gl_FragColor 是片断着色器需要设置的一个特殊变量
  gl_FragColor = vec4(1, 0, 0.5, 1); // 返回红紫色
}
```

我们知道webgl会把放入`gl_Position`的值除以`gl_Position.w`.

所以, 我们提供两种不同的顶点坐标, 如下:

```js
var mult = 20;
var positions = [
    -.8,  .8, 0, 1,  // 第一个矩形的第一个三角形
     .8,  .8, 0, 1,
    -.8,  .2, 0, 1,
    -.8,  .2, 0, 1,  // 第一个矩形的第二个三角形
     .8,  .8, 0, 1,
     .8,  .2, 0, 1,

    -.8       , -.2       , 0,    1,  // 第二个矩形的第一个三角形
     .8 * mult, -.2 * mult, 0, mult,
    -.8       , -.8       , 0,    1,
    -.8       , -.8       , 0,    1,  // 第二个矩形的第二个三角形
     .8 * mult, -.2 * mult, 0, mult,
     .8 * mult, -.8 * mult, 0, mult,
];
```

在上方的顶点中, 我们提供的w值为1, 但是我们知道webgl会除以w, 所以下面的矩形应该结果是不变的. 

我们把第二个矩阵的`x`和`y`都乘以`mult`, 同时设置w为`mult`, 由于webgl会除以w所以理论上应该是拿到相同的结果的. 

但实际上, 是不一样的.

![alt](./imgs/20210608174511.jpg)

注意两个矩形和上一个例子的位置相同, 事实是x,y的坐标都没有变化, 颜色却不一样. 这是为什么?

实际上, 是应为webgl是使用w实现纹理映射或者可变量插值的透视投影. 

线性插值的公式类似如下:

```js
result = (1 - t) * a + t * b
```

其中, `t∈(0,1)`表示a到b之间的位置, 0表示在起点, 1表示在终点.

可变量经过webgl的插值, 使用这个公式:

```js
result = (1 - t) * a / aW + t * b / bW
          -----------------------------
             (1 - t) / aW + t / bW
```

`aW`表示`a`点的`w`值, 也就是`gl_Position.w`的值, 而不一定等于缓冲区中的值, `bW`同理.

为什么要这么修改呢?

尝试手动的修改让w始终为1.

```js
attribute vec4 a_position;
attribute vec2 a_texcoord;
 
uniform mat4 u_matrix;
 
varying vec2 v_texcoord;
 
void main() {
  // 将位置和矩阵相乘
  gl_Position = u_matrix * a_position;
 
  // 手工除以 W
  gl_Position /= gl_Position.w;
 
  // 将纹理坐标传到片断着色器
  v_texcoord = a_texcoord;
}
```

但是这就会造成三维纹理的扭曲. 因为没有得到正确的w, webgl无法正确的实现纹理的透视纠正, 或者跟准确的说法是, webgl不能正确的对可变量的插值实现透视.

`W`就是透视矩阵的`Z`值, 当`W`始终为1的时候, WebGL做的就是一个简单的线性插值, 事实上如果我们看这个等式:

```js
result = (1 - t) * a / aW + t * b / bW
          -----------------------------
             (1 - t) / aW + t / bW
```

将`W`带入`1`, 就能得到:

```js
result = (1 - t) * a / 1 + t * b / 1
          ---------------------------
             (1 - t) / 1 + t / 1
```

简化后得到:

```js
result = (1 - t) * a + t * b
```

这就和线性插值是一样的了.

现在就知道为什么webgl需要使用4X4的矩阵和包含X, Y, Z, W四个值的向量了. X和Y除以W得到的裁剪空间的坐标, Z除以W也得到了裁剪空间的Z坐标, W同时还为纹理映射的透视纠正提供了帮助. 

