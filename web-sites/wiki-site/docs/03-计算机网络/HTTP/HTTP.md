# HTTP

Http是无状态(stateless)协议, http协议自身不对请求和响应之间的通信状态进行保存. 也就是说在HTTP这个级别, 协议对于发送过的请求或者响应都不做持久化处理.

使用HTTP协议, 每当有新的请求发送的时候, 就会有对应的新的响应信息.这么设计的原因是为了更快的处理大量的事务, 确保协议的可伸缩性. 

然而随着业务的发展, 出现了需要保存状态的需求. 于是引入了Cookie技术
有了Cookie在使用HTTP通信, 就可以管理状态了.

## HTTP 请求方法

- **HTTP1.0**支持的方法: GET, POST 和 HEAD 方法
- **HTTP1.1**支持的方法(增加的): OPTIONS, PUT, DELETE, TRACE 和 CONNECT

### 所有类型的请求概览

-   `GET`: 通常用于请求服务器发送某些资源
-   `HEAD`: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源
-   `OPTIONS`: 用于获取目的资源所支持的通信选项
-   `POST`: 发送数据给服务器
-   `PUT`: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
-   `DELETE`: 用于删除指定的资源
-   `PATCH`: 用于对资源进行部分修改
-   `CONNECT`: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器, `CONNECT`要求在与代理服务器通信的时候要建立隧道, 使用隧道协议进行TCP通信. 主要使用SSL(Secure Sockets Layer, 安全套接层)和TLS(Transport Layer Security, 传输层安全)协议把通信内容通过加密后经网络隧道传输
-   `TRACE`: 追踪路径, 让web服务端将之前的请求通信环回给客户端的方法. 发送请求时, 在`Max-Forwards`首部字段中填入数值, 每经过一个服务器就将该数字减一, 当数值刚好减到0的时候, 就停止继续传输, 最后接收到请求的服务端则返回200状态码

### 关于Trace的说明

客户端通过Trace方法可以查询发送出去的请求时怎样被加工修改的. 这是因为请求想要连接到源目标服务器可能会通过代理中转, Trace方法就是用来确认连接过程中发生的一些列操作. 

但是Trace方法不太常用, 并且容易引发`XST`(Cross-Site Tracing, 跨站追踪)攻击, 因此通常就更不会用到了.

### GET 和 POST 的区别

- GET在浏览器回退时是无害的, 而POST会再次提交请求
- GET产生的URL地址可以被保存, 而POST不可以
- GET请求会被浏览器主动cache, 而POST不会
- GET请求只能进行url编码, 而POST支持多种编码方式
- GET请求参数会被完整保留在浏览器历史记录中, 而POST中的参数不会被保留
- GET请求在URL中传输的参数是有长度限制的, 而POST没有
- 对参数的数据类型, GET只接受ASCLL字符, 而POST没有限制
- GET比POST更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息
- GET参数通过URL传递, POST放在Request body中

但是在本质上来说, GET和POST是HTTP协议中两种发送请求的方法. HTTP的底层是TCP/IP, 也就是说, 从协议层面上这两种请求的本质是一样的. 

我们可以给GET加上`request body`, 也可以在POST加上`url`参数. 这在技术上是行的通的.

所以get和post实际上是一种约定的规则. 浏览器和服务器采用这种约定的规则行事, 如果没有依照这种约定, 就不保证服务的可用性. 

除此之外, GET/POST还有一个状态的区别:

**GET产生一个TCP数据包, POST产生两个TCP数据包**.

- 对于GET请求, 浏览器会把`http header`和`data`一起发送数据, 服务器响应`200`.
- 对于POST, 浏览器先发送`header`, 服务器响应`100 continue`, 浏览器再发送`data`, 服务器响应`200 ok`

从这里看, GET请求的效率比POST要高一些, 但是也不要盲目的用GET去替代POST, 这里是一些理由:

1. GET/POST 有自己的明确的含义, 不应该随意的混用
2. 在网络环境好的情况下, 发一次包的时间和发两次包的时间可以基本无视, 而在网络环境差的情况下, 两次包的TCP在验证数据包完整性上, 有非常大的优点.
3. 并不是所有浏览器都会在POST中发送两次包, FireFox就只发送一次

### PUT 和 POST 的区别

PUT 方法是幂等的, 而 POST 的非幂等的.

除此之外, 通常情况下, PUT 的 URI 执行具体单一资源, POST 指向资源集合.

也可以理解为 POST 是创建资源, PUT 是更新资源

> 幂等: 多次执行统一请求服务器返回的结果是一致的, 我们就说这个请求是幂等的.

### PUT 和 PATCH 的区别

`PUT` 和 `PATCH` 都是更新资源, `PATCH` 用来对已知资源进行局部更新.

简单的说, `PUT` 是重新更新全部信息, `PATCH` 是更新某部分的信息.

## HTTP Keep-Alive

在早期的 HTTP/1.0 中，每次 http 请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的 HTTP/1.0 中以及 HTTP/1.1 中，引入了重用连接的机制，就是在 http 请求头中加入 `Connection: keep-alive` 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定 HTTP/1.0 如果想要保持长连接，需要在请求头中加上 `Connection: keep-alive`. 

`keep-alive`的优点：

-   较少的 CPU 和内存的使用（由于同时打开的连接的减少了）
-   允许请求和应答的 HTTP 管线化
-   降低拥塞控制 （TCP 连接减少了）
-   减少了后续请求的延迟（无需再进行握手）
-   报告错误无需关闭 TCP

**Keep-Alive 在Http1.1是默认开启的**, 可以在Response Header中看到: `Connection: keep-alive`. 

在配置该请求头的情况下, 可以配置`Keep-Alive`请求头的一些参数, 比如:

```
Keep-Alive: timeout=5, max=100
```

表示这个TCP的通道可以保持5秒, max则表示这个长连接最多接受100次请求就断开, 默认是没有限制的. 

在`nginx`中有两个比较重要的配置:

```
keepalive_timeout 65 // 保持连接的时间, 也叫超时时间
keepalive_request 100 // 最大连接上限
```

### 与TCP的 Keep Alive 的区别

HTTP的Keep-Alive和TCP的Keep Alive 在意图上有些不同, 前者只要是TCP连接的复用, 避免建立过多的TCP连接, 而TCP的Keep Alive的意图在于保持TCP连接的存活, 本质上是在发送心跳包: 每隔一段时间给接受方发送一个探测包, 如果收到回应的ACK, 则认为连接还是存活的, 在超过一定重试次数之后, 还是没有收到对方的回应, 则丢弃该TCP连接. 

### 管线化

持久链接使得多数请求以管线化(pipelining)方式发送成为可能. 从前发送请求后需要等待并受到响应, 才能发送下一个请求. 管线化技术出现后, 不同等待响应也可以直接发送下一个请求. 

这样就能做到同时并行的发送多个请求, 而不需要一个接一个的等待响应了. 

本质上是将多个HTTP请求整批提交的技术, 而且在传输过程中不需要先等待服务端的回应. 管线化机制必须通过永久连接完成, 并且只有GET和HEAD请求可以进行管线化, 而POST则有所限制. 只能在HTTP1.1中启用. 

浏览器将HTTP请求大批的提交可以缩短页面的加载时间. 关键在于把多个HTTP的请求消息同时塞入一个TCP分组中, 所以只要提交一个分组就能同时发出多个请求, 借此减少网络上多余的分组并降低线路负载. 

## HTTP 请求报文

请求报文由 4 部分组成:

1. 请求行
2. 请求头
3. 空行
4. 请求体

![image](/assets/2021-3-11/http_1.png)

### 请求行

请求行包括: 请求方法字段(method), URL 字段, HTTP 协议版本字段. 它们用空格分隔. 例如, GET /index.html HTTP/1.1

### 请求头

请求头部由关键字/值组成, 每行一对, 关键字和值用英文冒号":"分隔

1. `User-Agent`: 产生请求的浏览器类型
2. `Accept`: 客户端可识别的内容类型列表
3. `Host`: 请求的主机名, 允许多个域名同时使用一个`IP`地址, 即虚拟主机.

### 请求体

`post`,`put`等请求携带的数据.

## HTTP 响应报文

响应报文也由四部分组成:

1. 响应行: 由协议版本, 状态码和状态码的原因短语组成. 例如`HTTP/1.1 200 OK`
2. 响应头: 响应首部组成
3. 空行
4. 响应体: 服务器响应的数据

## HTTP 编码

HTTP在传输数据的时候可以按照数据原貌直接传输, 但也可以在传输过程中通过编码提升传输速率. 通过在传输的时候编码, 能够有效的处理大量的访问请求. 但是, 编码的操作需要计算机来完成, 会消耗额外的CPU资源. 

### 报文主体和实体主体

- 报文(message): 是HTTP通信中的基本单位, 由8位组字节流(octet sequence, 其中octet为8个比特)组成, 通过HTTP通信传输
- 实体(entity): 作为请求或者响应的有效载荷数据(补充项)被传输, 内容由实体首部和实体主体组成. 

HTTP报文的主体用于传输请求或响应的实体主体. 

通常, 报文主体等于实体主体. 只有当传输中进行编码操作的时候, 实体主体的内容发生变化, 才导致它和报文主体产生差异. 

### 内容编码 

HTTP协议中有一种被称为内容编码的功能, 能将数据容量变小. 

内容编码指明应用在实体内容上的编码格式, 并保持实体信息原样压缩. 内容编码后的实体由客户端接收并负责解码. 

常用的内容编码有以下几种:

- gzip(GNU zip)
- compress(UNIX系统的标准压缩)
- deflate(zlib)
- identity(不进行编码)

### 分块传输编码

在Http通信过程中, 请求的编码实体资源尚未全部传输完成之前, 浏览器无法显示请求页面. 在传输大容量数据的时候, 通过把数据分割为多块, 能够让浏览器逐步显示页面

这种把实体主体分块的功能称为**分块传输编码**(Chunked Transfer Coding).

分块传输编码会将实体分成多个部分(块), 每一块都会用16进制来标记块的大小, 而实体主体的最后一块会使用"0(CR+LF)"来标记.

使用分块传输编码的实体主体会由接受的客户端负责解码, 恢复到编码前的实体主体.

HTTP/1.1 中存在一种叫做**传输编码**(Transfer Coding)的机制, 它可以在通信时按某种编码方式传输, 但只定义作用于分块传输编码中. 

### 多部分对象集合

在发送邮件的时候, 我们可以在邮件中写入文字并且添加多份的附件. 这是因为采用了`MIME`(Multipurpose Internet Mail Extensions, 多用途因特网邮件扩展)机制, 它允许邮件处理文本, 图片, 视频等多个不同类型的数据.

在Http中也是类似的. 主要的对象包含:

- `multipart/form-data`: 在web表单上传时使用
- `multipart/byteranges`: 状态码206(Partial Content, 部分内容)响应报文包含了多个范围的内容时使用.

使用这些参数需要在后部字段中使用`Content-Type`进行指定. 

使用`boundary`字符串来划分多部分对象集合指明的各类实体. 在`boundary`字符串指定的各类实体的其实行插入`--`标记, 而在多部分对象集合对应的字符串的最后插入`--`标记作为结束.

多部分对象集合的每个部分类型中, 都可以含有首部字段, 另外, 可以在某个部分中嵌套使用多部分对象集合. 有关多部分对象集合更详细的解释, 请参考`RFC2046`.

### 范围请求

指定范围发送的请求就是范围请求(Range Request). 

对于一份10000字节大小的资源, 如果使用范围请求, 可以只请求`5001~10 000`字节内的资源. 

```
<!-- 5001 ~ 10 000 -->
Range: bytes=5001-10000

<!-- 5001 ~ -->
Range: bytes=5001-

<!-- 0~3000, 5000~7000 -->
Range: bytes=-3000, 5000-7000
```

### 内容协商返回最合适的内容

当浏览器的默认语言为英文或者中文, 访问相同URL的web页面时会显示对应的英文版本或者中文版本. 这样的机制叫做内容协商(Content Negotiation)机制.

内容协商机制是指客户端和服务器端就响应的资源内容进行协商, 然后提供给客户端最合适的资源. 内容协商会以响应资源的语言, 字符集, 编码方式等作为判断的基准. 

主要参考:

- accept
- accept-charset
- accept-encoding
- accept-language
- content-language

内容协商技术有三种类型:

- 服务器驱动协商(Server-driven Negotiation)
- 客户端驱动协商(Agent-driven Negotiation)
- 透明协商(Transparent Negotiation)

## HTTP 响应状态码

**2XX 成功:**

-   200 OK, 表示从客户端发来的请求在服务器端被正确处理 ✨
-   201 Created, 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立
-   202 Accepted, 请求已接受，但是还没执行，不保证完成请求
-   204 No content, 表示请求成功，但响应报文不含实体的主体部分
-   206 Partial Content, 进行范围请求 ✨

**3XX 重定向:**

-   301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
-   302 found，临时性重定向，表示资源临时被分配了新的 URL ✨
-   303 see other，临重定向, 表示资源存在着另一个 URL，应使用 `GET` 方法定向获取资源(会转换请求方法)
-   304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
-   307 temporary redirect，临时重定向，和 302 含义相同, 但是不会改变请求方式

**4XX 客户端错误:**

-   400 bad request，请求报文存在语法错误 ✨
-   401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨
-   403 forbidden，表示对请求资源的访问被服务器拒绝 ✨
-   404 not found，表示在服务器上没有找到请求的资源 ✨
-   408 Request timeout, 客户端请求超时
-   409 Confict, 请求的资源可能引起冲突

**5XX 服务器错误:**

-   500 internal sever error，表示服务器端在执行请求时发生了错误 ✨
-   501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法
-   503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
-   505 http version not supported 服务器不支持http协议版本，或者拒绝支持在请求中使用的 HTTP 版本

### 307, 303, 302 的区别

302 是 http1.0 的协议状态码，在 http1.1 版本的时候为了细化 302 状态码又出来了两个 303 和 307。

303 明确表示客户端应当采用 get 方法获取资源，他会把 POST 请求变为 GET 请求进行重定向。 307 会遵照浏览器标准，不会从 post 变为 get。

### 302 与 301 对搜索引擎的影响

302 与 301 都是重定向状态码, 不同的是 301 是永久重定向, 302 是临时重定向.

301 重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用 301 来做转址。
如果我们把一个地址采用 301 跳转方式跳转的话，搜索引擎会把老地址的`PageRank`等信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。旧网址的排名等完全清零

302 代表暂时性转移(Temporarily Moved )，在前些年，不少 `Black Hat SEO` 曾广泛应用这项技术作弊，目前，各大主要搜索引擎均加强了打击力度，像 Google 前些年对 Business.com 以及近来对 BMW 德国网站的惩罚。即使网站客观上不是 spam，也很容易被搜寻引擎容易误判为 spam 而遭到惩罚。

:::tip spam
spam, 搜索引擎垃圾技术, 利用不道德的技巧提高搜索引擎上的排名. 可能会导致搜索引擎把你的网站从它的数据库中永久删除.

常见的搜索引擎垃圾技术:

1. 隐藏文本
2. 重复关键字
3. 使用无关关键字
4. 隐藏标签
5. 相同或者相似的页面
6. 页面交换技术
7. 无内容
8. 过渡提交
9. 链接搜索引擎垃圾技术
:::


## HTTP 头部

HTTP的请求分为请求报文和响应报文. 

在请求报文中, 由方法, URI, HTTP版本, HTTP首部字段等部分组成.

在相应报文中, 有HTTP版本, 状态码, HTTP首部字段3部分组成.

其中首部字段的内容是最为丰富的.

HTTP的首部字段根据实际的通途分为四类:

- 通用首部字段: 请求报文和响应报文都会使用的首部字段
- 请求首部字段: 客户端向服务器发送请求报文时使用的首部字段, 补充了请求的附加内容, 客户端信息, 响应内容相关优先级信息
- 响应首部字段: 从服务端向客户端返回响应报文时使用的首部, 补充了响应的附加内容, 也会要求客户端附加额外的内容信息
- 实体首部字段: 针对请求报文和响应报文的实体部分使用的首部, 补充了资源内容更新时间和实体有关的信息

### 通用首部字段(General Header Fields)

请求报文和响应报文两方都会使用的首部:

-   `Cache-Control` 控制缓存 ✨
-   `Connection` 连接管理、逐跳首部 ✨
-   `Upgrade` 可以用来检测HTTP协议以及其他协议是否可使用, 并用更高的版本进行通信. 
-   `via` 代理服务器的相关信息, 可以用来追踪客户端与服务器之间的请求和响应报文的传输路径. 也可以用于避免请求回环的发生, 常常和trace请求一起使用.
-   `Wraning` 告知用户一些与缓存相关的问题的警告, 格式如下: `Warning: [警告码] [警告的主机:端口号] "[警告内容]" ([日期时间])`
-   `Transfor-Encoding` 报文主体的传输编码格式 ✨
-   `Trailer` 会事先说明在报文主体后面记录了哪些首部字段, 可以应用在分块传输编码的时候.
-   `Pragma` 报文指令, 是历史遗留字段, 仅仅为了兼容而存在.
-   `Date` 创建报文的日期

#### Cache-Control 控制缓存

该指令的参数是可选的, 多个指令之间通过`,`进行分隔. 首部字段`Cache-Control`可以用于请求以及响应时.

<!-- 具体的参数内容可以参照[浏览器/缓存策略](/浏览器&HTML/1.2.浏览器:%20缓存.html) -->

#### Connection 连接管理、逐跳首部

该首部具有两个作用:

- 控制不再转发给代理的首部字段: `Connection: 不再转发的首部字段名称`
- 管理持久链接: `Connetion: close` HTTP/1.1版本是默认持久连接的. 只要TCP连接不断开, 就可以一直发送HTTP请求, 持续不断, 没有上限. 在1.0版本中有连接的限制和规则. 这里不展开叙述. 可以通过执行`close`明确关闭连接. 只有设置`Connection: Keep-Alive`, 后面的`keep-alive`字段才会生效.


### 请求头部字段

客户端向服务器发送请求的报文时使用的首部

-   `Accept` 客户端或者代理能够处理的媒体类型 ✨
-   `Accept-Encoding` 优先可处理的编码格式
-   `Accept-Language` 优先可处理的自然语言
-   `Accept-Charset` 优先可以处理的字符集
-   `Authorization` web 的认证信息 ✨
-   `Host` 请求资源所在**服务器**, 是HTTP/1.1规范中唯一一个必须被包含在请求内的首部字段
-   `Expect` 期待服务器的特定行为
-   `If-Match` 比较实体标记Etag, 只有两个值匹配一致的时候, 服务器才会接受请求
-   `If-None-Match` 比较实体标记（ETage）与 If-Match 相反 ✨
-   `If-Modified-Since` 比较资源更新时间（Last-Modified）✨
-   `If-Unmodified-Since` 比较资源更新时间（Last-Modified），与 If-Modified-Since 相反 ✨
-   `If-Ranges` 告知服务器若指定的`if-range`字段值(ETag的值或者时间)与请求资源的ETag值或者时间相一致的时候, 作为范围请求处理. 反之, 返回全体资源
-   `Range` 实体的字节范围请求 ✨
-   `Proxy-Authorization` 代理服务器要求 web 认证信息
-   `From` 用户的邮箱地址
-   `User-Agent` 客户端程序信息 ✨
-   `Max-Forwrads` 最大的逐跳次数, 每经过一个代理服务器就减1, 可以用来检查请求路径的通信情况.
-   `TE` **传输编码**的优先级
-   `Referer` 请求原始方的`url`, 可以知道URI是从哪个web页面发起的 

### 响应首部字段

从服务器向客户端响应式使用的字段:

-   `Accept-Ranges` 能接受的字节范围, 当不能处理范围请求时, 可以发送`Accept-Ranges: none`
-   `Age` 告知客户端, 源服务器在多久之前创建了响应, 字段值单位为秒
-   `ETag` 能够表示资源唯一资源的字符串 ✨
-   `Location` 令客户端重定向的 URI, 基本用在配合30x的重定向请求时提供 ✨
-   `Proxy-Authenticate` 代理服务器要求客户端的验证信息
-   `Retry-After` 和状态码 503 一起使用的首部字段，表示下次请求服务器的时间
-   `Server` 服务器的信息 ✨
-   `Vary` 代理服务器的缓存信息控制, 比如`Vary: Accept-Language`表示只能对相同自然语言的请求返回缓存
-   `WWW-Authenticate` 服务器要求客户端的验证信息

### 实体首部字段

针对请求报文和响应报文的实体部分使用首部

-   `Allow` 资源可支持 http 请求的方法 ✨
-   `Content-Encoding` 实体的编码格式, 主要有`gzip`,`compress`, `deflate`, `identity`四种
-   `Content-Language` 实体的资源语言
-   `Content-Location` 代替资源的`uri`, 与`Location`不同, 该字段表示的是报文主题返回资源对应的URI
-   `Content-Length` 实体的大小（字节）
-   `Content-Type` 实体媒体类型
-   `Content-MD5` 实体报文的摘要, 该字段无法校验内容是否被篡改
-   `Content-Range` 针对范围请求, 能告知客户端作为响应返回的实体的哪个部分符合范围请求
-   `Last-Modified` 资源最后的修改资源 ✨
-   `Expires` 实体主体的过期资源 ✨

### 非HTTP/1.1首部字段

除了这些字段, 还有比较常用的`cookie`, `set-cookie`以及`content-disposition`等等在其他RFC中定义的首部字段, 使用的频率也是很高的.

### End-to-end / Hop-by-hop

HTTP首部字段将定义成缓存代理和非缓存代理的行为, 分成2种类型.

- 端到端首部(End-to-end Header): 分在此类别中的首部会转发给请求/响应对一个的最终接受目标, 且必须保存在由缓存生成的响应中, 另外规定它必须被转发. 
- 逐跳首部(Hop-by-hop Header): 分在此类别中的首部只对单次转发有效, 会因通过缓存或代理而不再转发. HTTP/1.1和之后版本中, 如果要使用该首部, 需要提供`Connection`首部

逐跳首部字段有:

- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- Trailer
- TE
- Transfer-Encoding
- Upgrade

### Cookie 相关的首部字段

- set-cookie: 开始状态管理所使用的cookie信息, 响应首部字段
- cookie: 服务器接收到的Cookie信息, 请求首部字段

### 其他首部字段

- X-frame-Options: 属于HTTP响应首部, 用于控制网站内容在其他Web网站的Frame标签内的显示问题. 其主要目的是为了防止点击劫持(clickjacking)攻击. 其中有两个可以指定的字段:
  - DENY: 拒绝
  - SAMEORIGIN: 仅同源域名下的页面匹配的时候许可
- X-XSS-Protection: 针对跨站脚本攻击的一种策略, 用于控制浏览器XSS防护机制的开关
  - 0: 将XSS过滤设置为无效状态
  - 1: 将XSS过滤设置为有效状态
- DNT: Do Not Track. 表示拒绝被精准广告追踪的一种方法
  - 0: 同意被追踪
  - 1: 拒绝被追踪
- P3P(The Platform for Privacy Preferences, 在线隐私偏好平台)技术, 可以让web网站上的个人隐私变成一种仅供程序可理解的形式, 以达到保护用户隐私的目的.

要设置P3P, 需要:

1. 创建P3P隐私
2. 创建P3P隐私对照文件, 命名保存在`/w3c/p3p.xml`
3. 从P3P隐私中新建Compact policies后, 输出到HTTP响应中. 

## 参考链接

- [图解HTTP](https://item.jd.com/11449491.html)