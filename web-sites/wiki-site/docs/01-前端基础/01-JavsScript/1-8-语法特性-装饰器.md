# è¯­æ³•ç‰¹æ€§-Decorators

## Decoratorçš„å†å²

- 2014å¹´4æœˆ10æ—¥, Decoratorsåœ¨TC39ä¸Šå‘—æå‡º. è¿™ä¸ªææ¡ˆè¢«æ·»åŠ åˆ°TC39çš„stage0é˜¶æ®µ
- 2014å¹´10æœˆ22æ—¥, Angularå›¢é˜Ÿå®£å¸ƒAngular2.0ä¼šä½¿ç”¨AtScriptå¹¶ä¸”ç¼–è¯‘åˆ°jså’ŒDart. ä»–ä»¬è®¡åˆ’åœ¨AtScriptä¸­æ”¯æŒ:
  - ä¸‰ç§ç±»å‹æ³¨é‡Š:
    - ç±»å‹æ³¨é‡Š
    - å­—æ®µæ ‘æ³¨é‡Šæ˜¾å¼å£°æ˜
    - å…ƒæ•°æ®æ³¨é‡Š, å…·æœ‰å’Œè£…é¥°å™¨ç›¸åŒçš„è¯­æ³•, ä½†æ˜¯åªæ·»åŠ å…ƒæ•°æ®, ä¸æ”¹å¸¦æ³¨é‡Šçš„æ„é€ çš„å·¥ä½œæ–¹å¼
  - è¿è¡Œæ—¶çš„ç±»å‹æ£€æŸ¥
  - type introspection: ç±»å‹å†…çœ
- 2015å¹´1æœˆ28æ—¥, angularå’Œtså›¢é˜Ÿäº¤æ¢äº†ä¸€äº›æƒ³æ³•, 3æœˆ5æ—¥, angularå’Œtså›¢é˜Ÿå®£å¸ƒangularä»AtScriptç›´æ¥åˆ‡æ¢åˆ°ä½¿ç”¨TpeScript, Typescriptä¼šæ”¯æŒä¸€äº›AtScriptçš„ç‰¹æ€§(å°¤å…¶æ˜¯è£…é¥°å™¨çš„éƒ¨åˆ†)
- 2015å¹´3æœˆ24æ—¥, decorator ææ¡ˆè¢«æ¨è¿›åˆ°stage1,
- 2015å¹´7æœˆ20æ—¥, ts1.5å‘å¸ƒ, å¹¶ä¸”æ”¯æŒä½¿ç”¨`experimentalDecorators`å¼€å¯stage1ä¸‹çš„è£…é¥°å™¨è¶Šå‘
- 2016å¹´7æœˆ28æ—¥, decorator è¢«æ¨è¿›åˆ°stage2.
- 2022å¹´3æœˆ28æ—¥, decorator è¢«æ¨è¿›åˆ°stage3.

## ä»€ä¹ˆæ˜¯ Decorators

`Decorators`å¯ä»¥è®©æˆ‘ä»¬æ”¹å˜ä½¿ç”¨jsçš„æ„é€ å‡½æ•°(classæˆ–è€…å…¶æˆå‘˜æ–¹æ³•), æ¯”å¦‚:

```ts
class C {
  @trace
  toString() {
    return 'C';
  }
}
```

å®ç°`trace`åªéœ€è¦å†™ä¸€ä¸ªå‡½æ•°:

```ts
function trace(decoratedMethod) {
  // Returns a function that replaces `decoratedMethod`.
}
```

ä¸Šé¢çš„class Cç­‰ä»·äº:

```ts
class C {
  toString() {
    return 'C';
  }
}
C.prototype.toString = trace(C.prototype.toString);
```

æ¢å¥è¯è¯´, ä¸€ä¸ªDecoratorså°±æ˜¯ä¸€ä¸ªèƒ½å¤Ÿç”¨æ¥å½“ä¸€ä¸ªæ„é€ å™¨çš„å‡½æ•°.

ç¼–å†™å’Œä½¿ç”¨Decoratorsæ˜¯å…ƒç¼–ç¨‹çš„ä¸€ç§:

- æˆ‘ä»¬ä¸å†™ç›´æ¥å¤„ç†æ•°æ®çš„ä»£ç (ç¼–ç¨‹)
- æˆ‘ä»¬å†™çš„ä»£ç ä¼šç”¨äºå¤„ç†ç”¨æˆ·ä»£ç (å…ƒç¼–ç¨‹)

### Decorator Function

è£…é¥°å™¨å‡½æ•°åœ¨TSçš„ä¸­ç±»å‹å£°æ˜å¤§æ¦‚æ˜¯è¿™æ ·çš„:

```ts
type Decorator = (
  value: DecoratedValue, // only fields differ
  context: {
    kind: string;
    name: string | symbol;
    addInitializer(initializer: () => void): void;

    // Donâ€™t always exist:
    static: boolean;
    private: boolean;
    access: {get: () => unknown, set: (value: unknown) => void};
  }
) => void | ReplacementValue; // only fields differ
```

ä¸€ä¸ªè£…é¥°å™¨å‡½æ•°, ä¸€èˆ¬æ¥è¯´æ˜¯ä¸€ä¸ªå‡½æ•°

- value: è£…é¥°å™¨è£…é¥°çš„å‡½æ•°(ç±»æˆ–æˆå‘˜)
- contextå¯¹è±¡:
  - é™„åŠ çš„valueçš„ä¿¡æ¯
  - ä¸€ä¸ªç®€å•çš„api, ç”¨äºè¿›è¡Œå…ƒç¼–ç¨‹

`kind`å±æ€§å‘Šè¯‰è£…é¥°å™¨æ˜¯ç”¨åœ¨å“ªä¸ªJSæ„é€ å™¨ä¸Š, è¿™æ ·æˆ‘ä»¬å¯ä»¥ç”¨åŒæ ·çš„è£…é¥°å™¨æ¥åº”ç”¨åˆ°å¤šä¸ªç›®æ ‡çš„æ„é€ å™¨.

å½“å‰æ¥è¯´, åŒæ—¶æœŸå¯ä»¥ç”¨åœ¨:

- class
- method
- getter
- setter
- accessor(ä¸€ä¸ªæ–°çš„ç±»æˆå‘˜, ç¨åä»‹ç»)
- filed

å…¶ç±»å‹:

```ts
type Decorator =
  | ClassDecorator
  | ClassMethodDecorator
  | ClassGetterDecorator
  | ClassSetterDecorator
  | ClassAutoAccessorDecorator
  | ClassFieldDecorator
;
```

## è£…é¥°å™¨çš„ä½œç”¨

æ¯ä¸ªè£…é¥°å™¨éƒ½å¯ä»¥æœ‰å››ä¸ªæ–¹é¢çš„ä½œç”¨:

- å®ƒå¯ä»¥é€šè¿‡æ›´æ”¹å‚æ•°å€¼æ¥æ›´æ”¹ä¿®é¥°çš„å®ä½“ã€‚
- å®ƒå¯ä»¥é€šè¿‡è¿”å›å…¼å®¹çš„å€¼æ¥æ›¿æ¢ä¿®é¥°çš„å®ä½“.
  - `Compatible`, è£…é¥°å™¨å¿…é¡»è¿”å›ç›¸åŒç±»å‹çš„å€¼, æ¯”å¦‚classçš„è£…é¥°å™¨å¿…é¡»è¿”å›ä¸€ä¸ªå¯æ„é€ çš„å€¼
  - å¦‚æœè£…é¥°å™¨ä¸æƒ³æ›¿æ¢è£…é¥°å€¼ï¼Œå®ƒå¯ä»¥é€šè¿‡ä¸è¿”å›ä»»ä½•å†…å®¹æ¥æ˜¾å¼æˆ–éšå¼è¿”å› `undefined`
- å‘å…¶ä»–äººå±•ç¤ºå¯¹è£…é¥°å®ä½“çš„è®¿é—®æƒé™ã€‚ä¸Šä¸‹æ–‡`access`ä½¿å®ƒèƒ½å¤Ÿé€šè¿‡å…¶æ–¹æ³•`.get()`å’Œ`.set()`å®ç°è¿™ä¸€ç‚¹ã€‚
- å¤„ç†ä¿®é¥°å®ä½“åŠå…¶å®¹å™¨ï¼ˆå¦‚æœå®ƒæœ‰ä¸€ä¸ªï¼‰ï¼Œåœ¨ä¸¤è€…éƒ½å­˜åœ¨ä¹‹åï¼šè¯¥åŠŸèƒ½ç”±context.addInitializeræä¾›ã€‚å®ƒå…è®¸è£…é¥°å™¨æ³¨å†Œä¸€ä¸ªåˆå§‹å€¼è®¾å®šé¡¹â€”â€”ä¸€ä¸ªåœ¨ä¸€åˆ‡å°±ç»ªæ—¶è°ƒç”¨çš„å›è°ƒï¼ˆç¨åå°†è§£é‡Šæ›´å¤šç»†èŠ‚ï¼‰ã€‚

### èƒ½åŠ›1: æ›¿æ¢è£…é¥°å®ä½“

ä¸¾ä¾‹:

```ts
function replaceMethod() {
  return function () { // (A)
    return `How are you, ${this.name}?`;
  }
}

class Person {
  constructor(name) {
    this.name = name;
  }
  @replaceMethod
  hello() { // (B)
    return `Hi ${this.name}!`;
  }
}

const robin = new Person('Robin');
assert.equal(
  robin.hello(), 'How are you, Robin?'
);
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­, è£…é¥°å™¨`@replaceMethod`æŠŠ`hello`æ–¹æ³•æ›¿æˆäº†è‡ªå·±è¿”å›çš„å‡½æ•°.

### èƒ½åŠ›2: å‘å…¶ä»–äººå…¬å¼€å¯¹è£…é¥°å®ä½“çš„è®¿é—®

```ts
let acc;
function exposeAccess(_value, {access}) {
  acc = access;
}

class Color {
  @exposeAccess
  name = 'green'
}

const green = new Color();
assert.equal(
  green.name, 'green'
);
// Using `acc` to get and set `green.name`
assert.equal(
  acc.get.call(green), 'green'
);
acc.set.call(green, 'red');
assert.equal(
  green.name, 'red'
);
```

è£…é¥°å°†ä¸€ä¸ªå¯¹è±¡å­˜å‚¨åœ¨å˜é‡aceä¸­, è¯¥å˜é‡å…è®¸æˆ‘ä»¬è®¿é—®`green`çš„å®ä¾‹å±æ€§`color`

### èƒ½åŠ›3: å¤„ç†è£…é¥°å®ä½“åŠå…¶å®¹å™¨

```ts
function collect(_value, {name, addInitializer}) {
  addInitializer(function () { // (A)
    if (!this.collectedMethodKeys) {
      this.collectedMethodKeys = new Set();
    }
    this.collectedMethodKeys.add(name);
  });
}

class C {
  @collect
  toString() {}
  @collect
  [Symbol.iterator]() {}
}
const inst = new C();
assert.deepEqual(
  inst.collectedMethodKeys,
  new Set(['toString', Symbol.iterator])
);
```

åˆå§‹åŒ–è£…é¥°å™¨å¿…é¡»æ˜¯æ™®é€šå‡½æ•°(éç®­å¤´), å› ä¸ºthiséœ€è¦è®¿é—®éšå¼é‡‡çº³æ•°. ç®­å¤´å‡½æ•°ä¸æä¾›è¿™ç§è®¿é—®, ä»–ä»¬çš„thisæ˜¯é™æ€ä½œç”¨åŸŸçš„.

### æ±‡æ€»

| è£…é¥°å™¨ç±»å‹    | (input) => output             | .access   |
| ------------- | ----------------------------- | --------- |
| Class         | (func) => func2               | â€“         |
| Method        | (func) => func2               | {get}     |
| Getter        | (func) => func2               | {get}     |
| Setter        | (func) => func2               | {set}     |
| Auto-accessor | ({get,set}) => {get,set,init} | {get,set} |
| Field         | () => (initValue)=>initValue2 | {get,set} |

å…¶ä¸­æ¯ä¸ªå‡½æ•°ä¸­`this`çš„å€¼å¦‚ä¸‹:

| this is â†’                                | undefined | Class | Instance |
| ---------------------------------------- | --------- | ----- | -------- |
| Decorator               function         | âœ”         |       |          |
| Static                  initializer      |           | âœ”     |          |
| Non-static              initializer      |           |       | âœ”        |
| Static field decorator  result           |           | âœ”     |          |
| Non-static field        decorator result |           |       | âœ”        |


## Decorators çš„è¯­æ³•å’Œè¯­ä¹‰

### è¡¨è¾¾å¼è¯­æ³•

```
@(<<expr>>)
```

æˆ‘ä»¬å¯ä»¥è¿ç»­ä½¿ç”¨å¤šä¸ªè£…é¥°å™¨:

```ts
@myFunc
@myFuncFactory('arg1', 'arg2')

@libraryModule.prop
@someObj.method(123)

@(wrap(dict['prop'])) // arbitrary expression

class MyClass {}
```

### è£…é¥°å™¨çš„æ‰§è¡Œé¡ºåº

- `@`è¯„ä¼°: åœ¨ç±»å®šä¹‰çš„æ‰§è¡ŒæœŸé—´ç¬¦å·åçš„è¡¨è¾¾å¼, ä»¥åŠè®¡ç®—çš„å±æ€§é”®å’Œé™æ€å­—æ®µ. ç»“æœå¿…é¡»æ˜¯ä¸€ä¸ªå‡½æ•°, ä»–ä»¬å­˜å‚¨åœ¨ä¸´æ—¶ä½ç½®ä»¥ä¾¿ç¨åè°ƒç”¨
- `è°ƒç”¨`: è£…é¥°å™¨å‡½æ•°åœ¨ç±»å®šä¹‰çš„æ‰§è¡ŒæœŸé—´è¢«è°ƒç”¨, åœ¨æ–¹æ³•è¢«è¯„ä¼°ä¹‹å, æ„é€ å‡½æ•°å’ŒåŸå‹è¢«ç»„è£…ä¹‹å‰. å…¶æ‰§è¡Œç»“æœå†æ¬¡è¢«å­˜å‚¨åœ¨ä¸´æ—¶çš„ä½ç½®
- `åº”ç”¨`: è°ƒç”¨æ‰€æœ‰è£…é¥°å™¨å‡½æ•°å, ä½¿ç”¨ä»–ä»¬çš„ç»“æœ, å½±å“æ„é€ å‡½æ•°å’ŒåŸå‹. 

```ts
function decorate(str) {
  console.log(`EVALUATE @decorate(): ${str}`);
  return () => console.log(`APPLY @decorate(): ${str}`); // (A)
}
function log(str) {
  console.log(str);
  return str;
}

@decorate('class')
class TheClass {

  @decorate('static field')
  static staticField = log('static field value');

  @decorate('prototype method')
  [log('computed key')]() {}

  @decorate('instance field')
  instanceField = log('instance field value');
    // This initializer only runs if we instantiate the class
}

// Output:
// EVALUATE @decorate(): class
// EVALUATE @decorate(): static field
// EVALUATE @decorate(): prototype method
// computed key
// EVALUATE @decorate(): instance field
// APPLY @decorate(): prototype method
// APPLY @decorate(): static field
// APPLY @decorate(): instance field
// APPLY @decorate(): class
// static field value
```

### è£…é¥°å™¨åˆå§‹åŒ–å™¨è¿è¡Œçš„æ—¶æœº

- ç±»è£…é¥°å™¨åˆå§‹åŒ–å™¨åœ¨ç±»è¢«å®Œå…¨å®šä¹‰å¹¶ä¸”æ‰€æœ‰é™æ€å­—æ®µéƒ½è¢«åˆå§‹åŒ–ä¹‹åè¿è¡Œ
- éé™æ€ç±»å…ƒç´ çš„åˆå§‹åŒ–å™¨åœ¨å®ä¾‹åŒ–æœŸé—´è¿è¡Œ, åœ¨å®ä¾‹å­—æ®µè¢«åˆå§‹åŒ–ä¹‹å‰
- é™æ€ç±»å…ƒç´ è£…é¥°å™¨çš„åˆå§‹åŒ–å™¨åœ¨ç±»å®šä¹‰æœŸé—´è¿è¡Œ,åœ¨å®šä¹‰é™æ€å­—æ®µä¹‹å‰ä½†åœ¨å®šä¹‰å…¶ä»–æ‰€æœ‰ç±»å…ƒç´ ä¹‹å


## ä»è£…é¥°å™¨ä¸­æš´éœ²æ•°æ®

### å°†æš´éœ²æ•°æ®å­˜å‚¨åœ¨å‘¨è¾¹èŒƒå›´å†…

æ¯”å¦‚:

```ts
const classes = new Set(); // (A)

function collect(value, {kind, addInitializer}) {
  if (kind === 'class') {
    classes.add(value);
  }
}

@collect
class A {}
@collect
class B {}
@collect
class C {}

assert.deepEqual(
  classes, new Set([A, B, C])
);
```

### é€šè¿‡å·¥å‚å‡½æ•°ç®¡ç†æš´éœ²çš„æ•°æ®

```ts
function createClassCollector() {
  const classes = new Set();
  function collect(value, {kind, addInitializer}) {
    if (kind === 'class') {
      classes.add(value);
    }
  }
  return {
    classes,
    collect,
  };
}

const {classes, collect} = createClassCollector();

@collect
class A {}
@collect
class B {}
@collect
class C {}

assert.deepEqual(
  classes, new Set([A, B, C])
);
```

### é€šè¿‡ç±»ç®¡ç†æš´éœ²çš„æ•°æ®

```ts
class ClassCollector {
  classes = new Set();
  install = (value, {kind}) => { // (A)
    if (kind === 'class') {
      this.classes.add(value); // (B)
    }
  };
}

const collector = new ClassCollector();

@collector.install
class A {}
@collector.install
class B {}
@collector.install
class C {}
```

## ç±»è£…é¥°å™¨

```ts
type ClassDecorator = (
  value: Function,
  context: {
    kind: 'class';
    name: string | undefined;
    addInitializer(initializer: () => void): void;
  }
) => Function | void;
```

ç±»è£…é¥°å™¨çš„èƒ½åŠ›:

- æ”¹å˜è£…é¥°ç±»çš„å€¼
- é€šè¿‡è¿”å›å¯è°ƒç”¨çš„å€¼æ¥æ›¿æ¢è£…é¥°ç±»
- æ³¨å†Œåˆå§‹åŒ–å™¨, åœ¨è£…é¥°ç±»å®Œå…¨è®¾ç½®åè°ƒç”¨
- å¾—ä¸åˆ°context.access, å› ä¸ºç´¯ä¸æ˜¯å…¶ä»–è¯­è¨€ç»“æ„çš„æˆå‘˜(ä¾‹å¦‚: æ–¹æ³•æ˜¯ç±»çš„æˆå‘˜)

### ä¾‹å­: æ”¶é›†å®ä¾‹

```ts
class InstanceCollector {
  instances = new Set();
  install = (value, {kind}) => {
    if (kind === 'class') {
      const _this = this;
      return function (...args) { // (A)
        const inst = new value(...args); // (B)
        _this.instances.add(inst);
        return inst;
      };
    }
  };
}

const collector = new InstanceCollector();

@collector.install
class MyClass {}

const inst1 = new MyClass();
const inst2 = new MyClass();
const inst3 = new MyClass();

assert.deepEqual(
  collector.instances, new Set([inst1, inst2, inst3])
);
```

æˆ‘ä»¬å¯ä»¥é€šè¿‡è£…é¥°å™¨æ”¶é›†ç»™å®šç±»çš„æ‰€æœ‰å®ä¾‹.

æ³¨æ„: æˆ‘ä»¬ä¸èƒ½åœ¨`A`è¡Œè¿”å›ç®­å¤´å‡½æ•°, å› ä¸ºç®­å¤´å‡½æ•°ä¸èƒ½è¢«æ–°è°ƒç”¨. 

è¿™ä¸ªä¾‹å­çš„ç¼ºç‚¹åœ¨äºå®ƒç ´åäº†`instanceof`

```ts
assert.equal(
  inst1 instanceof MyClass,
  false
);
```

æˆ‘ä»¬æœ‰ä¸€äº›æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜:

#### 1. ç”¨`.prototype`æ‰‹åŠ¨è®¾ç½®`instanceof`:

```ts
function countInstances(value) {
  const _this = this;
  let instanceCount = 0;
  // The wrapper must be new-callable
  const wrapper = function (...args) {
    instanceCount++;
    const instance = new value(...args);
    // Change the instance
    instance.count = instanceCount;
    return instance;
  };
  wrapper.prototype = value.prototype; // (A)
  return wrapper;
}

@countInstances
class MyClass {}

const inst1 = new MyClass();
assert.ok(inst1 instanceof MyClass);
assert.equal(inst1.count, 1);

const inst2 = new MyClass();
assert.ok(inst2 instanceof MyClass);
assert.equal(inst2.count, 2);
```

å› ä¸º:

```ts
inst instanceof C
C.prototype.isPrototypeOf(inst) // ç­‰ä»·äº
```

è¿™ä¸¤è€…æ˜¯ç­‰ä»·çš„

#### 2. ç”¨`Symbol.hasInstance`

```ts
function countInstances(value) {
  const _this = this;
  let instanceCount = 0;
  // The wrapper must be new-callable
  const wrapper = function (...args) {
    instanceCount++;
    const instance = new value(...args);
    // Change the instance
    instance.count = instanceCount;
    return instance;
  };
  // Property is ready-only, so we canâ€™t use assignment
  Object.defineProperty( // (A)
    wrapper, Symbol.hasInstance,
    {
      value: function (x) {
        return x instanceof value; 
      }
    }
  );
  return wrapper;
}

@countInstances
class MyClass {}

const inst1 = new MyClass();
assert.ok(inst1 instanceof MyClass);
assert.equal(inst1.count, 1);

const inst2 = new MyClass();
assert.ok(inst2 instanceof MyClass);
assert.equal(inst2.count, 2);
```

#### 3. é€šè¿‡å­ç±»å¯ç”¨`instanceof`

```ts
function countInstances(value) {
  const _this = this;
  let instanceCount = 0;
  // The wrapper must be new-callable
  return class extends value { // (A)
    constructor(...args) {
      super(...args);
      instanceCount++;
      // Change the instance
      this.count = instanceCount;
    }
  };
}

@countInstances
class MyClass {}

const inst1 = new MyClass();
assert.ok(inst1 instanceof MyClass);
assert.equal(inst1.count, 1);

const inst2 = new MyClass();
assert.ok(inst2 instanceof MyClass);
assert.equal(inst2.count, 2);
```

## ç±»æ–¹æ³•è£…é¥°å™¨

```ts
type ClassMethodDecorator = (
  value: Function,
  context: {
    kind: 'method';
    name: string | symbol;
    static: boolean;
    private: boolean;
    access: { get: () => unknown };
    addInitializer(initializer: () => void): void;
  }
) => Function | void;
```

æ–¹æ³•è£…é¥°å™¨:

- å¯ä»¥é€šè¿‡æ”¹å˜è£…é¥°çš„æ–¹æ³•
- å¯ä»¥é€šè¿‡è¿”å›ä¸€ä¸ªå‡½æ•°æ¥æ›¿æ¢è£…é¥°æ–¹æ³•
- å¯ä»¥æ³¨å†Œåˆå§‹å€¼è®¾å®šé¡¹
- `context.access`åªèƒ½è·å–å±æ€§çš„å€¼, ä¸æ”¯æŒè®¾ç½®

æ„é€ å‡½æ•°ä¸èƒ½è¢«è£…é¥°, ä»–ä»¬åªæ˜¯çœ‹èµ·æ¥åƒæ–¹æ³•, ä½†å®é™…ä¸Šå¹¶ä¸æ˜¯æ–¹æ³•

### ä¾‹å­: è·Ÿè¸ªæ–¹æ³•è°ƒç”¨

è£…é¥°å™¨`@trace`å¯ä»¥ç”¨æ¥è·Ÿè¸ªæ–¹æ³•çš„è°ƒç”¨å’Œç»“æœè®°å½•:

```ts
function trace(value, {kind, name}) {
  if (kind === 'method') {
    return function (...args) {
      console.log(`CALL ${name}: ${JSON.stringify(args)}`);
      const result = value.apply(this, args);
      console.log('=> ' + JSON.stringify(result));
      return result;
    };
  }
}

class StringBuilder {
  #str = '';
  @trace
  add(str) {
    this.#str += str;
  }
  @trace
  toString() {
    return this.#str;
  }
}

const sb = new StringBuilder();
sb.add('Home');
sb.add('page');
assert.equal(
  sb.toString(), 'Homepage'
);

// Output:
// CALL add: ["Home"]
// => undefined
// CALL add: ["page"]
// => undefined
// CALL toString: []
// => "Homepage"
```

### ä¾‹å­: å°†æ–¹æ³•ç»‘å®šåˆ°å®ä¾‹

é€šå¸¸æˆ‘ä»¬æå–æ–¹æ³•å, thisçš„ç»‘å®šä¼šä¸¢å¤±, æˆ‘ä»¬å¯ä»¥é€šè¿‡è£…é¥°å™¨æ¥å¼ºç»‘å®š:

```ts
function bind(value, {kind, name, addInitializer}) {
  if (kind === 'method') {
    addInitializer(function () { // (B)
      this[name] = value.bind(this); // (C)
    });
  }
}

class Color2 {
  #name;
  constructor(name) {
    this.#name = name;
  }
  @bind
  toString() {
    return `Color(${this.#name})`;
  }
}

const green2 = new Color2('green');
const toString2 = green2.toString;
assert.equal(
  toString2(), 'Color(green)'
);

// The own property green2.toString is different
// from Color2.prototype.toString
assert.ok(Object.hasOwn(green2, 'toString'));
assert.notEqual(
  green2.toString,
  Color2.prototype.toString
);
```

### ä¾‹å­: å°†å‡½æ•°åº”ç”¨äºæ–¹æ³•


```ts
import { memoize } from 'lodash-es';

function applyFunction(functionFactory) {
  return (value, {kind}) => { // decorator function
    if (kind === 'method') {
      return functionFactory(value);
    }
  };
}

let invocationCount = 0;

class Task {
  @applyFunction(memoize)
  expensiveOperation(str) {
    invocationCount++;
    // Expensive processing of `str` ğŸ˜€
    return str + str;
  }
}

const task = new Task();
assert.equal(
  task.expensiveOperation('abc'),
  'abcabc'
);
assert.equal(
  task.expensiveOperation('abc'),
  'abcabc'
);
assert.equal(
  invocationCount, 1
);
```

## ç±»çš„getterè£…é¥°å™¨/setterè£…é¥°å™¨

```ts
type ClassGetterDecorator = (
  value: Function,
  context: {
    kind: 'getter';
    name: string | symbol;
    static: boolean;
    private: boolean;
    access: { get: () => unknown };
    addInitializer(initializer: () => void): void;
  }
) => Function | void;

type ClassSetterDecorator = (
  value: Function,
  context: {
    kind: 'setter';
    name: string | symbol;
    static: boolean;
    private: boolean;
    access: { set: (value: unknown) => void };
    addInitializer(initializer: () => void): void;
  }
) => Function | void;
```

getterå’Œsetterè£…é¥°å™¨å’Œæ–¹æ³•è£…é¥°å™¨çš„èƒ½åŠ›æ˜¯ç±»ä¼¼çš„.

### ä¾‹å­: å»¶è¿Ÿè®¡ç®—å€¼

- å®ç°ä¸€ä¸ªå»¶è¿Ÿè®¡ç®—å€¼çš„å±æ€§, æˆ‘ä»¬é€šè¿‡:
  - é€šè¿‡getterå®ç°è¯¥å±æ€§, è¿™æ ·è®¡ç®—å€¼çš„ä»£ç ä¼šåœ¨è¯»å–å±æ€§çš„æ—¶å€™æ‰§è¡Œ
  - ä½¿ç”¨è£…é¥°å™¨`@lazy`åŒ…è£…åŸå§‹çš„`getter`

```ts
class C {
  @lazy
  get value() {
    console.log('COMPUTING');
    return 'Result of computation';
  }
}

function lazy(value, {kind, name, addInitializer}) {
  if (kind === 'getter') {
    return function () {
      const result = value.call(this);
      Object.defineProperty( // (A)
        this, name,
        {
          value: result,
          writable: false,
        }
      );
      return result;
    };
  }
}
```

## ç±»å­—æ®µè£…é¥°å™¨

```ts
type ClassFieldDecorator = (
  value: undefined,
  context: {
    kind: 'field';
    name: string | symbol;
    static: boolean;
    private: boolean;
    access: { get: () => unknown, set: (value: unknown) => void };
    addInitializer(initializer: () => void): void;
  }
) => (initialValue: unknown) => unknown | void;
```

- å®ƒä¸èƒ½æ›´æ”¹æˆ–è€…æ›¿æ¢å­—æ®µ(éœ€è¦è‡ªåŠ¨è®¿é—®å™¨æ¥å®ç°)
- å¯ä»¥é€šè¿‡è¿”å›åŸå§‹çš„åˆå§‹åŒ–å€¼å…µè¿”å›æ–°çš„åˆå§‹åŒ–å€¼çš„å‡½æ•°æ¥æ›´æ”¹åˆå§‹åŒ–å€¼
- å¯ä»¥æ³¨å†Œåˆå§‹è®¾å®šé¡¹
- å¯ä»¥é€šè¿‡å…¬å¼€å…¶å­—æ®µçš„è®¿é—®(å³ä¾¿å®ƒæ˜¯ç§æœ‰çš„) context.access

### ä¾‹å­: æ›´æ”¹å­—æ®µçš„åˆå§‹åŒ–å€¼

```ts
function twice() {
  return initialValue => initialValue * 2;
}

class C {
  @twice
  field = 3;
}

const inst = new C();
assert.equal(
  inst.field, 6
);
```

### ä¾‹å­: åªè¯»å­—æ®µ

```ts
const readOnlyFieldKeys = Symbol('readOnlyFieldKeys');

@readOnly
class Color {
  @readOnly
  name;
  constructor(name) {
    this.name = name;
  }
}

const blue = new Color('blue');
assert.equal(blue.name, 'blue');
assert.throws(
  () => blue.name = 'brown',
  /^TypeError: Cannot assign to read only property 'name'/
);

function readOnly(value, {kind, name}) {
  if (kind === 'field') { // (A)
    return function () {
      if (!this[readOnlyFieldKeys]) {
        this[readOnlyFieldKeys] = [];
      }
      this[readOnlyFieldKeys].push(name);
    };
  }
  if (kind === 'class') { // (B)
    return function (...args) {
      const inst = new value(...args);
      for (const key of inst[readOnlyFieldKeys]) {
        Object.defineProperty(inst, key, {writable: false});
      }
      return inst;
    }
  }
}
```

1. é¦–å…ˆæ”¶é›†åªè¯»å­—æ®µçš„æ‰€æœ‰é”®(A)
2. ç­‰å®ä¾‹å®Œå…¨è®¾ç½®å®Œæˆ, å¹¶ä½¿æˆ‘ä»¬æ”¶é›†é½å¯†é’¥çš„å­—æ®µä¸å¯å†™(B)

### ä¾‹å­: ä¾èµ–æ³¨å…¥, å®ä¾‹å…¬å…±å­—æ®µ.

```ts
const {registry, inject} = createRegistry();

class Logger {
  log(str) {
    console.log(str);
  }
}
class Main {
  @inject logger;
  run() {
    this.logger.log('Hello!');
  }
}

registry.register('logger', Logger);
new Main().run();

// Output:
// Hello!
```

å…¶ä¸­`createRegistry`å®ç°å¦‚ä¸‹:

```ts
function createRegistry() {
  const nameToClass = new Map();
  const nameToInstance = new Map();
  const registry = {
    register(name, componentClass) {
      nameToClass.set(name, componentClass);
    },
    getInstance(name) {
      if (nameToInstance.has(name)) {
        return nameToInstance.get(name);
      }
      const componentClass = nameToClass.get(name);
      if (componentClass === undefined) {
        throw new Error('Unknown component name: ' + name);
      }
      const inst = new componentClass();
      nameToInstance.set(name, inst);
      return inst;
    },
  }; 
  function inject (_value, {kind, name}) {
    if (kind === 'field') {
      return () => registry.getInstance(name);
    }
  }
  return {registry, inject};
}
```

### ä¾‹å­: "æœ‹å‹"å¯è§æ€§

æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†ç±»çš„å­—æ®µè®¾ç½®ä¸ºç§æœ‰æ¥æ›´æ”¹æŸäº›ç±»æˆå‘˜çš„å¯è§æ€§. ä»¥é˜²å®ƒä»¬è¢«å…¬å¼€è®¿é—®.

æœ‹å‹å¯è§æ€§æŒ‡çš„æ˜¯å…è®¸ä¸€äº›"æœ‹å‹"æ¥è®¿é—®ä¸€äº›ç§æœ‰æˆå‘˜ç±»å‹.

æ¯”å¦‚:

```ts
const friendName = new Friend();

class ClassWithSecret {
  @friendName.install #name = 'Rumpelstiltskin';
  getName() {
    return this.#name;
  }
}

// Everyone who has access to `secret`, can access inst.#name
const inst = new ClassWithSecret();
assert.equal(
  friendName.get(inst), 'Rumpelstiltskin'
);
friendName.set(inst, 'Joe');
assert.equal(
  inst.getName(), 'Joe'
);
```

å…¶ä¸­`Friend`çš„å®ç°å¦‚ä¸‹:

```ts
class Friend {
  #access = undefined;
  #getAccessOrThrow() {
    if (this.#access === undefined) {
      throw new Error('The friend decorator wasnâ€™t used yet');
    }
    return this.#access;
  }
  // An instance property whose value is a function whose `this`
  // is fixed (bound to the instance).
  install = (_value, {kind, access}) => {
    if (kind === 'field') {
      if (this.#access) {
        throw new Error('This decorator can only be used once');
      }
      this.#access = access;
    }
  }
  get(inst) {
    return this.#getAccessOrThrow().get.call(inst);
  }
  set(inst, value) {
    return this.#getAccessOrThrow().set.call(inst, value);
  }
}
```

### ä¾‹å­: æšä¸¾

æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥å®ç°æšä¸¾, OOPé£æ ¼çš„æ–¹æ³•æ˜¯ä½¿ç”¨ç±»å’Œé™æ€å±æ€§:

```ts
class Color {
  static red = new Color('red');
  static green = new Color('green');
  static blue = new Color('blue');
  constructor(enumKey) {
    this.enumKey = enumKey;
  }
  toString() {
    return `Color(${this.enumKey})`;
  }
}
assert.equal(
  Color.green.toString(),
  'Color(green)'
);
```

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è£…é¥°å™¨æ¥è‡ªåŠ¨çš„:

- ä»æšä¸¾é”®åˆ›å»ºä¸€ä¸ªæ˜ å°„åˆ°æšä¸¾å€¼
- å°†æšä¸¾é”®æ·»åŠ åˆ°æšä¸¾å€¼--æ— éœ€å°†å®ƒä»¬ä¼ é€’ç»™æ„é€ å‡½æ•°

ç±»ä¼¼è¿™æ ·:

```ts
function enumEntry(value, {kind, name}) {
  if (kind === 'field') {
    return function (initialValue) {
      if (!Object.hasOwn(this, 'enumFields')) {
        this.enumFields = new Map();
      }
      this.enumFields.set(name, initialValue);
      initialValue.enumKey = name;
      return initialValue;
    };
  }
}

class Color {
  @enumEntry static red = new Color();
  @enumEntry static green = new Color();
  @enumEntry static blue = new Color();
  toString() {
    return `Color(${this.enumKey})`;
  }
}
assert.equal(
  Color.green.toString(),
  'Color(green)'
);
assert.deepEqual(
  Color.enumFields,
  new Map([
    ['red', Color.red],
    ['green', Color.green],
    ['blue', Color.blue],
  ])
);
```

## è‡ªåŠ¨è®¿é—®å™¨

è£…é¥°å™¨ææ¡ˆå¼•å…¥äº†ä¸€ä¸ªæ–°çš„è¯­è¨€ç‰¹æ€§: è‡ªåŠ¨è®¿é—®å™¨

é€šè¿‡å°†å…³é”®è¯æ”¾åœ¨`accessor`ç±»å­—æ®µä¹‹å‰æ¥åˆ›å»ºè‡ªåŠ¨è®¿é—®å™¨. å®ƒæƒ³å­—æ®µä¸€æ ·ä½¿ç”¨, ä½†æ˜¯è¿è¡Œæ—¶æœ‰ä¸åŒçš„æ–¹å¼æ¥å®ç°:

```ts
class C {
  static accessor myField1;
  static accessor #myField2;
  accessor myField3;
  accessor #myField4;
}
```

å­—æ®µå’Œè‡ªåŠ¨è®¿é—®å™¨æœ‰ä»€ä¹ˆä¸åŒ?

- ä¸€ä¸ªå­—æ®µåˆ›å»º:
  - å±æ€§
  - ä¸“ç”¨æ’æ§½
- è‡ªåŠ¨è®¿é—®å™¨ä¸ºæ•°æ®åˆ›å»ºä¸€ä¸ªç§æœ‰æ§½, å¹¶ä¸”:
  - å…¬å…±`getter-setter`å¯¹
  - ç§æœ‰`getter-setter`å¯¹: ç§æœ‰æ’æ§½ä¸ä¼šè¢«ç»§æ‰¿, æ‰€ä»¥æ°¸è¿œä¸ä¼šä½äºåŸå‹ä¸­.


æ¯”å¦‚ä¸‹é¢è¿™ä¸ªç±»:

```ts
class C {
  accessor str = 'abc';
}
const inst = new C();

assert.equal(
  inst.str, 'abc'
);
inst.str = 'def';
assert.equal(
  inst.str, 'def'
);
```

å®ƒåœ¨å†…éƒ¨çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:

```ts
class C {
  #str = 'abc';
  get str() {
    return this.#str;
  }
  set str(value) {
    this.#str = value;
  }
}
```

### ä¸ºä»€ä¹ˆéœ€è¦

1. ä»–ä»¬åªå½±å“åˆå§‹åŒ–çš„å€¼å­—æ®µ
2. ä»–ä»¬å¯ä»¥å®Œå…¨å–ä»£è‡ªåŠ¨å­˜å–å™¨

æ¯å½“è£…é¥°å™¨éœ€è¦æ¯”å­—æ®µæ›´å¤šçš„æ§åˆ¶èƒ½åŠ›æ—¶, æˆ‘ä»¬å°±å¿…é¡»ä½¿ç”¨è‡ªåŠ¨è®¿é—®å™¨, è€Œä¸æ˜¯å­—æ®µ

## ç±»è‡ªåŠ¨è®¿é—®è£…é¥°å™¨

```ts
type ClassAutoAccessorDecorator = (
  value: {
    get: () => unknown;
    set: (value: unknown) => void;
  },
  context: {
    kind: 'accessor';
    name: string | symbol;
    static: boolean;
    private: boolean;
    access: { get: () => unknown, set: (value: unknown) => void };
    addInitializer(initializer: () => void): void;
  }
) => {
  get?: () => unknown;
  set?: (value: unknown) => void;
  init?: (initialValue: unknown) => unknown;
} | void;
```

- å®ƒèƒ½é€šè¿‡æ°”å‚æ•°æ¥å—è‡ªåŠ¨è®¿é—®å™¨çš„`getter`å’Œ`setter`
- å®ƒå¯ä»¥é€šè¿‡å‘æŒ¥å¸¦æœ‰æ–¹æ³•`.get()`æ¥æ›¿æ¢ä¿®é¥°çš„è‡ªåŠ¨è®¿é—®å™¨`.set()`
- å®ƒå¯ä»¥é€šè¿‡ä½¿ç”¨æ–¹æ³•è¿”å›ä¸€ä¸ªå¯¹è±¡æ¥å½±å“è‡ªåŠ¨è®¿é—®å™¨çš„åˆå§‹å€¼
- å®ƒå¯ä»¥æ³¨å†Œåˆå§‹å€¼è®¾å®šé¡¹.


### ä¾‹å­: åªè¯»è‡ªåŠ¨è®¿é—®å™¨

```ts
const UNINITIALIZED = Symbol('UNINITIALIZED');
function readOnly({get,set}, {name, kind}) {
  if (kind === 'accessor') {
    return {
      init() {
        return UNINITIALIZED;
      },
      get() {
        const value = get.call(this);
        if (value === UNINITIALIZED) {
          throw new TypeError(
            `Accessor ${name} hasnâ€™t been initialized yet`
          );
        }
        return value;
      },
      set(newValue) {
        const oldValue = get.call(this);
        if (oldValue !== UNINITIALIZED) {
          throw new TypeError(
            `Accessor ${name} can only be set once`
          );
        }
        set.call(this, newValue);
      },
    };
  }
}

class Color {
  @readOnly
  accessor name;
  constructor(name) {
    this.name = name;
  }
}

const blue = new Color('blue');
assert.equal(blue.name, 'blue');
assert.throws(
  () => blue.name = 'yellow',
  /^TypeError: Accessor name can only be set once$/
);

const orange = new Color('orange');
assert.equal(orange.name, 'orange');
```


## å‚è€ƒ

- [JavaScript metaprogramming with the 2022-03 decorators API](https://2ality.com/2022/10/javascript-decorators.html)